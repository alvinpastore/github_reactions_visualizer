{"568405899": {"author_username": "tspiteri", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69316, "title": "Feature request: From<&[T]> for NonNull<T> ", "body": "While `NonNull<T>` implements `From<&T>`, it does not implement `From<&[T]>`. Current options:\r\n\r\n1. Use `NonNull::new(slice.as_ptr() as *mut T).unwrap()`, and rely on the optimizer to remove the unwrap.\r\n2. Use `unsafe { NonNull::new_unchecked(slice.as_ptr() as *mut T) }`, which is correct but unfortunately has to use `unsafe`.\r\n3. It is tempting to use `NonNull::from(&slice[0])`, which looks more ergonomic than 1 and 2, but has incorrect pointer provenance.\r\n\r\nSince both references and slices have `as_ptr` and `as_mut_ptr` methods, I think that `NonNull` should implement `From` for slices as well as for references.", "labels": [], "number_of_comments": 1, "created_at": "2020-02-20 16:06:02", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "568392415": {"author_username": "alexcrichton", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69315, "title": "Macro-expanded public struct no longer considered public", "body": "I had https://github.com/rustwasm/wasm-bindgen/issues/2009 opened up on a project recently but this looks to be a regression I think. This regressed between nightly-2020-02-19 and nightly-2020-02-20, and bisecting further by commit reveals https://github.com/rust-lang/rust/pull/69271 as the culprit. I'm not sure which of the PRs in that rollup though are the culprit here.\r\n\r\nThis can be reproduced by running `cargo check` from the `crates/js-sys` folder in the wasm-bindgen repository. Unfortunately this one probably isn't super easy to reproduce, so I'm hoping that someone more knowledgeable can hopefully take a look at this and have a better idea about what's going on. \r\n\r\nThere's definitely macros going on in `#[wasm_bindgen]` (the `Memory` type is synthesized by a macro), which leads me to think that https://github.com/rust-lang/rust/pull/69211 may be the culprit? (cc @petrochenkov)", "labels": ["A-parser", "A-visibility", "I-nominated", "T-compiler", "regression-from-stable-to-nightly"], "number_of_comments": 0, "created_at": "2020-02-20 15:45:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "568379052": {"author_username": "nkbai", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69314, "title": "Wrong compiler error description", "body": " \r\nI tried this code:\r\n\r\n```rust\r\n struct A {}\r\nstruct Msg<'a> {\r\n    s: &'a [i32],\r\n}\r\nimpl A {\r\n    async fn g(buf: &[i32]) -> Msg<'_> {\r\n        Msg { s: &buf[0..1] }\r\n    }\r\n    async fn f() {\r\n        let mut buf = [0; 512];\r\n        let m2 = &buf[..];\r\n        let m = Self::g(m2).await;\r\n        Self::f2(m).await;\r\n    }\r\n    async fn f2(m: Msg /*<'_>*/) {}\r\n}\r\n```\r\n\r\nI expected to  report error on function `f2` only,\r\n```log\r\nerror[E0726]: implicit elided lifetime not allowed here\r\n  --> src/lib.rs:15:20\r\n   |\r\n15 |     async fn f2(m: Msg /*<'_>*/) {}\r\n   |                    ^^^- help: indicate the anonymous lifetime: `<'_>`\r\n```\r\nInstead, it has error following:\r\n```log\r\n  Compiling playground v0.0.1 (/playground)\r\nerror[E0726]: implicit elided lifetime not allowed here\r\n  --> src/lib.rs:15:20\r\n   |\r\n15 |     async fn f2(m: Msg /*<'_>*/) {}\r\n   |                    ^^^- help: indicate the anonymous lifetime: `<'_>`\r\n\r\nwarning: variable does not need to be mutable\r\n  --> src/lib.rs:10:13\r\n   |\r\n10 |         let mut buf = [0; 512];\r\n   |             ----^^^\r\n   |             |\r\n   |             help: remove this `mut`\r\n   |\r\n   = note: `#[warn(unused_mut)]` on by default\r\n\r\nerror[E0597]: `buf` does not live long enough\r\n  --> src/lib.rs:11:19\r\n   |\r\n11 |         let m2 = &buf[..];\r\n   |                   ^^^\r\n   |                   |\r\n   |                   borrowed value does not live long enough\r\n   |                   cast requires that `buf` is borrowed for `'static`\r\n...\r\n14 |     }\r\n   |     - `buf` dropped here while still borrowed\r\n\r\nerror: aborting due to 2 previous errors\r\n\r\nFor more information about this error, try `rustc --explain E0597`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\nthere should be no error E0597. \r\n\r\nyou  can test on [playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=f4fc8c9feb924f9344e48564a88eec5d)\r\n\r\n### Meta\r\n \r\n \r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.43.0-nightly (0176a9eef 2020-02-17)\r\nbinary: rustc\r\ncommit-hash: 0176a9eef845e7421b7e2f7ef015333a41a7c027\r\ncommit-date: 2020-02-17\r\nhost: x86_64-apple-darwin\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n\r\n```\r\n\r\n ", "labels": ["A-diagnostics", "A-lifetimes", "C-bug", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-20 15:25:44", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "568378518": {"author_username": "hsivonen", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69313, "title": "ICE with rustc claiming non-constant shuffle indices when they are constant (block.rs:622)", "body": "### Code\r\n\r\n```rust\r\n#[macro_use(shuffle)]\r\nextern crate packed_simd;\r\n\r\nuse packed_simd::u8x16;\r\n\r\npub fn boom(s: u8x16) -> u8x16 {\r\n    unsafe {\r\n        let first: u8x16 = shuffle!(\r\n            s,\r\n            u8x16::splat(0),\r\n            [0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23]\r\n        );\r\n        first\r\n    }\r\n}\r\n```\r\n\r\nWith\r\n\r\n```toml\r\npacked_simd = \"0.3.3\"\r\n```\r\n\r\nin Cargo.toml\r\n\r\n### Meta\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.43.0-nightly (7760cd0fb 2020-02-19)\r\nbinary: rustc\r\ncommit-hash: 7760cd0fbbbf2c59a625e075a5bdfa88b8e30f8a\r\ncommit-date: 2020-02-19\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\n### Error output\r\n\r\n```\r\nerror: internal compiler error: src/librustc_codegen_ssa/mir/block.rs:622: shuffle indices must be constant\r\n  --> src/lib.rs:8:28\r\n   |\r\n8  |           let first: u8x16 = shuffle!(\r\n   |  ____________________________^\r\n9  | |             s,\r\n10 | |             u8x16::splat(0),\r\n11 | |             [0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23]\r\n12 | |         );\r\n   | |_________^\r\n   |\r\n   = note: this error: internal compiler error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\r\n\r\nthread 'rustc' panicked at 'Box<Any>', <::std::macros::panic macros>:2:4\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-nightly (7760cd0fb 2020-02-19) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `simdice`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary><strong>Backtrace</strong></summary>\r\n<p>\r\n\r\n```\r\nerror: internal compiler error: src/librustc_codegen_ssa/mir/block.rs:622: shuffle indices must be constant\r\n  --> src/lib.rs:8:28\r\n   |\r\n8  |           let first: u8x16 = shuffle!(\r\n   |  ____________________________^\r\n9  | |             s,\r\n10 | |             u8x16::splat(0),\r\n11 | |             [0, 16, 1, 17, 2, 18, 3, 19, 4, 20, 5, 21, 6, 22, 7, 23]\r\n12 | |         );\r\n   | |_________^\r\n   |\r\n   = note: this error: internal compiler error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\r\n\r\nthread 'rustc' panicked at 'Box<Any>', <::std::macros::panic macros>:2:4\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.44/src/backtrace/libunwind.rs:86\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.44/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:78\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1428\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:474\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::span_bug\r\n  14: rustc_errors::Handler::span_bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::span_bug_fmt\r\n  20: <core::iter::adapters::Map<I,F> as core::iter::traits::iterator::Iterator>::fold\r\n  21: rustc_codegen_ssa::mir::block::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_call_terminator\r\n  22: rustc_codegen_ssa::mir::block::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_block\r\n  23: rustc_codegen_ssa::base::codegen_instance\r\n  24: <rustc::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt>::define\r\n  25: rustc_codegen_llvm::base::compile_codegen_unit::module_codegen\r\n  26: rustc::dep_graph::graph::DepGraph::with_task\r\n  27: rustc_codegen_llvm::base::compile_codegen_unit\r\n  28: rustc_codegen_ssa::base::codegen_crate\r\n  29: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  30: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  31: rustc_interface::passes::QueryContext::enter\r\n  32: rustc_interface::queries::Queries::ongoing_codegen\r\n  33: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  34: scoped_tls::ScopedKey<T>::set\r\n  35: syntax::attr::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-nightly (7760cd0fb 2020-02-19) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `simdice`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n### Additional Info\r\n\r\nCompiler rustc 1.43.0-nightly (5e7af4669 2020-02-16) worked.", "labels": ["A-simd", "C-bug", "I-ICE", "T-compiler", "regression-from-stable-to-nightly", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-02-20 15:24:59", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "568355365": {"author_username": "gwafotapa", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69312, "title": "Compiler crash following out of bounds access in a zero sized array", "body": "Here's the crashing code I came down to:\r\n\r\n- An empty main.rs\r\n- lib.rs contains a single line: \"pub mod matrix.rs\"\r\n- a file matrix.rs with the following code:\r\n\r\npub struct Bug {\r\n    field: usize,\r\n}\r\n\r\nimpl Bug {\r\n    pub fn test(&self) {\r\n        let cols = [self.field; 0];\r\n        cols[self.field];\r\n    }\r\n}\r\n\r\n\r\nThis happened as I permuted type and size in my array definition. My intention was not to declare a zero sized array but to declare an array filled with zeros. Anyway, the compiler crashed. I noticed that if I remove the \"pub\" from the line in lib.rs, it compiles fine.\r\n\r\n\r\n## Meta\r\n\r\n\r\nrustc --verbose --version:\r\n\r\nrustc 1.41.0 (5e1a79984 2020-01-27)\r\nbinary: rustc\r\ncommit-hash: 5e1a799842ba6ed4a57e91f7ab9435947482f7d8\r\ncommit-date: 2020-01-27\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.41.0\r\nLLVM version: 9.0\r\n\r\n\r\nBacktrace:\r\n\r\n   Compiling bug v0.1.0 (/home/guillaume/projects/bug)\r\nthread 'rustc' panicked at 'assertion failed: `(left == right)`\r\n  left: `8`,\r\n right: `0`', src/librustc/mir/interpret/value.rs:319:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:84\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:61\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1025\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:65\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:50\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:193\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:210\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:475\r\n  12: rust_begin_unwind\r\n             at src/libstd/panicking.rs:375\r\n  13: std::panicking::begin_panic_fmt\r\n             at src/libstd/panicking.rs:326\r\n  14: rustc_mir::interpret::visitor::ValueVisitor::walk_value\r\n  15: rustc_mir::interpret::validity::<impl rustc_mir::interpret::eval_context::InterpCx<M>>::validate_operand\r\n  16: <rustc_mir::transform::const_prop::ConstPropagator as rustc::mir::visit::MutVisitor>::visit_statement\r\n  17: <rustc_mir::transform::const_prop::ConstProp as rustc_mir::transform::MirPass>::run_pass\r\n  18: rustc_mir::transform::run_passes\r\n  19: rustc_mir::transform::run_optimization_passes\r\n  20: rustc_mir::transform::optimized_mir\r\n  21: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::optimized_mir>::compute\r\n  22: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  23: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  24: rustc::ty::<impl rustc::ty::context::TyCtxt>::instance_mir\r\n  25: rustc_mir::monomorphize::collector::collect_items_rec\r\n  26: rustc_mir::monomorphize::collector::collect_crate_mono_items::{{closure}}\r\n  27: rustc::util::common::time\r\n  28: rustc_mir::monomorphize::collector::collect_crate_mono_items\r\n  29: rustc::util::common::time\r\n  30: rustc_mir::monomorphize::partitioning::collect_and_partition_mono_items\r\n  31: rustc::ty::query::__query_compute::collect_and_partition_mono_items\r\n  32: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  33: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  34: rustc_codegen_ssa::back::symbol_export::exported_symbols_provider_local\r\n  35: rustc::ty::query::__query_compute::exported_symbols\r\n  36: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  37: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  38: rustc_metadata::rmeta::encoder::EncodeContext::encode_crate_root\r\n  39: rustc::ty::context::tls::with_context::{{closure}}\r\n  40: rustc_metadata::rmeta::encoder::encode_metadata\r\n  41: rustc_metadata::rmeta::decoder::cstore_impl::<impl rustc::middle::cstore::CrateStore for rustc_metadata::creader::CStore>::encode_metadata\r\n  42: rustc::ty::context::TyCtxt::encode_metadata\r\n  43: rustc_interface::passes::start_codegen::{{closure}}\r\n  44: rustc_interface::passes::start_codegen\r\n  45: rustc::ty::context::tls::enter_global\r\n  46: rustc_interface::queries::Queries::ongoing_codegen\r\n  47: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  48: std::thread::local::LocalKey<T>::with\r\n  49: scoped_tls::ScopedKey<T>::set\r\n  50: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.41.0 (5e1a79984 2020-01-27) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [optimized_mir] processing `matrix::Bug::test`\r\n#1 [collect_and_partition_mono_items] collect_and_partition_mono_items\r\n#2 [exported_symbols] exported_symbols\r\nend of query stack\r\nerror: could not compile `bug`.", "labels": [], "number_of_comments": 0, "created_at": "2020-02-20 14:53:36", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "568298892": {"author_username": "GuillaumeGomez", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69311, "title": "Clean up E0321 and E0322", "body": "r? @Dylan-DPC ", "labels": ["S-waiting-on-review"], "number_of_comments": 0, "created_at": "2020-02-20 13:27:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "568277590": {"author_username": "dwrensha", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69310, "title": "internal compiler error: src/librustc_mir_build/hair/constant.rs:60: impossible case reached", "body": "I'm seeing an internal compiler error on the following input (found by [fuzz-rustc](https://github.com/dwrensha/fuzz-rustc)):\r\n\r\n```rust\r\nconst X: [(); 0.1] = [()];\r\nfn main() {}\r\n```\r\n\r\n```\r\n$ rustc main.rs\r\nerror: internal compiler error: src/librustc_mir_build/hair/constant.rs:60: impossible case reached\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:881:9\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-nightly (7760cd0fb 2020-02-19) running on x86_64-unknown-linux-gnu\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\nThe error happens on `nightly` and `beta`, but not on `stable`.\r\n\r\n<details>\r\n<summary>Nightly backtrace</summary>\r\n\r\n```\r\n\r\nerror: internal compiler error: src/librustc_mir_build/hair/constant.rs:60: impossible case reached\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:881:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.44/src/backtrace/libunwind.rs:86\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.44/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:78\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1428\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:474\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc_mir_build::hair::constant::lit_to_const\r\n  21: rustc::ty::query::__query_compute::lit_to_const\r\n  22: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::lit_to_const>::compute\r\n  23: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  24: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  25: <dyn rustc_typeck::astconv::AstConv>::ast_const_to_const\r\n  26: <dyn rustc_typeck::astconv::AstConv>::ast_ty_to_ty\r\n  27: rustc_typeck::collect::type_of::type_of\r\n  28: rustc::ty::query::__query_compute::type_of\r\n  29: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::type_of>::compute\r\n  30: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  31: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  32: <rustc_typeck::collect::CollectItemTypesVisitor as rustc_hir::intravisit::Visitor>::visit_item\r\n  33: rustc::hir::map::Map::visit_item_likes_in_module\r\n  34: rustc_typeck::collect::collect_mod_item_types\r\n  35: rustc::ty::query::__query_compute::collect_mod_item_types\r\n  36: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::collect_mod_item_types>::compute\r\n  37: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  38: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  39: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::ensure_query\r\n  40: rustc_session::session::Session::track_errors\r\n  41: rustc_typeck::check_crate\r\n  42: rustc_interface::passes::analysis\r\n  43: rustc::ty::query::__query_compute::analysis\r\n  44: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  45: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  46: rustc::ty::context::tls::enter_global\r\n  47: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  48: scoped_tls::ScopedKey<T>::set\r\n  49: syntax::attr::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-nightly (7760cd0fb 2020-02-19) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C codegen-units=1 -C debuginfo=2 --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [lit_to_const] converting literal to const\r\n#1 [type_of] processing `X`\r\n#2 [collect_mod_item_types] collecting item types in top-level module\r\n#3 [analysis] running analysis passes on this crate\r\nend of query stack\r\n```\r\n\r\n</details>", "labels": ["A-const-eval", "C-bug", "E-needs-bisection", "I-ICE", "P-high", "T-compiler", "regression-from-stable-to-beta"], "number_of_comments": 1, "created_at": "2020-02-20 12:50:18", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "568096687": {"author_username": "Kumassy", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69307, "title": "ICE: src/librustc/middle/region.rs:1037: Encountered greater count 28", "body": "<!--\r\nThank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\r\na minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\r\nhow to create smaller examples.\r\n\r\nhttp://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\r\n\r\n-->\r\n\r\n### Code\r\n\r\n```rust\r\nuse tokio::prelude::*;\r\nuse tokio::runtime::Runtime;\r\nuse tokio::sync::mpsc;\r\n\r\nfn main() {\r\n    let mut rt = Runtime::new().unwrap();\r\n    let mut sum = 0;\r\n    sum += rt.block_on(async {\r\n        let (tx, mut rx) = mpsc::unbounded_channel();\r\n        tx.send(1).unwrap();\r\n\r\n        while let Some(res) = rx.recv().await {\r\n            println!(\"{:?}\", res);\r\n        }\r\n        1\r\n    });\r\n}\r\n```\r\n[Playground Link](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c17ef0f007c49e9baf5e449317ca28ed)\r\n\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.41.0 (5e1a79984 2020-01-27)\r\nbinary: rustc\r\ncommit-hash: 5e1a799842ba6ed4a57e91f7ab9435947482f7d8\r\ncommit-date: 2020-01-27\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.41.0\r\nLLVM version: 9.0\r\n```\r\n\r\nSame issue still exists in `rustc +beta --version --verbose`:\r\n```\r\nrustc 1.42.0-beta.3 (86f329b41 2020-02-07)\r\nbinary: rustc\r\ncommit-hash: 86f329b419dbac59da59e2ac7d6e21e5eb679ec7\r\ncommit-date: 2020-02-07\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.42.0-beta.3\r\nLLVM version: 9.0\r\n```\r\n\r\nand also in `rustc +nightly --version --verbose`:\r\n```\r\nrustc 1.43.0-nightly (7760cd0fb 2020-02-19)\r\nbinary: rustc\r\ncommit-hash: 7760cd0fbbbf2c59a625e075a5bdfa88b8e30f8a\r\ncommit-date: 2020-02-19\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\n\r\n### Error output\r\n\r\n```\r\nerror: internal compiler error: src/librustc/middle/region.rs:1037: Encountered greater count 28 at span src/main.rs:13:31: 13:46 - expected no greater than 12\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:905:9\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.41.0 (5e1a79984 2020-01-27) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary><strong>Backtrace</strong></summary>\r\n<p>\r\n\r\n```\r\nerror: internal compiler error: src/librustc/middle/region.rs:1037: Encountered greater count 28 at span src/main.rs:13:31: 13:46 - expected no greater than 12\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:905:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:84\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:61\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1025\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:65\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:50\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:193\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:210\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:475\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc::middle::region::resolve_expr\r\n  21: <rustc::middle::region::RegionResolutionVisitor as rustc::hir::intravisit::Visitor>::visit_stmt\r\n  22: <rustc::middle::region::RegionResolutionVisitor as rustc::hir::intravisit::Visitor>::visit_block\r\n  23: rustc::middle::region::resolve_expr\r\n  24: <rustc::middle::region::RegionResolutionVisitor as rustc::hir::intravisit::Visitor>::visit_body\r\n  25: rustc::middle::region::region_scope_tree\r\n  26: rustc::ty::query::__query_compute::region_scope_tree\r\n  27: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::region_scope_tree>::compute\r\n  28: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  29: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  30: rustc_typeck::check::generator_interior::resolve_interior\r\n  31: rustc_typeck::check::FnCtxt::resolve_generator_interiors\r\n  32: rustc::ty::context::tls::with_context::{{closure}}\r\n  33: rustc_typeck::check::typeck_tables_of\r\n  34: rustc::ty::query::__query_compute::typeck_tables_of\r\n  35: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::typeck_tables_of>::compute\r\n  36: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  37: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  38: rustc::ty::query::__query_compute::typeck_tables_of\r\n  39: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::typeck_tables_of>::compute\r\n  40: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  41: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  42: rustc_typeck::collect::type_of\r\n  43: rustc::ty::query::__query_compute::type_of\r\n  44: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::type_of>::compute\r\n  45: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  46: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  47: rustc::hir::intravisit::walk_expr\r\n  48: rustc::hir::intravisit::walk_expr\r\n  49: rustc::hir::intravisit::walk_expr\r\n  50: rustc::hir::intravisit::walk_block\r\n  51: rustc::hir::intravisit::Visitor::visit_fn\r\n  52: rustc::hir::intravisit::walk_item\r\n  53: <rustc_typeck::collect::CollectItemTypesVisitor as rustc::hir::intravisit::Visitor>::visit_item\r\n  54: rustc::hir::map::Map::visit_item_likes_in_module\r\n  55: rustc_typeck::collect::collect_mod_item_types\r\n  56: rustc::ty::query::__query_compute::collect_mod_item_types\r\n  57: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::collect_mod_item_types>::compute\r\n  58: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  59: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  60: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::ensure_query\r\n  61: rustc_typeck::check_crate::{{closure}}::{{closure}}\r\n  62: rustc::util::common::time\r\n  63: rustc_typeck::check_crate\r\n  64: rustc_interface::passes::analysis\r\n  65: rustc::ty::query::__query_compute::analysis\r\n  66: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  67: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  68: rustc::ty::context::tls::enter_global\r\n  69: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  70: std::thread::local::LocalKey<T>::with\r\n  71: scoped_tls::ScopedKey<T>::set\r\n  72: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.41.0 (5e1a79984 2020-01-27) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [region_scope_tree] processing `main`\r\n#1 [typeck_tables_of] processing `main`\r\n#2 [typeck_tables_of] processing `main::{{closure}}#0`\r\n#3 [type_of] processing `main::{{closure}}#0`\r\n#4 [collect_mod_item_types] collecting item types in top-level module\r\n#5 [analysis] running analysis passes on this crate\r\nend of query stack\r\nerror: aborting due to previous error\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n", "labels": ["A-async-await", "C-bug", "I-ICE", "I-nominated", "P-high", "T-compiler"], "number_of_comments": 4, "created_at": "2020-02-20 07:10:26", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "568022980": {"author_username": "arucil", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69306, "title": "Inconsistent Self behavior with generic structs", "body": "Summary from @pnkfelix : `Self` used as a tuple-struct constructor function should use the fully type-substituted form from the `impl` block, but does not.\r\n\r\n\r\nThus, today this code is accepted, but it should not be.\r\n\r\n```rust\r\nstruct _Bar<T>(T);\r\n\r\nimpl<T> _Bar<T> {\r\n    fn _map1<U>(x: U) -> _Bar<U> {\r\n        Self(x)\r\n    }\r\n}\r\n```\r\n\r\n(Fixing this would be a breaking-change, so we should take care in how we deploy it.)\r\n\r\nOriginal bug report follows:\r\n\r\n----\r\n\r\n<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI tried this code:\r\n\r\n```rust\r\nstruct _Foo<T> {\r\n    x: T\r\n}\r\n\r\nimpl<T> _Foo<T> {\r\n    fn _map<U>(x: U) -> _Foo<U> {\r\n        Self { x }\r\n    }\r\n}\r\n\r\nstruct _Bar<T>(T);\r\n\r\nimpl<T> _Bar<T> {\r\n    fn _map<U>(x: U) -> _Bar<U> {\r\n        Self(x)\r\n    }\r\n}\r\n```\r\n\r\nIn nightly rustc, `_Bar` compiles while `_Foo` yields a type mismatch error:\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n  --> src/main.rs:10:16\r\n   |\r\n8  | impl<T> _Foo<T> {\r\n   |      - expected type parameter\r\n9  |     fn _map<U>(x: U) -> _Foo<U> {\r\n   |             - found type parameter\r\n10 |         Self { x }\r\n   |                ^ expected type parameter `T`, found type parameter `U`\r\n   |\r\n```", "labels": ["C-bug", "I-nominated", "P-high", "T-compiler"], "number_of_comments": 6, "created_at": "2020-02-20 03:17:31", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "568002613": {"author_username": "estebank", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69305, "title": "Tweak binding lifetime suggestion text", "body": "We already have a structured suggestion, but the wording made it seem like that wasn't the case.\r\n\r\nFix #65286. r? @varkor", "labels": ["S-waiting-on-bors"], "number_of_comments": 2, "created_at": "2020-02-20 02:04:28", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567896744": {"author_username": "Zoxc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69303, "title": "Add a query cache for dense local DefIds", "body": "Waiting on https://github.com/rust-lang/rust/pull/68988 to land for a perf run.\r\n\r\nr? @eddyb", "labels": ["S-waiting-on-review"], "number_of_comments": 5, "created_at": "2020-02-19 22:48:04", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567895948": {"author_username": "jonas-schievink", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69302, "title": "Fix generator miscompilations", "body": "Fixes https://github.com/rust-lang/rust/issues/69039\r\n\r\nr? @Zoxc", "labels": ["S-waiting-on-review"], "number_of_comments": 0, "created_at": "2020-02-19 22:46:08", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567875362": {"author_username": "That3Percent", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69301, "title": "macros which use $crate:: resolve to the wrong name when the crate is renamed", "body": "A macro using `$crate::` is supposed to be able to see its namespace regardless of whether that crate is a direct dependency of the caller. This is useful for hygienic purposes.\r\n\r\nIf a crate is renamed however:\r\n\r\n```toml\r\nfutures03 = { version = \"0.3.1\", package = \"futures\" }\r\n```\r\nThen the compiler fails to find the correct crate, instead using the name of the package.\r\nUsing the previous import and the following rust code produces an error:\r\n\r\n```rust\r\nasync fn test() {\r\n    futures03::try_join!()\r\n}\r\n```\r\n\r\nThe error produced by cargo check is:\r\n```\r\nfailed to resolve: could not find `futures` in `{{root}}`\r\n```\r\n\r\nThe error shown by rust-analyzer is:\r\n```\r\nfailed to resolve: could not find `core_reexport` in `futures`\r\n```\r\n\r\nOne might try to work around the bug by not renaming the crate. But, doing so presents a problem when importing multiple versions of the same crate under different names (as one may want to do when migrating from futures01 to futures03) since it is not possible to use macros from both crates.\r\n\r\nIn this case `$crate::` should not expand to `::futures::` but expand to `::futures03::` which would fix the bug.", "labels": ["A-macros", "A-resolve", "C-bug", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-19 22:02:08", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567792657": {"author_username": "That3Percent", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69298, "title": "Move keyword page makes no mention of async blocks", "body": "The [move keyword](https://doc.rust-lang.org/std/keyword.move.html) page currently talks only about the use of move with closures. The `move` keyword is also valid before an async block. For example: `async move { /*...*/ }`. This page could be updated to include that usage.", "labels": ["A-async-await", "C-enhancement", "T-doc"], "number_of_comments": 0, "created_at": "2020-02-19 19:28:57", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567779377": {"author_username": "RalfJung", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69297, "title": "Miri exception improvements", "body": "The Miri engine uses \"exceptions\" (`InterpResult`) to report misbehaving executions and propagate this information outwards to the machine (const-eval/const-prop/miri-the-tool). When an error is raised, we optionally capture a backtrace to ease debugging.\r\n\r\nThere are two problems with this:\r\n* [ ] Currently, checking whether we want to capture a backtrace is rather expensive (we check an env var). @wesleywiser proposed a scheme to use a session variable instead.\r\n* [ ] Sometimes, the engine *catches* these \"exceptions\". This means we caught the backtrace in vein. https://github.com/rust-lang/rust/pull/69290 brought some nice speed-up by removing just one case of catching an interpreter error! I think we should never catch these errors. Is there something we can do to prevent accidental catching?\r\n\r\nCc @oli-obk ", "labels": ["A-const-eval", "C-cleanup", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-19 19:05:39", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567776195": {"author_username": "nicbn", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69296, "title": "Compiler bug: type parameter `T/#0` (T/0) out of range when substituting", "body": "### Code\r\n\r\n```\r\nunsafe fn f<T: ?Sized>(ptr: *mut T, new: *mut u8) -> *mut T {\r\n    use std::mem;\r\n\r\n    let mut parts: [*mut u8; mem::size_of::<*mut T>() / mem::size_of::<*mut u8>()] =\r\n        mem::transmute(ptr);\r\n    parts[0] = new;\r\n    mem::transmute(parts)\r\n}\r\n```\r\n\r\n\r\n### Meta\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.42.0-nightly (13db6501c 2020-02-01)\r\nbinary: rustc\r\ncommit-hash: 13db6501c7273cd1997ce20e15106f362e5613c4\r\ncommit-date: 2020-02-01\r\nhost: x86_64-pc-windows-msvc\r\nrelease: 1.42.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\n### Error output\r\n\r\n```\r\nerror: internal compiler error: src\\librustc\\ty\\subst.rs:565: type parameter `T/#0` (T/0) out of range when substituting (root type=Some(fn() -> usize {std::mem::size_of::<*mut T>})) substs=[]\r\n\r\nthread 'rustc' panicked at 'Box<Any>', <::std::macros::panic macros>:2:4\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (13db6501c 2020-02-01) running on x86_64-pc-windows-msvc\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\n<details><summary><strong>Backtrace</strong></summary>\r\n<p>\r\n\r\n```\r\nerror: internal compiler error: src\\librustc\\ty\\subst.rs:565: type parameter `T/#0` (T/0) out of range when substituting (root type=Some(fn() -> usize {std::mem::size_of::<*mut T>})) substs=[]\r\n\r\nthread 'rustc' panicked at 'Box<Any>', <::std::macros::panic macros>:2:4\r\nstack backtrace:\r\n   0: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n   1: core::fmt::write\r\n   2: <std::io::IoSliceMut as core::fmt::Debug>::fmt\r\n   3: std::panicking::take_hook\r\n   4: std::panicking::take_hook\r\n   5: rustc_driver::report_ice\r\n   6: std::panicking::rust_panic_with_hook\r\n   7: rustc::ty::structural_impls::<impl rustc::ty::context::Lift for rustc_span::span_encoding::Span>::lift_to_tcx\r\n   8: rustc::ich::impls_hir::<impl rustc_data_structures::stable_hasher::HashStable<rustc::ich::hcx::StableHashingContext> for rustc_attr::builtin::InlineAttr>::hash_stable\r\n   9: rustc::ich::impls_hir::<impl rustc_data_structures::stable_hasher::HashStable<rustc::ich::hcx::StableHashingContext> for rustc_attr::builtin::InlineAttr>::hash_stable\r\n  10: rustc::util::bug::bug_fmt\r\n  11: <rustc::ty::trait_def::TraitImpls as rustc_data_structures::stable_hasher::HashStable<rustc::ich::hcx::StableHashingContext>>::hash_stable\r\n  12: <rustc::ty::trait_def::TraitImpls as rustc_data_structures::stable_hasher::HashStable<rustc::ich::hcx::StableHashingContext>>::hash_stable\r\n  13: rustc::util::bug::bug_fmt\r\n  14: rustc::util::bug::bug_fmt\r\n  15: <rustc::ty::subst::SubstFolder as rustc::ty::fold::TypeFolder>::fold_ty\r\n  16: rustc::ty::structural_impls::<impl rustc::ty::context::Lift for rustc::ty::ParamEnv>::lift_to_tcx\r\n  17: <rustc::ty::subst::SubstFolder as rustc::ty::fold::TypeFolder>::fold_ty\r\n  18: rustc::ty::error::<impl rustc::ty::TyS>::prefix_string\r\n  19: rustc::ty::structural_impls::<impl rustc::ty::context::Lift for rustc::ty::ParamEnv>::lift_to_tcx\r\n  20: <rustc::ty::subst::SubstFolder as rustc::ty::fold::TypeFolder>::fold_ty\r\n  21: <rustc::ty::subst::SubstFolder as rustc::ty::fold::TypeFolder>::fold_const\r\n  22: <rustc::mir::ProjectionElem<rustc::mir::Local,&rustc::ty::TyS> as rustc_mir::dataflow::move_paths::abs_domain::Lift>::lift\r\n  23: <rustc::mir::ProjectionElem<rustc::mir::Local,&rustc::ty::TyS> as rustc_mir::dataflow::move_paths::abs_domain::Lift>::lift\r\n  24: rustc_mir::const_eval::eval_queries::const_eval_raw_provider\r\n  25: <rustc_mir::interpret::validity::PathElem as core::fmt::Debug>::fmt\r\n  26: <rustc_mir::util::collect_writes::FindLocalAssignmentVisitor as rustc::mir::visit::Visitor>::visit_local\r\n  27: rustc_mir::const_eval::eval_queries::const_eval_validated_provider\r\n  28: <rustc_mir::interpret::validity::PathElem as core::fmt::Debug>::fmt\r\n  29: <rustc_mir::util::collect_writes::FindLocalAssignmentVisitor as rustc::mir::visit::Visitor>::visit_local\r\n  30: rustc_mir::const_eval::eval_queries::const_eval_validated_provider\r\n  31: rustc::ty::print::pretty::<impl core::fmt::Display for rustc::ty::sty::ProjectionTy>::fmt\r\n  32: rustc::middle::weak_lang_items::<impl rustc::ty::context::TyCtxt>::is_weak_lang_item\r\n  33: rustc::dep_graph::graph::DepGraph::assert_ignored\r\n  34: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::try_print_query_stack\r\n  35: rustc::mir::interpret::queries::<impl rustc::ty::context::TyCtxt>::const_eval_resolve\r\n  36: <rustc::traits::project::AssocTypeNormalizer as rustc::ty::fold::TypeFolder>::fold_const\r\n  37: rustc::ty::structural_impls::<impl rustc::ty::context::Lift for rustc::ty::ParamEnv>::lift_to_tcx\r\n  38: <rustc::traits::project::AssocTypeNormalizer as rustc::ty::fold::TypeFolder>::fold_ty\r\n  39: <rustc_traits::lowering::ClauseDumper as rustc_hir::intravisit::Visitor>::visit_struct_field\r\n  40: <chalk_engine::ExClause<rustc_traits::chalk_context::ChalkArenas> as rustc_traits::chalk_context::Upcast>::upcast\r\n  41: <rustc_typeck::check::FnCtxt as rustc_typeck::astconv::AstConv>::normalize_ty\r\n  42: <rustc_typeck::variance::terms::InferredIndex as core::fmt::Debug>::fmt\r\n  43: <rustc_typeck::check::GatherLocalsVisitor as rustc_hir::intravisit::Visitor>::visit_local\r\n  44: <rustc_typeck::namespace::Namespace as core::fmt::Debug>::fmt\r\n  45: <rustc_typeck::check::GatherLocalsVisitor as rustc_hir::intravisit::Visitor>::visit_pat\r\n  46: <rustc_typeck::outlives::explicit::ExplicitPredicatesMap as core::fmt::Debug>::fmt\r\n  47: <rustc_typeck::check::fixup_opaque_types::FixupFolder as rustc::ty::fold::TypeFolder>::fold_ty\r\n  48: <rustc_typeck::check::check_opaque_for_inheriting_lifetimes::ProhibitOpaqueVisitor as core::fmt::Debug>::fmt\r\n  49: <rustc_typeck::outlives::explicit::ExplicitPredicatesMap as core::fmt::Debug>::fmt\r\n  50: <rustc_typeck::namespace::Namespace as core::fmt::Debug>::fmt\r\n  51: <rustc_typeck::outlives::explicit::ExplicitPredicatesMap as core::fmt::Debug>::fmt\r\n  52: <rustc_typeck::outlives::explicit::ExplicitPredicatesMap as core::fmt::Debug>::fmt\r\n  53: <rustc_typeck::check::CheckItemTypesVisitor as rustc_hir::itemlikevisit::ItemLikeVisitor>::visit_item\r\n  54: <rustc_typeck::check::check_opaque_for_inheriting_lifetimes::ProhibitOpaqueVisitor as core::fmt::Debug>::fmt\r\n  55: <rustc_typeck::namespace::Namespace as core::fmt::Debug>::fmt\r\n  56: <rustc_typeck::outlives::explicit::ExplicitPredicatesMap as core::fmt::Debug>::fmt\r\n  57: rustc_typeck::check_crate\r\n  58: rustc_interface::passes::QueryContext::print_stats\r\n  59: <rustc_span::symbol::SymbolStr as core::fmt::Display>::fmt\r\n  60: rustc_driver::pretty::print_after_hir_lowering\r\n  61: <rustc_driver::DEFAULT_HOOK as core::ops::deref::Deref>::deref\r\n  62: rustc_driver::pretty::print_after_hir_lowering\r\n  63: rustc_driver::pretty::print_after_hir_lowering\r\n  64: <env_logger::filter::inner::Filter as core::fmt::Display>::fmt\r\n  65: <env_logger::filter::inner::Filter as core::fmt::Display>::fmt\r\n  66: <env_logger::filter::inner::Filter as core::fmt::Display>::fmt\r\n  67: _rust_maybe_catch_panic\r\n  68: rustc_driver::pretty::print_after_hir_lowering\r\n  69: ZN244_$LT$std..error..$LT$impl$u20$core..convert..From$LT$alloc..string..String$GT$$u20$for$u20$alloc..boxed..Box$LT$dyn$u20$std..error..Error$u2b$core..marker..Send$u2b$core..marker..Sync$GT$$GT$..from..StringError$u20$as$u20$core..fmt..Display$GT$3fmt17\r\n  70: std::sys::windows::thread::Thread::new\r\n  71: BaseThreadInitThunk\r\n  72: RtlUserThreadStart\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (13db6501c 2020-02-01) running on x86_64-pc-windows-msvc\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [const_eval_raw] const-evaluating `f::{{constant}}#0`\r\n#1 [const_eval_validated] const-evaluating + checking `f::{{constant}}#0`\r\n#2 [const_eval_validated] const-evaluating + checking `f::{{constant}}#0`\r\n#3 [typeck_tables_of] processing `f`\r\n#4 [typeck_item_bodies] type-checking all item bodies\r\n#5 [analysis] running analysis passes on this crate\r\nend of query stack\r\nerror: aborting due to previous error\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n", "labels": ["C-bug", "I-ICE", "P-high", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-19 19:00:08", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567739581": {"author_username": "ecstatic-morse", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69295, "title": "Use new dataflow framework for generators", "body": "#65672 introduced a new dataflow framework that can handle arbitrarily complex transfer functions as well as ones be expressed as a series of gen/kill operations. This PR ports the analyses used during generator passed to the new framework so that we can remove the old one. See #68241 for a prior example of this. The new framework has some superficial API changes, but this shouldn't alter the generator passes in any way.\r\n\r\nr? @tmandry", "labels": ["S-waiting-on-review"], "number_of_comments": 0, "created_at": "2020-02-19 18:03:58", "reactions": {"total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "heart": 3, "hooray": 0}}, "567736881": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69294, "title": "[WIP] traits/select: use global vs per-infcx caches more uniformly.", "body": "~~*Note: this is based on an older `master` to avoid perf interference before https://github.com/rust-lang/rust/pull/67953#issuecomment-587031702 is resolved.*~~ **EDIT**: sadly not workable due https://github.com/rust-lang/rust/pull/69294#issuecomment-588360527.\r\n\r\nSo far this PR only has the first couple steps towards making the decision of which cache (\"global\" vs \"per-`InferCtxt`\") to use for trait evaluation/selection, only once (at the time of checking the cache).\r\n\r\nThe goal here is to actually make per-`InferCtxt` caches not track `DepNode`s, and maybe even enforce that once `SelectionContext::in_task` is entered, the `InferCtxt` is effectively unused.\r\n\r\nMy assumption is that if you *need* inference variables in your cache key (i.e. `ParamEnv` and/or `PolyTraitPredicate`) to ever end up doing anything \"non-global\", and you can't get there from a \"global cache key\" (which would still use `DepNode`s and `in_task` etc.).\r\n\r\nPerhaps another path forward is to redirect \"global cache keys\" to a query, but I'm not sure how that would handle cycles (badly?), and it feels like stepping on Chalk's toes.\r\n\r\nr? @nikomatsakis cc @rust-lang/wg-traits @Zoxc @michaelwoerister", "labels": ["S-waiting-on-review"], "number_of_comments": 14, "created_at": "2020-02-19 17:59:36", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567617500": {"author_username": "pnkfelix", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69291, "title": "tidy should not traverse untracked directories", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI ran (effectively):\r\n\r\n```\r\n% git pull origin master\r\n...\r\n% git status\r\nOn branch moz-master\r\nYour branch is ahead of 'pnk-gh/moz-master' by 5558 commits.\r\n  (use \"git push\" to publish your local commits)\r\n\r\nUntracked files:\r\n  (use \"git add <file>...\" to include in what will be committed)\r\n\r\n\t../src/ignore_me/\r\n\r\nnothing added to commit but untracked files present (use \"git add\" to track)\r\n% cat ../src/ignore_me/should_be_ignored.rs\r\nuse tidy;\r\nuse not_so_smart;\r\n\r\n// THIS IS AN ABSURDLY LONG LINE OVER HERE THIS IS AN ABSURDLY LONG LINE OVER HERE THIS IS AN ABSURDLY LONG LINE OVER HERE\r\n% ../x.py test src/tools/tidy\r\nUpdating only changed submodules\r\nSubmodules updated in 0.08 seconds\r\n    Finished dev [unoptimized] target(s) in 0.16s\r\nDiff in /Users/felixklock/Dev/Mozilla/rust.git/src/ignore_me/should_be_ignored.rs at line 1:\r\n-use tidy;\r\n use not_so_smart;\r\n+use tidy;\r\n \r\n // THIS IS AN ABSURDLY LONG LINE OVER HERE THIS IS AN ABSURDLY LONG LINE OVER HERE THIS IS AN ABSURDLY LONG LINE OVER HERE\r\n \r\nRunning `\"/Users/felixklock/Dev/Mozilla/rust.git/objdir-dbgopt/build/x86_64-apple-darwin/stage0/bin/rustfmt\" \"--config-path\" \"/Users/felixklock/Dev/Mozilla/rust.git\" \"--edition\" \"2018\" \"--unstable-features\" \"--skip-children\" \"--check\" \"/Users/felixklock/Dev/Mozilla/rust.git/src/ignore_me/should_be_ignored.rs\"` failed.\r\nIf you're running `tidy`, try again with `--bless` flag. Or, you just want to format code, run `./x.py fmt` instead.\r\nfailed to run: /Users/felixklock/Dev/Mozilla/rust.git/objdir-dbgopt/build/bootstrap/debug/bootstrap test src/tools/tidy\r\nBuild completed unsuccessfully in 0:00:03\r\n% \r\n```\r\n\r\nThere are often extraneous files and directories in my source tree. And often they are not even files/directories that I had created (see (*) below).\r\n\r\nThe problem is that tidy does a blanket traversal of the tree under `src/`, as far as I can tell, and thus will happily flag \"problems\" in files that are no longer effectively part of the source code. \r\n\r\n(My most recent instance of this was tidy flagging a problem in a `.rs` file under `src/stdsimd/`.)\r\n\r\nEventually, after several rounds of trying to understand why non-tidy code got checked into the github repo, I'll eventually remember to look at `git status` and take note of the directories listed under untracked files.  And then, usually, delete them.\r\n\r\nBut this should not be necessary. `tidy` should be smart enough to run `git status` itself and use that to drive its traversal.\r\n\r\n----\r\n\r\n(*) part of the above process is the build system will automatically update submodules. But old directories from old (outdated) submodule checkouts still stick around.\r\n", "labels": ["A-rustbuild", "C-bug", "T-compiler"], "number_of_comments": 5, "created_at": "2020-02-19 14:42:00", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567568528": {"author_username": "wesleywiser", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69290, "title": "Check `RUSTC_CTFE_BACKTRACE` much less by generating fewer errors", "body": "Before this change, `get_size_and_align()`  calls `get_fn_alloc()` *a\r\nlot* in CTFE heavy code. This previously returned an `Error` which would\r\ncheck if `RUSTC_CTFE_BACKTRACE` was set on construction. Doing this\r\nturned out to be a performance hotspot as @nnethercote discovered in\r\n#68792.\r\n\r\nThis is an alternate take on that PR which resolves the performance\r\nissue by generating *many* fewer errors. Previously, `ctfe-stress-4`\r\nwould generate over 5,000,000 errors each of which would check for the\r\npresence of the environment variable. With these changes, that number is\r\nreduced to 30.\r\n\r\nr? @RalfJung ", "labels": ["S-waiting-on-bors"], "number_of_comments": 18, "created_at": "2020-02-19 13:26:28", "reactions": {"total_count": 4, "+1": 0, "-1": 0, "laugh": 0, "heart": 4, "hooray": 0}}, "567496402": {"author_username": "rust-highfive", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69286, "title": "`rls` no longer builds after rust-lang/rust#69265", "body": "Hello, this is your friendly neighborhood mergebot.\nAfter merging PR rust-lang/rust#69265, I observed that the tool rls no longer builds.\nA follow-up PR to the repository https://github.com/rust-lang/rls is needed to fix the fallout.\n\ncc @ehuss, do you think you would have time to do the follow-up work?\nIf so, that would be great!\n\ncc @Dylan-DPC, the PR reviewer, and nominating for compiler team prioritization.\n\n", "labels": ["P-medium", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-19 11:15:27", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567396168": {"author_username": "naim94a", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69283, "title": "[Docs] box doesn't contain documentation regarding ZSTs", "body": "I've recently learned that `Box::new` on a ZST returns the ZSTs alignment. I assumed that the return value didn't really matter since it's a ZST.\r\nThis should be added to Box's documentation (`Box::from_raw` should also be aligned then, right?)", "labels": ["C-enhancement", "T-doc", "T-libs"], "number_of_comments": 2, "created_at": "2020-02-19 08:24:51", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567369315": {"author_username": "ecstatic-morse", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69282, "title": "Replace `#[rustc_args_required_const(n)]` with per-argument attr", "body": "[RFC 2565](https://github.com/rust-lang/rfcs/pull/2565), which was recently stabilized, allows individual function parameters to have attributes. One of the [motivating examples](https://github.com/rust-lang/rfcs/blob/master/text/2565-formal-function-parameter-attributes.md#compiler-internals-improving-rustc_args_required_const) for that RFC was the ugliness of `#[rustc_args_required_const]`, which specifies the const argument(s) by index. We should transition away from `#[rustc_args_required_const]` to a per-argument attribute.\r\n\r\n@petrochenkov has proposed [`#[rustc_required_const]`](https://github.com/rust-lang/rust/pull/69280#issuecomment-588049122). These attributes are perma-unstable so there are no backwards compatibility concerns.", "labels": ["A-attributes", "C-cleanup", "C-enhancement", "E-medium", "F-param_attrs"], "number_of_comments": 0, "created_at": "2020-02-19 07:28:10", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 2}}, "567361823": {"author_username": "nnethercote", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69281, "title": "Inline some encoding and decoding methods.", "body": "This is a small performance win.\r\n\r\nr? @Centril", "labels": ["S-waiting-on-review"], "number_of_comments": 9, "created_at": "2020-02-19 07:10:31", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567256672": {"author_username": "konimex", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69277, "title": "libunwind: also build with C++ compiler on musl", "body": "Clang 9 (the C compiler) errors out and refuses to build anything if -stdlib=c++11 is set. This ensures that libunwind will be built with the C++ compiler just like on glibc.\r\n\r\nCloses #69222.", "labels": ["S-waiting-on-author"], "number_of_comments": 6, "created_at": "2020-02-19 01:22:23", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567239831": {"author_username": "tmandry", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69276, "title": "Improve error message for \"return type cannot contain a projection or `Self`...\"", "body": "Example ([playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6263bc1478126f230d8ef2dae9a5deb0)):\r\n\r\n```\r\nerror: `async fn` return type cannot contain a projection or `Self` that references lifetimes from a parent scope\r\n --> src/lib.rs:4:33\r\n  |\r\n4 |     async fn new(i: &'a i32) -> Self {\r\n  |                                 ^^^^\r\n```\r\n\r\n- Add a hint: try spelling out the type instead\r\n- Add an error code with an entry in the error index explaining that this is a limitation of the compiler, tracked by #61949", "labels": ["A-async-await", "A-diagnostics", "AsyncAwait-OnDeck", "AsyncAwait-Triaged", "C-enhancement", "D-papercut", "D-terse", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-19 00:24:08", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567224412": {"author_username": "grantslatton", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69275, "title": "Incorrect \"previous iteration of loop\" error message", "body": "The compiler gives a \"value moved in previous iteration of loop\" error message where there is no loop present.\r\n\r\nCode: [playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b90242be8f2df1b021024dba858d0817):\r\n\r\n```rust\r\nfn main() {\r\n    macro_rules! foo {\r\n        ($x:expr) => {\r\n            let _y = $x;\r\n            let _z = $x;\r\n        }\r\n    }\r\n    \r\n    let non_copy_value = vec![0u8];\r\n    foo!(non_copy_value);\r\n}\r\n```\r\n\r\nI expected to see an error message that does not talk about loops.\r\n\r\nInstead, the compiler gives this error message: \r\n\r\n```\r\nerror[E0382]: use of moved value: `non_copy_value`\r\n  --> src/main.rs:11:10\r\n   |\r\n10 |     let non_copy_value = vec![0u8];\r\n   |         -------------- move occurs because `non_copy_value` has type `std::vec::Vec<u8>`, which does not implement the `Copy` trait\r\n11 |     foo!(non_copy_value);\r\n   |          ^^^^^^^^^^^^^^ value moved here, in previous iteration of loop\r\n\r\n```\r\n\r\n### Meta\r\nBug exists on stable 1.41.0 and still on nightly 1.43.0\r\n", "labels": ["A-borrow-checker", "A-diagnostics", "C-bug", "D-incorrect", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-18 23:35:56", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567179832": {"author_username": "LeSeulArtichaut", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69274, "title": "Implement RFC 2396: `#[target_feature]` 1.1", "body": "Tracking issue: #69098\r\n\r\nr? @nikomatsakis\r\ncc @gnzlbg @joshtriplett", "labels": ["S-waiting-on-review"], "number_of_comments": 2, "created_at": "2020-02-18 21:50:08", "reactions": {"total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 3}}, "567152561": {"author_username": "Centril", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69270, "title": "[lint: unsafe_in_unsafe_fn] A lint which triggers on unsafe operations in `unsafe fn`", "body": "As a follow up to fixing https://github.com/rust-lang/rust/issues/69173 via https://github.com/rust-lang/rust/pull/69245, we would like to see a lint, starting as `allow`-by-default which would trigger on the following situation:\r\n\r\n```rust\r\n#![warn(unsafe_in_unsafe_fn)]\r\n\r\nunsafe fn foo() {} // Stand-in for any unsafe operation.\r\nunsafe fn bar() {\r\n    foo();\r\n    //~^ WARN unsafe operation directly in `unsafe fn`\r\n    //~| HELP move the operation into an `unsafe { ... }` block.\r\n}\r\n```\r\n\r\nEventually, over time, we would like to consider moving this lint to be `warn`-by-default, but we would like to give the ecosystem time to adapt before doing so. We have not discussed what the timescale of \"eventually\" entails.\r\n\r\nContext (this has already been tentatively accepted by the language team in meetings, though not FCP):\r\n- https://github.com/rust-lang/rfcs/pull/2585#issuecomment-586325462\r\n- https://github.com/rust-lang/rfcs/pull/2585#issuecomment-586513265\r\n\r\ncc @rust-lang/lang @RalfJung \n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\nThis issue has been assigned to @LeSeulArtichaut via [this comment](https://github.com/rust-lang/rust/issues/69270#issuecomment-588254029).\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"LeSeulArtichaut\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "labels": ["A-lint", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-18 20:55:59", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567117644": {"author_username": "cynecx", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69268, "title": "Yield reference in generator with GAT", "body": "Since https://github.com/rust-lang/rust/pull/67160 has been merge in December, having a GAT with lifetime should be possible (See the `StreamingIterator` example in that PR).\r\n\r\nThe current trait-defition of a generator is the following:\r\n\r\n```rust\r\npub trait Generator<R = ()> {\r\n    type Yield;\r\n    type Return;\r\n    fn resume(\r\n        self: Pin<&mut Self>, \r\n        arg: R\r\n    ) -> GeneratorState<Self::Yield, Self::Return>;\r\n}\r\n```\r\n\r\nThe issue here is that the `Yield` can't be parameterized with a lifetime, so yielding a reference from a generator is quite not possible in the current state.\r\n\r\nBy using a GAT for the `Yield` AT, it would be possible to return a generator local reference.\r\n\r\nAlso I don't see the point why the resume argument type couldn't also be expressed with a GAT, so we would use the following trait definition for a generator:\r\n\r\n```rust\r\npub trait Generator {\r\n    type Resume<'a>;\r\n    type Yield<'a>;\r\n    type Return;\r\n\r\n    fn resume<'a, 'b>(\r\n        self: Pin<&'a mut Self>, \r\n        arg: Self::Resume<'b>\r\n    ) -> GeneratorState<Self::Yield<'a>, Self::Return>;\r\n}\r\n```\r\n\r\nDoes this make sense and is it actually feasible to realize?\r\n\r\nEDIT:\r\n\r\nThis probably also requires an extension to the syntax of `impl Trait`. As for know you can't express this (Pseudosyntax):\r\n\r\n```rust\r\nfn generator() -> impl Generator<Resume = String, Yield = for<'a> &'a str, Return = ()> {\r\n    |x: String| { ... }\r\n}\r\nor\r\nfn generator() -> impl Generator<Resume = String, Yield<'a> = &'a str, Return = ()> {\r\n...\r\n```", "labels": ["A-associated-items", "A-generators", "C-feature-request", "F-generators", "F-generic_associated_types", "T-lang"], "number_of_comments": 0, "created_at": "2020-02-18 19:45:42", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "567008287": {"author_username": "nmattia", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69264, "title": "rustdoc: use remap-path-prefix", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nThe rust compiler has an option `--remap-path-prefix` for remapping path prefixes. It's useful to avoid runtime messages that are independent of where the source code was located during the build.\r\n\r\nAs far as I can tell that doesn't apply to `rustdoc`'s `<meta>` info \"Source to the Rust file ...\", which (to me) is unexpected.\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n```\r\n$ rustc --version --verbose\r\nrustc 1.40.0\r\nbinary: rustc\r\ncommit-hash: unknown\r\ncommit-date: unknown\r\nhost: x86_64-apple-darwin\r\nrelease: 1.40.0\r\nLLVM version: 8.0\r\n```", "labels": ["C-bug", "T-rustdoc"], "number_of_comments": 0, "created_at": "2020-02-18 16:25:23", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566974155": {"author_username": "anyska", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69263, "title": "Blacklist powerpc-unknown-linux-gnu as having non-ignored GNU C ZSTs.", "body": "Closes #64259 (this is a simpler alternative to that). See also https://github.com/rust-lang/rust/pull/64259#issuecomment-585815831.", "labels": ["S-waiting-on-review"], "number_of_comments": 3, "created_at": "2020-02-18 15:33:06", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566907719": {"author_username": "GuillaumeGomez", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69260, "title": "Create E0747 error code for unterminated raw strings", "body": "Reopening of #66035.\r\n\r\nr? @estebank ", "labels": ["S-waiting-on-review"], "number_of_comments": 1, "created_at": "2020-02-18 13:53:05", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566849698": {"author_username": "olegnn", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69259, "title": "Incorrect `this block is empty, you might have not meant to close it` on any channel", "body": "Any code which has correct `()` and incorrect braces like `f)` after them will produce incorrect `this block is empty, you might have not meant to close it` which will point at the valid parentheses. This behaviour is the same on all channels.\r\n```rust\r\nfn main() {}\r\n\r\nfn f) {}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=e1c8a9c2395232687c7da75078ce58ac))\r\n\r\nErrors:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nerror: unexpected closing delimiter: `)`\r\n --> src/main.rs:3:5\r\n  |\r\n1 | fn main() {}\r\n  |        -- this block is empty, you might have not meant to close it\r\n2 | \r\n3 | fn f) {}\r\n  |     ^ unexpected closing delimiter\r\n\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```", "labels": [], "number_of_comments": 1, "created_at": "2020-02-18 12:08:44", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566733250": {"author_username": "RalfJung", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69257, "title": "Adjust Miri value visitor, and doc-comment layout components", "body": "I realized that I still didn't have quite the right intuition for how our `LayoutDetails` work, so I had to adjust the Miri value visitor to the things I understood better now. I also added some doc-comments to `LayoutDetails` as a hopefully canonical place to note such things.\r\n\r\nThe main visitor change is that we *first* look at all the fields (according to `FieldPlacement`), and *then* check the variants and handle `Multiple` appropriately. I did not quite realize how orthogonal \"fields\" and \"variants\" are.\r\nI also moved the check for the scalar ABI to *after* checking all the fields; this leads to better (more type-driven) error messages.\r\n\r\nAnd it looks like we can finally remove that magic hack for `ty::Generator`. :D\r\n\r\nr? @oli-obk for the Miri/visitor changes and @eddyb for the layout docs\r\nThe Miri PR is at: https://github.com/rust-lang/miri/pull/1178", "labels": ["S-waiting-on-review"], "number_of_comments": 1, "created_at": "2020-02-18 08:43:43", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566699033": {"author_username": "estebank", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69255, "title": "Add more context to E0599 errors", "body": "Point at the intermediary unfulfilled trait bounds.\r\n\r\nFix #52523, fix #61661, cc #36513, fix #68131, fix #64417, fix #61768, cc #57457, cc #9082, fix #57994, cc #64934, cc #65149.", "labels": ["S-waiting-on-review"], "number_of_comments": 2, "created_at": "2020-02-18 07:28:49", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566578140": {"author_username": "anp", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69251, "title": "#[track_caller] in traits", "body": "Per https://github.com/rust-lang/rust/issues/47809#issuecomment-572791760, this allows the `#[track_caller]` attribute on trait methods. There's also a commit applying the attribute to the standard library [functions listed in \"tier 1\" in the original RFC](https://github.com/rust-lang/rfcs/blob/master/text/2091-inline-semantic.md#survey-of-panicking-standard-functions).", "labels": ["F-track_caller", "S-waiting-on-review"], "number_of_comments": 12, "created_at": "2020-02-18 00:37:22", "reactions": {"total_count": 4, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 4}}, "566572815": {"author_username": "MarkMcCaskey", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69250, "title": "Documentation unclear with Fn trait on extern \"C\" function pointers", "body": "The relevant docs are [here](https://doc.rust-lang.org/std/primitive.fn.html) and [here in the repo](https://github.com/rust-lang/rust/blob/master/src/libstd/primitive_docs.rs#L1133-L1135):\r\n\r\n> In addition, function pointers of any signature, ABI, or safety are Copy, and all safe function pointers implement Fn, FnMut, and FnOnce. This works because these traits are specially known to the compiler.\r\n\r\nThe code:\r\n\r\n```Rust\r\nextern \"C\" fn abc(x: u32) {\r\n    println!(\"Hello, {}\", x);\r\n}\r\n\r\nfn do_it<F: Fn(u32)>(f: F, n: u32) {\r\n    f(n)\r\n}\r\n\r\nfn main() {\r\n    do_it(abc, 5);\r\n}\r\n```\r\n\r\nDoes not compile even though `abc` can be called without `unsafe`, which the docs seem to suggest is sufficient for this to work.\r\n\r\n[Rust playground demonstrating the issue](https://play.rust-lang.org/?version=stable&mode=debug&edition=2015&gist=8735414c1ecb5b4e58d9997912419b21)\r\n\r\nI'd be happy to update the docs, but unfortunately I think I don't understand why this doesn't work well enough to do so.", "labels": ["A-ffi", "C-enhancement", "T-doc"], "number_of_comments": 0, "created_at": "2020-02-18 00:13:40", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566508421": {"author_username": "CAD97", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69247, "title": "Remove experimental chalk option", "body": "As suggested by @nikomatsakis [here](https://github.com/rust-lang/rust/pull/68807#issuecomment-583339932).\r\n\r\nThe current version of chalk used by the experimental `-Zchalk` flag is [v0.9.0, which is over a year old](https://crates.io/crates/chalk-engine). Since v0.9.0, chalk has seen [a lot of further development](https://github.com/rust-lang/chalk/compare/41dfe13...master), and the intent is to eventually upgrade rustc to use a more recent chalk.\r\n\r\nHowever, it will take a decent chunk of effort to upgrade the current experimental chalk support, and it is currently [blocking at least some PRs](https://github.com/rust-lang/rust/pull/68807) due to chalk:0.9.0's use of unstable features. So for the interim until the next chalk release and experimental rustc integration, we remove the chalk-specific code from rustc.", "labels": ["S-waiting-on-review"], "number_of_comments": 4, "created_at": "2020-02-17 20:42:07", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "heart": 2, "hooray": 0}}, "566482260": {"author_username": "LeSeulArtichaut", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69245, "title": "Remove \"unnecessary `unsafe` block in `unsafe` fn\" lint", "body": "Closes #69173.\r\n\r\nr? @eddyb\r\ncc @Centril", "labels": ["S-waiting-on-review", "T-lang", "disposition-merge", "proposed-final-comment-period"], "number_of_comments": 15, "created_at": "2020-02-17 19:30:21", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 2}}, "566470067": {"author_username": "mgattozzi", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69243, "title": "Improve ?Sized diagnostics", "body": "Context: https://twitter.com/mgattozzi/status/1229477994961494021\r\n\r\nA way to improve the diagnostics when suggesting to relax trait bounds with ?Sized is to show how one would use it on a struct/fn with their code rather than just suggesting it, making it easier for newer people, or those first encountering the issue to more clearly understand how this works.\r\n\r\ncc/ @estebank ", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 2, "created_at": "2020-02-17 18:56:59", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566468936": {"author_username": "cjgillot", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69242, "title": "Querify object_safety_violations.", "body": "Split from #69076\n\nr? @Zoxc", "labels": ["S-waiting-on-author"], "number_of_comments": 14, "created_at": "2020-02-17 18:53:44", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566423201": {"author_username": "d-e-s-o", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69240, "title": "RwLock: support upgrades and downgrades", "body": "I think it would be great (certainly useful for me) if `RwLock` were to support read-write upgrades and write-read downgrades. Currently I don't see a way to accomplish the same and I always have to get write access over the entire operation.\r\n\r\n`parking_lot` currently supports both cases ([here](https://docs.rs/lock_api/0.3.3/lock_api/struct.RwLockUpgradableReadGuard.html#method.upgrade) & [here](https://docs.rs/lock_api/0.3.3/lock_api/struct.RwLockUpgradableReadGuard.html#method.downgrade)). I also understand that there exists [a proposal](https://github.com/rust-lang/rust/pull/56410) to use `parking_lot` as the lock implementation backend.\r\n\r\nOnce (if) that lands, it should merely be a matter of extending the `std` APIs to provide such support.", "labels": ["C-feature-request", "T-libs"], "number_of_comments": 5, "created_at": "2020-02-17 17:00:25", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566407320": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69239, "title": "const generic ICE on *stable*", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI tried this code on *stable*:\r\n\r\n```rust\r\ntrait Trait<const S: &'static str> {}\r\n\r\nstruct Bug<T>\r\nwhere\r\n    T: Trait<{std::intrinsics::type_name::<T>()}>\r\n{\r\n    t: T\r\n}\r\n```\r\n\r\nI expected to see this happen: For one, report an error that Im using const generics without a feature flag. For two, report an error Im uising an intrinsic without a feature flag.\r\n\r\nInstead, this happened: The above code crashed the compiler.\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\n1.41.0\r\n```\r\nA quick check in godbolt gives that the ICE's started in 1.35 and onwards. This also includes the current nightly and beta.\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n Compiling playground v0.0.1 (/playground)\r\nerror[E0658]: const generics are unstable\r\n --> src/lib.rs:1:19\r\n  |\r\n1 | trait Trait<const S: &'static str> {}\r\n  |                   ^\r\n  |\r\n  = note: for more information, see https://github.com/rust-lang/rust/issues/44580\r\n\r\nerror[E0658]: use of unstable library feature 'core_intrinsics': intrinsics are unlikely to ever be stabilized, instead they should be used through stabilized interfaces in the rest of the standard library\r\n --> src/lib.rs:5:15\r\n  |\r\n5 |     T: Trait<{std::intrinsics::type_name::<T>()}>\r\n  |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nerror: internal compiler error: src/librustc/ty/subst.rs:610: type parameter `T/#0` (T/0) out of range when substituting (root type=Some(extern \"rust-intrinsic\" fn() -> &'static str {std::intrinsics::type_name::<T>})) substs=[]\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:864:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:84\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:61\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1025\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:65\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:50\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:193\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:210\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:475\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::span_bug\r\n  14: rustc_errors::Handler::span_bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::span_bug_fmt\r\n  20: <rustc::ty::subst::SubstFolder as rustc::ty::fold::TypeFolder>::fold_ty\r\n  21: rustc::ty::fold::TypeFoldable::fold_with\r\n  22: rustc::ty::structural_impls::<impl rustc::ty::fold::TypeFoldable for &rustc::ty::TyS>::super_fold_with\r\n  23: <rustc::ty::subst::SubstFolder as rustc::ty::fold::TypeFolder>::fold_ty\r\n  24: rustc::ty::structural_impls::<impl rustc::ty::fold::TypeFoldable for &rustc::ty::sty::Const>::super_fold_with\r\n  25: <rustc::ty::subst::SubstFolder as rustc::ty::fold::TypeFolder>::fold_const\r\n  26: rustc::traits::codegen::<impl rustc::ty::context::TyCtxt>::subst_and_normalize_erasing_regions\r\n  27: rustc_mir::interpret::operand::<impl rustc_mir::interpret::eval_context::InterpCx<M>>::eval_operand\r\n  28: rustc_mir::interpret::step::<impl rustc_mir::interpret::eval_context::InterpCx<M>>::step\r\n  29: rustc_mir::const_eval::const_eval_raw_provider\r\n  30: rustc::ty::query::__query_compute::const_eval_raw\r\n  31: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::const_eval_raw>::compute\r\n  32: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  33: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  34: rustc_mir::const_eval::const_eval_provider\r\n  35: rustc::ty::query::__query_compute::const_eval\r\n  36: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::const_eval>::compute\r\n  37: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  38: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  39: rustc_mir::const_eval::const_eval_provider\r\n  40: rustc::ty::query::__query_compute::const_eval\r\n  41: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::const_eval>::compute\r\n  42: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  43: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  44: rustc::ty::sty::Const::eval::{{closure}}\r\n  45: rustc::ty::sty::Const::eval\r\n  46: rustc::ty::fold::TypeFoldable::fold_with\r\n  47: rustc::ty::fold::TypeFoldable::fold_with\r\n  48: rustc::ty::fold::TypeFoldable::fold_with\r\n  49: rustc::traits::project::normalize\r\n  50: rustc::traits::fully_normalize\r\n  51: rustc::ty::context::tls::with_context::{{closure}}\r\n  52: rustc::ty::context::GlobalCtxt::enter_local\r\n  53: rustc::traits::do_normalize_predicates\r\n  54: rustc::traits::normalize_param_env_or_error\r\n  55: rustc::ty::param_env\r\n  56: rustc::ty::query::__query_compute::param_env\r\n  57: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::param_env>::compute\r\n  58: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  59: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  60: rustc_typeck::check::wfcheck::check_item_well_formed\r\n  61: rustc::ty::query::__query_compute::check_item_well_formed\r\n  62: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::check_item_well_formed>::compute\r\n  63: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  64: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  65: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::ensure_query\r\n  66: __rust_maybe_catch_panic\r\n             at src/libpanic_unwind/lib.rs:78\r\n  67: rustc_data_structures::sync::par_for_each_in\r\n  68: __rust_maybe_catch_panic\r\n             at src/libpanic_unwind/lib.rs:78\r\n  69: rustc::hir::Crate::par_visit_all_item_likes\r\n  70: rustc::util::common::time\r\n  71: rustc_typeck::check_crate\r\n  72: rustc_interface::passes::analysis\r\n  73: rustc::ty::query::__query_compute::analysis\r\n  74: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  75: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  76: rustc::ty::context::tls::enter_global\r\n  77: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  78: std::thread::local::LocalKey<T>::with\r\n  79: scoped_tls::ScopedKey<T>::set\r\n  80: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.41.0 (5e1a79984 2020-01-27) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C codegen-units=1 -C debuginfo=2 --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [const_eval_raw] const-evaluating `Bug::{{constant}}#0`\r\n#1 [const_eval] const-evaluating + checking `Bug::{{constant}}#0`\r\n#2 [const_eval] const-evaluating + checking `Bug::{{constant}}#0`\r\n#3 [param_env] processing `Bug`\r\n#4 [check_item_well_formed] processing `Bug`\r\n#5 [analysis] running analysis passes on this crate\r\nend of query stack\r\nerror: aborting due to 3 previous errors\r\n\r\nFor more information about this error, try `rustc --explain E0658`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n\r\n</p>\r\n</details>\r\n", "labels": ["A-const-generics", "C-bug", "F-const_generics", "I-ICE", "P-medium", "T-compiler"], "number_of_comments": 6, "created_at": "2020-02-17 16:29:14", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566290241": {"author_username": "glandium", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69232, "title": "Error message for E0617 is confusing when functions are involved", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI tried this code:\r\n\r\n```rust\r\nuse curl_sys::{curl_easy_setopt, CURLOPT_READFUNCTION};\r\nuse libc;\r\n\r\n// (...)\r\ncurl_easy_setopt(curl, CURLOPT_READFUNCTION, libc::fread);\r\n```\r\n\r\nI expected to see this happen: maybe not a failure, or a failure that is not completely confusing.\r\n\r\nInstead, this happened:\r\n```\r\nerror[E0617]: can't pass `unsafe extern \"C\" fn(*mut core::ffi::c_void, usize, usize, *mut libc::unix::FILE) -> usize {libc::unix::fread}` to variadic function\r\n   --> hg_connect.rs:844:62\r\n    |\r\n844 |                 curl_easy_setopt(curl, CURLOPT_READFUNCTION, libc::fread);\r\n    |                                                              ^^^^^^^^^^^\r\n    |\r\nhelp: cast the value to `unsafe extern \"C\" fn(*mut core::ffi::c_void, usize, usize, *mut libc::unix::FILE) -> usize`\r\n    |\r\n844 |                 curl_easy_setopt(curl, CURLOPT_READFUNCTION, libc::fread as unsafe extern \"C\" fn(*mut core::ffi::c_void, usize, usize, *mut libc::unix::FILE) -> usize);\r\n    |                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n```\r\n\r\nNote how it suggests to cast to the exact same type it started with.\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.43.0-nightly (5e7af4669 2020-02-16)\r\nbinary: rustc\r\ncommit-hash: 5e7af4669f80e5f682141f050193ab679afdb4b1\r\ncommit-date: 2020-02-16\r\nhost: aarch64-unknown-linux-gnu\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```", "labels": ["A-diagnostics", "A-ffi", "C-enhancement", "D-confusing", "T-compiler"], "number_of_comments": 7, "created_at": "2020-02-17 13:12:43", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566203588": {"author_username": "jonas-schievink", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69231, "title": "`noreturn` on diverging functions makes LLVM trash the link register on thumb targets", "body": "Downstream issue: https://github.com/rust-embedded/cortex-m-rt/issues/139\r\n\r\nIt looks like LLVM is extremely eager to overwrite the Link Register without saving it as soon as `noreturn` is put on a function. Since rustc does that for any `-> !` function, which includes many parts of the panic machinery, this effectively makes obtaining a backtrace on panic on embedded systems impossible.\r\n\r\nThis is somewhat analogous to omission of frame pointers on x86, so maybe `-Cforce-frame-pointers` can be repurposed to prevent this behavior on Thumb/ARM targets? I'm not sure there's even an LLVM feature to control this specifically, but I suppose rustc could always omit the `noreturn`.\r\n\r\nSince this is only important in debug builds (that may be optimized, however), it might make sense to couple this behavior to whether debug assertions are enabled, but I'm not sure about that. What do you think? Would a patch doing something or this sort be accepted?", "labels": ["A-LLVM", "C-bug", "O-ARM", "T-compiler", "WG-embedded"], "number_of_comments": 8, "created_at": "2020-02-17 10:30:50", "reactions": {"total_count": 3, "+1": 3, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566164011": {"author_username": "petrochenkov", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69229, "title": "parser: Implement recovery for potential unknown macro variables `$ IDENT`", "body": "https://github.com/rust-lang/rust/pull/69211 simplified parsing and fixed treatment of `$` tokens coming from proc macros, but slightly regressed diagnostics.\r\n\r\nIf a declarative macro body contains something that looks like an unknown macro variable `$ var`, then it's preserved and outputted like two-token sequence punctuation `$` and identifier `var`.\r\n\r\nWe previously tried to detect such sequences in `Parser::bump`, but the detection wasn't correct and wasn't done in the best way for recovery.\r\n\r\nInstead, we need to support parsing the `$ IDENT` sequences in context dependent fashion, as an error expression in expression position, as an error type in type position etc.\r\n\r\nCurrently supported positions for macro variables (roughly in the order of importance):\r\n- [ ] `expr`\r\n- [ ] `ty`\r\n- [ ] `pat`\r\n- [ ] `item`\r\n- [ ] `ident`\r\n- [ ] `lifetime`\r\n- [ ] `vis`\r\n- [ ] `path`\r\n- [ ] `block`\r\n- [ ] `literal`\r\n- [ ] `meta`\r\n- [ ] `stmt`\r\n\r\nIt's quite possible that implementing this recovery for `ident` can successfully make implementing it for `expr`, `ty`, `pat`, `path` and `meta` unnecessary.", "labels": ["A-diagnostics", "A-parser", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-17 09:24:13", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566099467": {"author_username": "Marwes", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69227, "title": "perf: Buffer stderr when writing json errors/warnings", "body": "Since `stderr` is unbuffered, writing out json messages actually take up\r\nabout ~10%/0.1s of the runtime of the `inflate` benchmark as it generates a fair number of warnings.\r\n\r\ncc #64413", "labels": ["S-waiting-on-review"], "number_of_comments": 2, "created_at": "2020-02-17 07:12:29", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566037034": {"author_username": "dfyz", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69225, "title": "Memory unsafety problem in safe Rust", "body": "I have a [small program](https://github.com/dfyz/rust-segfault) (a simplification of a test function from a larger project) that slices a small array and tries to access an out-of-bounds element of the slice. Running it with `cargo run --release` using the stable `1.41.0` release prints something like this (tested on macOS 10.15 and Ubuntu 19.10):\r\n```\r\n0 0 3 18446744073709551615\r\n[1]    21065 segmentation fault  cargo run --release\r\n```\r\nIt looks like the resulting slice somehow has length `2**64 - 1`, so the bounds checking is omitted, which predictably results in a segfault. On `1.39.0` and `1.40.0` the very same program prints what I would expect:\r\n```\r\n0 0 3 0\r\nthread 'main' panicked at 'index out of bounds: the len is 0 but the index is 16777216', src/main.rs:13:35\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\r\n```\r\n\r\nThe problem goes away if I do any of the following:\r\n  * remove either of the two `do_test(...);` calls in `main()`;\r\n  * remove the `for _ in 0..1 {` loop;\r\n  * replace the `for y in 0..x {` loop with `for y in 0..1 {`;\r\n  * remove the `z.extend(std::iter::repeat(0).take(x));` line or replace it with `z.extend(std::iter::repeat(0).take(1));`;\r\n  * replace the `for arr_ref in arr {` loop with `let arr_ref = &arr[0];`;\r\n  * specify `RUSTFLAGS=\"-C opt-level=2\"`;\r\n  * specify `RUSTFLAGS=\"-C codegen-units=1\"`.\r\n\r\nMy best guess is `-C opt-level=3` enables a problematic optimization pass in LLVM, which results in miscompilation. This is corroborated by the fact that MIR (`--emit mir`) and LLVM IR before optimizations (`--emit llvm-ir -C no-prepopulate-passes`) is the same for both `-C opt-level=2` and `-C opt-level=3`.\r\n\r\nSome additional info that might be helpful:\r\n  * I can't reproduce the problem in the Rust playground (presumably because it uses `codegen-units = 1`);\r\n  * I can't reproduce the problem on Windows 10 with the same `1.41.0` release (no idea what makes it different);\r\n  * `cargo-bisect-rustc` says the regression first happened in the `2019-12-12` nightly, specifically [in this commit](https://github.com/rust-lang/rust/commit/033662dfbca088937b9cdfd3d9584015b5e375b2). This seems suspicious to me, given that `1.40.0`, which does not exhibit the problem, was released after this date.\r\n\r\nI'm attaching the program inline in case the GitHub repo doesn't work (if you want to compile it without Cargo, use `rustc -C opt-level=3 main.rs`):\r\n```rust\r\nfn do_test(x: usize) {\r\n    let arr = vec![vec![0u8; 3]];\r\n\r\n    let mut z = Vec::new();\r\n    for arr_ref in arr {\r\n        for y in 0..x {\r\n            for _ in 0..1 {\r\n                z.extend(std::iter::repeat(0).take(x));\r\n                let a = y * x;\r\n                let b = (y + 1) * x - 1;\r\n                let slice = &arr_ref[a..b];\r\n                eprintln!(\"{} {} {} {}\", a, b, arr_ref.len(), slice.len());\r\n                eprintln!(\"{:?}\", slice[1 << 24]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn main() {\r\n    do_test(1);\r\n    do_test(2);\r\n}\r\n```", "labels": ["A-LLVM", "C-bug", "I-unsound \ud83d\udca5", "ICEBreaker-LLVM", "P-medium", "T-compiler", "regression-from-stable-to-stable"], "number_of_comments": 25, "created_at": "2020-02-17 03:40:22", "reactions": {"total_count": 30, "+1": 22, "-1": 0, "laugh": 0, "heart": 2, "hooray": 0}}, "566033725": {"author_username": "clarfon", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69224, "title": "Confusing errors when using `Self` variants with lifetimes", "body": "Minimal example, imagine that we have the following type:\r\n\r\n```rust\r\nenum MyCow<'a> {\r\n    Owned(String),\r\n    Borrowed(&'a str),\r\n}\r\n```\r\n\r\nIf the user returns `Self` variants, this fails:\r\n\r\n```rust\r\nimpl<'a> MyCow<'a> {\r\n    fn borrow(&self) -> MyCow<'_> {\r\n        match self {\r\n            Self::Owned(s) => Self::Borrowed(s),\r\n            Self::Borrowed(s) => Self::Borrowed(s),\r\n        }\r\n    }\r\n    fn own(&self) -> MyCow<'static> {\r\n        match self {\r\n            Self::Owned(s) => Self::Owned(s.clone()),\r\n            Self::Borrowed(s) => Self::Owned(s.to_string()),\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nBut the same code works when you change `Self` to `MyCow`!\r\n```rust\r\nimpl<'a> MyCow<'a> {\r\n    fn borrow(&self) -> MyCow<'_> {\r\n        match self {\r\n            Self::Owned(s) => MyCow::Borrowed(s),\r\n            Self::Borrowed(s) => MyCow::Borrowed(s),\r\n        }\r\n    }\r\n    fn own(&self) -> MyCow<'static> {\r\n        match self {\r\n            Self::Owned(s) => MyCow::Owned(s.clone()),\r\n            Self::Borrowed(s) => MyCow::Owned(s.to_string()),\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe real error here is that `Self` really represents `MyCow<'a>` and not `MyCow<'_>` or `MyCow<'static>`-, but the errors don't really relay this. Potentially linked issue: #30904 (has been fixed).", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-17 03:26:31", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "566017963": {"author_username": "konimex", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69222, "title": "Building rustc in Clang 9.0 error: invalid argument '-std=c++11' not allowed with 'C'", "body": "Hello, I'm trying to build a pure-LLVM Rust (no linking to `libgcc_s.so` at all). Building rust with `clang` set as `cc` in `target.x86_64-unknown-linux-musl` returns failure since Clang (the C compiler) doesn't allow `std=c++11`.\r\n\r\nHere's my `config.toml`:\r\n```toml\r\n[llvm]\r\nlink-shared = true\r\n\r\n[build]\r\nbuild = \"x86_64-unknown-linux-musl\"\r\nhost = [ \"x86_64-unknown-linux-musl\" ]\r\ntarget = [ \"x86_64-unknown-linux-musl\" ]\r\ndocs = false\r\nextended = true\r\nsubmodules = false\r\npython = \"python3\"\r\nlocked-deps = true\r\nvendor = true\r\n\r\n[install]\r\nprefix = \"/usr\"\r\n\r\n[rust]\r\nchannel = \"stable\"\r\nrpath = false\r\ncodegen-units = 1\r\ndebuginfo-level = 0\r\nbacktrace = false\r\njemalloc = false\r\ncodegen-tests = false\r\nllvm-libunwind = true\r\n\r\n[target.x86_64-unknown-linux-musl]\r\ncc = \"clang\"\r\ncxx = \"clang++\"\r\nlinker = \"clang\"\r\nllvm-config = \"/usr/bin/llvm-config\"\r\ncrt-static = false\r\n```\r\n\r\nHere are the relevant bits of the log:\r\n```\r\nBuilding stage0 std artifacts (x86_64-unknown-linux-musl -> x86_64-unknown-linux-musl)\r\n   Compiling cc v1.0.47\r\n   Compiling core v0.0.0 (/home/koni/.cache/kiss/build-20469/rust/src/libcore)\r\n   Compiling libc v0.2.64\r\n   Compiling autocfg v0.1.6\r\n   Compiling std v0.0.0 (/home/koni/.cache/kiss/build-20469/rust/src/libstd)\r\n   Compiling hashbrown v0.6.2\r\n   Compiling compiler_builtins v0.1.22\r\n   Compiling unwind v0.0.0 (/home/koni/.cache/kiss/build-20469/rust/src/libunwind)\r\n   Compiling backtrace-sys v0.1.32\r\n   Compiling rustc-std-workspace-core v1.99.0 (/home/koni/.cache/kiss/build-20469/rust/src/tools/rustc-std-workspace-core)\r\nerror: failed to run custom build command for `unwind v0.0.0 (/home/koni/.cache/kiss/build-20469/rust/src/libunwind)`\r\n\r\nCaused by:\r\n  process didn't exit successfully: `/home/koni/.cache/kiss/build-20469/rust/build/x86_64-unknown-linux-musl/stage0-std/release/build/unwind-078e32742eabfcea/build-script-build` (exit code: 1)\r\n--- stdout\r\ncargo:rerun-if-changed=build.rs\r\ncargo:rustc-link-search=native=/home/koni/.cache/kiss/build-20469/rust/build/x86_64-unknown-linux-musl/stage0-std/x86_64-unknown-linux-musl/release/build/unwind-ab6a3e65ec86ddbe/out\r\nrunning: \"clang\" \"-O2\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=x86_64-unknown-linux-musl\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=x86_64-unknown-linux-musl\" \"-I\" \"../llvm-project/libunwind/include\" \"-std=c99\" \"-std=c++11\" \"-nostdinc++\" \"-fno-exceptions\" \"-fno-rtti\" \"-fstrict-aliasing\" \"-funwind-tables\" \"-D__LITTLE_ENDIAN__=1\" \"-o\" \"/home/koni/.cache/kiss/build-20469/rust/build/x86_64-unknown-linux-musl/stage0-std/x86_64-unknown-linux-musl/release/build/unwind-ab6a3e65ec86ddbe/out/../llvm-project/libunwind/src/Unwind-EHABI.o\" \"-c\" \"../llvm-project/libunwind/src/Unwind-EHABI.cpp\"\r\nexit code: 0\r\nrunning: \"clang\" \"-O2\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=x86_64-unknown-linux-musl\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=x86_64-unknown-linux-musl\" \"-I\" \"../llvm-project/libunwind/include\" \"-std=c99\" \"-std=c++11\" \"-nostdinc++\" \"-fno-exceptions\" \"-fno-rtti\" \"-fstrict-aliasing\" \"-funwind-tables\" \"-D__LITTLE_ENDIAN__=1\" \"-o\" \"/home/koni/.cache/kiss/build-20469/rust/build/x86_64-unknown-linux-musl/stage0-std/x86_64-unknown-linux-musl/release/build/unwind-ab6a3e65ec86ddbe/out/../llvm-project/libunwind/src/Unwind-seh.o\" \"-c\" \"../llvm-project/libunwind/src/Unwind-seh.cpp\"\r\nexit code: 0\r\nrunning: \"clang\" \"-O2\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=x86_64-unknown-linux-musl\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=x86_64-unknown-linux-musl\" \"-I\" \"../llvm-project/libunwind/include\" \"-std=c99\" \"-std=c++11\" \"-nostdinc++\" \"-fno-exceptions\" \"-fno-rtti\" \"-fstrict-aliasing\" \"-funwind-tables\" \"-D__LITTLE_ENDIAN__=1\" \"-o\" \"/home/koni/.cache/kiss/build-20469/rust/build/x86_64-unknown-linux-musl/stage0-std/x86_64-unknown-linux-musl/release/build/unwind-ab6a3e65ec86ddbe/out/../llvm-project/libunwind/src/Unwind-sjlj.o\" \"-c\" \"../llvm-project/libunwind/src/Unwind-sjlj.c\"\r\ncargo:warning=error: invalid argument '-std=c++11' not allowed with 'C'\r\nexit code: 1\r\n\r\n--- stderr\r\n\r\n\r\nerror occurred: Command \"clang\" \"-O2\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=x86_64-unknown-linux-musl\" \"-ffunction-sections\" \"-fdata-sections\" \"-fPIC\" \"--target=x86_64-unknown-linux-musl\" \"-I\" \"../llvm-project/libunwind/include\" \"-std=c99\" \"-std=c++11\" \"-nostdinc++\" \"-fno-exceptions\" \"-fno-rtti\" \"-fstrict-aliasing\" \"-funwind-tables\" \"-D__LITTLE_ENDIAN__=1\" \"-o\" \"/home/koni/.cache/kiss/build-20469/rust/build/x86_64-unknown-linux-musl/stage0-std/x86_64-unknown-linux-musl/release/build/unwind-ab6a3e65ec86ddbe/out/../llvm-project/libunwind/src/Unwind-sjlj.o\" \"-c\" \"../llvm-project/libunwind/src/Unwind-sjlj.c\" with args \"clang\" did not execute successfully (status code exit code: 1).\r\n\r\n\r\n\r\nwarning: build failed, waiting for other jobs to finish...\r\nerror: build failed\r\ncommand did not execute successfully: \"/home/koni/.cache/kiss/build-20469/rust/build/x86_64-unknown-linux-musl/stage0/bin/cargo\" \"build\" \"-Zconfig-profile\" \"--target\" \"x86_64-unknown-linux-musl\" \"-Zbinary-dep-depinfo\" \"-j\" \"4\" \"--release\" \"--locked\" \"--frozen\" \"--features\" \"panic-unwind llvm-libunwind compiler-builtins-c\" \"--manifest-path\" \"/home/koni/.cache/kiss/build-20469/rust/src/libtest/Cargo.toml\" \"--message-format\" \"json-render-diagnostics\"\r\nexpected success, got: exit code: 101\r\nfailed to run: /home/koni/.cache/kiss/build-20469/rust/build/bootstrap/debug/bootstrap build -j 4\r\nBuild completed unsuccessfully in 0:01:09\r\n```\r\n\r\nThanks.\r\n\r\nA complete log is available here:\r\nhttp://termbin.com/ex3p", "labels": ["A-rustbuild", "C-bug", "T-infra"], "number_of_comments": 1, "created_at": "2020-02-17 02:16:29", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565995770": {"author_username": "wesleywiser", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69220, "title": "Add documentation for the `-Zself-profile` flag", "body": "", "labels": ["S-waiting-on-review"], "number_of_comments": 8, "created_at": "2020-02-17 00:12:45", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565981812": {"author_username": "Marwes", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69218, "title": "perf: Only process changed obligations in ObligationForest", "body": "This rewrites most of ObligationForest forest so to avoid iterating\r\nthrough the entire set of obligations on each `select` attempt. Instead\r\nonly the obligations that can actually make progress are processed. This\r\ngives great speedups in benchmarks such as `inflate` which create a\r\nlarge number of pending obligations which fail to make progress.\r\n\r\nTo support this the unification tables where extended to to keep track\r\nof which type inference variables that has actually changed at each\r\nstep. Which then lets `ObligationForest` get a list of only the changed\r\nvariables at each step which it can map back to its obligations.\r\n\r\nIn addition to this primary change, many of the other iterations in\r\n`ObligationForest` were refactored to only process lists of the nodes\r\nthat they actually are interested in. The extra bookkeeping needed for\r\nthis was possible without the primary change but were a performance\r\nregressions there as they slowed down the main loop. As the main loop is\r\nno longer the main issue these optimizations could be re-applied.\r\n\r\nThis needs some unit tests to the added data structures (I have some in an external crate I experimented in which I need to pull in), the `warn!` debug logs need to go/made `debug!` and I am not happy with the how `Offsets` are deregistered.\r\n\r\nI would interested in getting some feedback on the overall PR and seeing some perf results though (the extra complexity to in unification could see some regressions, there may ways to reduce the added overhead there further).", "labels": ["S-waiting-on-review"], "number_of_comments": 13, "created_at": "2020-02-16 22:28:46", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565964924": {"author_username": "jturner314", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69216, "title": "Overflow evaluating requirements when referencing associated type without a type parameter", "body": "This code fails to compile on stable (1.41.0), beta (1.42.0-beta.3), and nightly:\r\n\r\n```rust\r\nuse std::ops::Add;\r\n\r\nstruct Container<S: Data>(S);\r\n\r\ntrait Data {\r\n    type Elem;\r\n}\r\n\r\nimpl<A> Data for Vec<A> {\r\n    type Elem = A;\r\n}\r\n\r\nimpl<A, S> Add<Container<S>> for f32\r\nwhere\r\n    f32: Add<A, Output=A>,\r\n    S: Data<Elem=A>,\r\n{\r\n    type Output = Container<S>;\r\n    fn add(self, _rhs: Container<S>) -> Container<S> {\r\n        unimplemented!()\r\n    }\r\n}\r\n\r\nimpl<'a, A, S> Add<&'a Container<S>> for f32\r\nwhere\r\n      f32: Add<A>,\r\n      S: Data<Elem=A>,\r\n{\r\n    type Output = Container<Vec<<f32 as Add<A>>::Output>>;\r\n    fn add(self, _rhs: &Container<S>) -> Self::Output {\r\n        unimplemented!()\r\n    }\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\n([playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0b20b5a0031756e51ca72df4489526d1))\r\n\r\nwith the following error messages:\r\n\r\n```\r\nerror[E0275]: overflow evaluating the requirement `f32: std::ops::Add<Container<_>>`\r\n  --> src/main.rs:24:16\r\n   |\r\n24 | impl<'a, A, S> Add<&'a Container<S>> for f32\r\n   |                ^^^^^^^^^^^^^^^^^^^^^\r\n   |\r\n   = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate\r\n   = note: required because of the requirements on the impl of `std::ops::Add<Container<_>>` for `f32`\r\n   = note: required because of the requirements on the impl of `std::ops::Add<Container<_>>` for `f32`\r\n   = note: required because of the requirements on the impl of `std::ops::Add<Container<_>>` for `f32`\r\n   [...]\r\n   = note: required because of the requirements on the impl of `std::ops::Add<Container<_>>` for `f32`\r\n   = note: required because of the requirements on the impl of `std::ops::Add<Container<_>>` for `f32`\r\n\r\nerror[E0275]: overflow evaluating the requirement `f32: std::ops::Add<Container<_>>`\r\n  --> src/main.rs:30:5\r\n   |\r\n30 | /     fn add(self, _rhs: &Container<S>) -> Self::Output {\r\n31 | |         unimplemented!()\r\n32 | |     }\r\n   | |_____^\r\n   |\r\n   = help: consider adding a `#![recursion_limit=\"256\"]` attribute to your crate\r\n   = note: required because of the requirements on the impl of `std::ops::Add<Container<_>>` for `f32`\r\n   = note: required because of the requirements on the impl of `std::ops::Add<Container<_>>` for `f32`\r\n   = note: required because of the requirements on the impl of `std::ops::Add<Container<_>>` for `f32`\r\n   [...]\r\n   = note: required because of the requirements on the impl of `std::ops::Add<Container<_>>` for `f32`\r\n   = note: required because of the requirements on the impl of `std::ops::Add<Container<_>>` for `f32`\r\n```\r\n\r\nI expected it to compile without errors. Adding a type parameter for the type `<f32 as Add<A>>::Output` fixes the issue. In other words, this equivalent code compiles without errors:\r\n\r\n```rust\r\nuse std::ops::Add;\r\n\r\nstruct Container<S: Data>(S);\r\n\r\ntrait Data {\r\n    type Elem;\r\n}\r\n\r\nimpl<A> Data for Vec<A> {\r\n    type Elem = A;\r\n}\r\n\r\nimpl<A, S> Add<Container<S>> for f32\r\nwhere\r\n    f32: Add<A, Output=A>,\r\n    S: Data<Elem=A>,\r\n{\r\n    type Output = Container<S>;\r\n    fn add(self, _rhs: Container<S>) -> Container<S> {\r\n        unimplemented!()\r\n    }\r\n}\r\n\r\n// See the type `B` here.\r\nimpl<'a, A, S, B> Add<&'a Container<S>> for f32\r\nwhere\r\n      f32: Add<A, Output = B>,\r\n      S: Data<Elem=A>,\r\n{\r\n    type Output = Container<Vec<B>>;\r\n    fn add(self, _rhs: &Container<S>) -> Self::Output {\r\n        unimplemented!()\r\n    }\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\n([playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=d0815f4f20342c69ff611054c0236eaa))\r\n\r\nMaybe the compiler is over-eager in evaluating the `<f32 as Add<A>>::Output` type expression, but using a type parameter instead set equal to that type prevents the compiler from going too far?\r\n\r\n### Meta\r\n\r\nTested using the Rust playground.\r\n\r\n* stable: 1.41.0\r\n* beta: 1.42.0-beta.3 (2020-02-07 86f329b419dbac59da59)\r\n* nightly: 1.43.0-nightly (2020-02-15 61d9231ff2604a046798)", "labels": ["A-traits", "C-bug", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-16 20:32:18", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565961261": {"author_username": "alecmocatta", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69214, "title": "Type inference asks for annotations that are already present", "body": "```rust\r\nuse std::convert::TryInto;\r\n\r\nfn main() {\r\n    let _: usize = Some(0usize).map(|host: usize| 0usize).unwrap() + 0usize.try_into().unwrap();\r\n}\r\n\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=2fdb3ddfe24a37438c0723f62c278a11))\r\n\r\nErrors:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nerror[E0284]: type annotations needed for `usize`\r\n --> src/main.rs:4:38\r\n  |\r\n4 |     let _: usize = Some(0usize).map(|host: usize| 0usize).unwrap() + 0usize.try_into().unwrap();\r\n  |                                      ^^^^ consider giving this closure parameter a type\r\n  |\r\n  = note: cannot resolve `<usize as std::ops::Add<_>>::Output == usize`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0284`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```", "labels": ["A-diagnostics", "A-inference", "C-bug", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-16 20:06:39", "reactions": {"total_count": 4, "+1": 0, "-1": 0, "laugh": 4, "heart": 0, "hooray": 0}}, "565930412": {"author_username": "LeSeulArtichaut", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69213, "title": "Improve documentation on iterators length", "body": "Attempts to resolve #66491. @the8472 does this help?\r\n\r\nr? @steveklabnik", "labels": ["S-waiting-on-review"], "number_of_comments": 1, "created_at": "2020-02-16 16:22:13", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565922438": {"author_username": "BijanT", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69210, "title": "Tracking Issue for linked_list_remove", "body": "<!--\r\nThank you for creating a tracking issue! \ud83d\udcdc Tracking issues are for tracking a\r\nfeature from implementation to stabilisation. Make sure to include the relevant\r\nRFC for the feature if it has one. Otherwise provide a short summary of the\r\nfeature and link any relevant PRs or issues, and remove any sections that are\r\nnot relevant to the feature.\r\n\r\nRemember to add team labels to the tracking issue.\r\nFor a language team feature, this would e.g., be `T-lang`.\r\nSuch a feature should also be labeled with e.g., `F-my_feature`.\r\nThis label is used to associate issues (e.g., bugs and design questions) to the feature.\r\n-->\r\n#68705 adds a method in LinkedList to remove an element at a specified index.\r\n\r\nThe feature gate for the issue is `#![feature(linked_list_remove)]`.\r\n", "labels": ["A-collections", "B-unstable", "C-tracking-issue", "T-libs"], "number_of_comments": 0, "created_at": "2020-02-16 15:26:06", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565922408": {"author_username": "Mark-Simulacrum", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69209, "title": "Miscellaneous cleanup to formatting", "body": "Each commit stands alone.\r\n\r\nThis pull request will also resolve #58320.\r\n\r\nr? @dtolnay ", "labels": ["S-waiting-on-review"], "number_of_comments": 4, "created_at": "2020-02-16 15:25:53", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565908276": {"author_username": "RalfJung", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69208, "title": "debug_assert a few more raw pointer methods", "body": "Fixes https://github.com/rust-lang/rust/issues/53871", "labels": ["S-waiting-on-review"], "number_of_comments": 13, "created_at": "2020-02-16 13:50:00", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565859524": {"author_username": "Jess3Jane", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69204, "title": "`_` in associated types causes nightly and beta compiler to panic", "body": "### Code\r\n\r\n```\r\ntrait IAmATrait {\r\n    type Item;\r\n    fn function(&self) -> Self::Item;\r\n}\r\n\r\nstruct IAmAnObject(usize);\r\n\r\nimpl IAmATrait for IAmAnObject {\r\n    type Item = _;\r\n    fn function(&self) -> Self::Item {\r\n        self.0\r\n    }\r\n}\r\n\r\nfn main() {}\r\n```\r\nhttps://play.rust-lang.org/?version=nightly&mode=debug&edition=2018\r\n\r\n\r\n### Meta\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.43.0-nightly (61d9231ff 2020-02-15)\r\nbinary: rustc\r\ncommit-hash: 61d9231ff2604a0467987042d9ebf9ff9ea739b5\r\ncommit-date: 2020-02-15\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\n### Error output\r\n\r\n```\r\nerror: internal compiler error: bad placeholder type\r\n --> test.rs:9:17\r\n  |\r\n9 |     type Item = _;\r\n  |                 ^\r\n\r\nerror: internal compiler error: cat_expr Errd\r\n  --> test.rs:10:38\r\n   |\r\n10 |       fn function(&self) -> Self::Item {\r\n   |  ______________________________________^\r\n11 | |         self.0\r\n12 | |     }\r\n   | |_____^\r\n\r\nerror: internal compiler error: PromoteTemps: MIR had errors\r\n  --> test.rs:10:5\r\n   |\r\n10 | /     fn function(&self) -> Self::Item {\r\n11 | |         self.0\r\n12 | |     }\r\n   | |_____^\r\n\r\nerror: internal compiler error: broken MIR in DefId(0:11 ~ test[317d]::{{impl}}[0]::function[0]) (\"return type\"): bad type [type error]\r\n  --> test.rs:10:5\r\n   |\r\n10 | /     fn function(&self) -> Self::Item {\r\n11 | |         self.0\r\n12 | |     }\r\n   | |_____^\r\n\r\nerror: internal compiler error: broken MIR in DefId(0:11 ~ test[317d]::{{impl}}[0]::function[0]) (LocalDecl { mutability: Mut, local_info: Other, internal: false, is_block_tail: None, ty: [type error], user_ty: UserTypeProjections { contents: [] }, source_info: SourceInfo { span: test.rs:10:5: 12:6, scope: scope[0] } }): bad type [type error]\r\n  --> test.rs:10:5\r\n   |\r\n10 | /     fn function(&self) -> Self::Item {\r\n11 | |         self.0\r\n12 | |     }\r\n   | |_____^\r\n\r\nthread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:355:17\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.44/src/backtrace/libunwind.rs:86\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.44/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:78\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1428\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:474\r\n  12: std::panicking::begin_panic\r\n  13: <rustc_errors::HandlerInner as core::ops::drop::Drop>::drop\r\n  14: core::ptr::drop_in_place\r\n  15: <alloc::rc::Rc<T> as core::ops::drop::Drop>::drop\r\n  16: core::ptr::drop_in_place\r\n  17: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  18: scoped_tls::ScopedKey<T>::set\r\n  19: syntax::attr::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-nightly (61d9231ff 2020-02-15) running on x86_64-unknown-linux-gnu\r\n\r\nquery stack during panic:\r\nend of query stack\r\n```\r\n\r\n", "labels": ["A-associated-items", "C-bug", "I-ICE", "P-high", "T-compiler", "glacier", "regression-from-stable-to-beta"], "number_of_comments": 3, "created_at": "2020-02-16 06:28:00", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565857223": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69203, "title": " Implement unused crate lint for 2018 edition ", "body": "Fixes #57274\r\n\r\nThis PR fixes the `unused_extern_crate` lint to work with the 2018 edition. We now separately track whether or not crates in the extern prelude ended up getting used, and lint those that do not.\r\n\r\nNotes:\r\n* This lint ignores crates that have an `extern crate` statement. That is, `exern crate mycrate as renamed` will not trigger a lint for `mycrate` (but the existing `extern crate`-based lints will still run). This avoids false-positives when `#[macro_use]` is involved, and allows this lint to be suppressed using either `use mycrate as _` or `extern mycrate`.\r\n* I added in a hack which ignores crates named `panic_abort` and `panic_unwind`, to avoid lints in `libstd`. Ideally, we could just do `use panic_abort as _` and `use panic_unwind as _` - however, this currently triggers an error due to two different panic runtimes being linked in.\r\n* The `extern crate`-based lint (e.g. the already existing lint) performs several checks on the metadata of unused crates (e.g. `is_compiler_builtins`) to see if it should skip linting an otherwise unused crate. Unfortuantely, the nature of the extern prelude means that if a crate ends up unused, we will never have loaded the metadata for it. Unless we want to deliberately load unused crates during the new lint (which seems like a horrible hack), we can only use command line flags to determine if we should skip linting a crate. This prevents us from detecting `panic_abort` and `panic_unwind` via crate metadata instead of crate names.\r\n* There is no span associated with the new warning - by its very nature, there isn't any location that makes sense. Because of this, I chose to include the current crate name in the warning message - otherwise, the messages become useless when multiple crates in a workspace are built in parallel.", "labels": ["S-waiting-on-author"], "number_of_comments": 13, "created_at": "2020-02-16 06:00:42", "reactions": {"total_count": 6, "+1": 5, "-1": 0, "laugh": 0, "heart": 0, "hooray": 1}}, "565830016": {"author_username": "dtolnay", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69202, "title": "Tracking issue for boxed_slice_try_from", "body": "```rust\r\nimpl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]>\r\nwhere\r\n    [T; N]: LengthAtMost32;\r\n\r\nimpl<T, const N: usize> TryFrom<Rc<[T]>> for Rc<[T; N]>\r\nwhere\r\n    [T; N]: LengthAtMost32;\r\n\r\nimpl<T, const N: usize> TryFrom<Arc<[T]>> for Arc<[T; N]>\r\nwhere\r\n    [T; N]: LengthAtMost32;\r\n```\r\n\r\nThese were added in https://github.com/rust-lang/rust/pull/61515 with an #\\[unstable(...)\\] attribute but without a tracking issue. Since these are trait impls where both the trait and Self type are already stable, they are [already callable on a stable compiler](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=42b18eefd371631876827b188daec827) and we likely can't make further changes (other than removing the LengthAtMost32 bounds, which can take place after stabilization).\r\n\r\nAnyone should feel free to send a \"stabilization\" PR changing the stability attributes to #\\[stable(...)\\].", "labels": ["B-unstable", "C-tracking-issue", "T-libs"], "number_of_comments": 0, "created_at": "2020-02-16 00:35:57", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565827565": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69201, "title": "Permit attributes on 'if' expressions", "body": "Previously, attributes on 'if' expressions (e.g. `#[attr] if true {}`)\r\nwere disallowed during parsing. This made it impossible for macros to\r\nperform any custom handling of such attributes (e.g. stripping them\r\naway), since a compilation error would be emitted before they ever had a\r\nchance to run.\r\n\r\nThis PR permits attributes on 'if' expressions ('if-attrs' from here on).\r\nBoth built-in attributes (e.g. `#[allow]`, `#[cfg]`) and proc-macro attributes are supported.\r\n\r\nWe still do *not* accept attributes on 'other parts' of an if-else\r\nchain. That is, the following code snippet still fails to parse:\r\n\r\n```rust\r\nif true {} #[attr] else if false {} else #[attr] if false {} #[attr]\r\nelse {}\r\n```", "labels": ["S-waiting-on-review", "T-lang", "disposition-merge", "proposed-final-comment-period", "relnotes"], "number_of_comments": 7, "created_at": "2020-02-16 00:08:51", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 1}}, "565815170": {"author_username": "ecstatic-morse", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69197, "title": "Significant performance regression on the `encoding` benchmark", "body": "#69144 (a rollup)  slowed down check builds of the `encoding` benchmark considerably, see the [task-clock measurements](https://perf.rust-lang.org/compare.html?start=d538b80ad77949e46989cd355cdec193b574f052&end=10104085e4f9f52f405fa1cc5e5e18c4c4cc72d1&stat=task-clock). This degradation has been consistent over the last half-dozen perf runs, so it is not spurious. The following candidates have non-trivial changes to the parts of the compiler that are run during a check build.\r\n\r\n\r\n* #68728 (parse: merge fn syntax + cleanup item parsing)\r\n* #68938 (fix lifetime shadowing check in GATs) **unlikely**\r\n* #69057 (expand: misc cleanups and simplifications)\r\n* #69108 (Use HirId in TraitCandidate.) **ruled out by #69199**\r\n* #69126 (miri: fix exact_div) **unlikely**\r\n\r\nI doubt it is #68938 or #69126 so cc @Centril @cjgillot\r\n", "labels": ["I-compiletime", "P-high", "T-compiler", "regression-from-stable-to-nightly"], "number_of_comments": 6, "created_at": "2020-02-15 21:58:13", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565805079": {"author_username": "etna", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69195, "title": "Build error on Rust 1.41", "body": "Hi, I'm getting this error when trying to build Rust 1.41 with cargo:\r\n\r\n>     Finished release [optimized] target(s) in 0.52s\r\n>Installing libLLVM.so to stage 0 (x86_64-unknown-linux-gnu)\r\n>Copying stage0 rustc from stage0 (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu / x86_64-unknown-linux-gnu)\r\n>Assembling stage1 compiler (x86_64-unknown-linux-gnu)\r\n>Building stage1 std artifacts (x86_64-unknown-linux-gnu -> x86_64-unknown-linux-gnu)\r\n>error: failed to run `rustc` to learn about target-specific information\r\n>\r\n>Caused by:\r\n > process didn't exit successfully: `/home/etna/TmpBuildRAM/rustc-1.41.0-src/build/bootstrap/debug/rustc - --crate-name ___ --print=file-names -Zexternal-macro-backtrace -Wrust_2018_idioms -Wunused_lifetimes -Dwarnings -Zsave-analysis -Cprefer-dynamic --target x86_64-unknown-linux-gnu --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=cfg` (signal: 11, SIGSEGV: invalid memory reference)\r\n>command did not execute successfully: \"/home/etna/TmpBuildRAM/rustc-1.41.0-src/build/x86_64-unknown-linux-gnu/stage0/bin/cargo\" \"build\" \"-Zconfig-profile\" \"--target\" \"x86_64-unknown-linux-gnu\" \"-Zbinary-dep-depinfo\" \"-j\" \"48\" \"--release\" \"--features\" \"panic-unwind backtrace compiler-builtins-c\" \"--manifest-path\" \"/home/etna/TmpBuildRAM/rustc-1.41.0-src/src/libtest/Cargo.toml\" \"--message-format\" \"json-render-diagnostics\"\r\n>expected success, got: exit code: 101\r\n>failed to run: /home/etna/TmpBuildRAM/rustc-1.41.0-src/build/bootstrap/debug/bootstrap build\r\n>Build completed unsuccessfully in 0:00:04\r\n>etna@linux-oieh:~/TmpBuildRAM/rustc-1.41.0-src> \r\n\r\nNot sure what is happening as I was previously able to build all versions of Rust from 1.32 to 1.40. But now, out of curiosity, trying to build Rust 1.40 again returns the same error.\r\n\r\nDistribution is OpenSUSE 15.0, using self-built LLVM and Clang 7.0\r\n\r\nAny help will be greatly appreciated.", "labels": [], "number_of_comments": 1, "created_at": "2020-02-15 20:30:20", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565784106": {"author_username": "Mark-Simulacrum", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69191, "title": "beta regression: ICE on Tried to access field 0 of union Layout", "body": "- [`rotor v0.6.3`](https://crater-reports.s3.amazonaws.com/beta-1.42-1/beta-2020-02-05/reg/rotor-0.6.3/log.txt)\r\n- [`rotor-dns v0.4.0`](https://crater-reports.s3.amazonaws.com/beta-1.42-1/beta-2020-02-05/reg/rotor-dns-0.4.0/log.txt)\r\n- [`rotor-tools v0.3.2`](https://crater-reports.s3.amazonaws.com/beta-1.42-1/beta-2020-02-05/reg/rotor-tools-0.3.2/log.txt)\r\n\r\ncc @oli-obk \r\n\r\nI suspect (but have not verified) that this would be fixed by a backport of https://github.com/rust-lang/rust/pull/64987.", "labels": ["A-mir", "C-bug", "I-ICE", "P-high", "T-compiler", "regression-from-stable-to-beta"], "number_of_comments": 8, "created_at": "2020-02-15 17:41:09", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565783493": {"author_username": "Mark-Simulacrum", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69190, "title": "beta regression: $crate may not be imported", "body": "Number of crates regressed: 26\r\n\r\nLooks like essentially all the regressions come from a piston2d-gfx_graphics macro. Bisecting this may be helpful, not sure.\r\n\r\ncc @petrochenkov \r\n\r\n<details>\r\n\r\n- [`ThePianoDentist/rusty-dota-manager`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/ThePianoDentist.rusty-dota-manager/log.txt)\r\n- [`XavilPergis/rusty-tiles`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/XavilPergis.rusty-tiles/log.txt)\r\n- [`bluecereal/a_game`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/bluecereal.a_game/log.txt)\r\n- [`bluecereal/mvp_transform`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/bluecereal.mvp_transform/log.txt)\r\n- [`bluecereal/oop_gfx_test`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/bluecereal.oop_gfx_test/log.txt)\r\n- [`bluecereal/transform`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/bluecereal.transform/log.txt)\r\n- [`bluecereal/using_math_lib`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/bluecereal.using_math_lib/log.txt)\r\n- [`carols10cents/color-game`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/carols10cents.color-game/log.txt)\r\n- [`chip8-rust/chip8-ui`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/chip8-rust.chip8-ui/log.txt)\r\n- [`despawnerer/piston-tutorial`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/despawnerer.piston-tutorial/log.txt)\r\n- [`echochamber/rust_spin_wheel`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/echochamber.rust_spin_wheel/log.txt)\r\n- [`edigiacomo/snake-rust`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/edigiacomo.snake-rust/log.txt)\r\n- [`fabiosantoscode/life`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/fabiosantoscode.life/log.txt)\r\n- [`jakmeier/cheer-them-up`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/jakmeier.cheer-them-up/log.txt)\r\n- [`jakmeier/rusty-shortest-path-map-inspector`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/jakmeier.rusty-shortest-path-map-inspector/log.txt)\r\n- [`jjjjw/rust_elmish_rocket`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/jjjjw.rust_elmish_rocket/log.txt)\r\n- [`kamicut/rust-fractal-experiments`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/kamicut.rust-fractal-experiments/log.txt)\r\n- [`mattkuo/rusty-chips`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/mattkuo.rusty-chips/log.txt)\r\n- [`nbez/0.1.0`](https://crater-reports.s3.amazonaws.com/beta-1.42-1/beta-2020-02-05/reg/nbez-0.1.0/log.txt)\r\n- [`pierrechevalier83/mengner`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/pierrechevalier83.mengner/log.txt)\r\n- [`piston-opengex/0.6.0`](https://crater-reports.s3.amazonaws.com/beta-1.42-1/beta-2020-02-05/reg/piston-opengex-0.6.0/log.txt)\r\n- [`robinwhittleton/life_rs`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/robinwhittleton.life_rs/log.txt)\r\n- [`shmutalov/tick-tack-toe-killer-rs`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/shmutalov.tick-tack-toe-killer-rs/log.txt)\r\n- [`sumproxy/tetris_tmp`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/sumproxy.tetris_tmp/log.txt)\r\n- [`whodidthis/gfx-rs-testing`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/whodidthis.gfx-rs-testing/log.txt)\r\n- [`yeliknewo/souls`](https://crater-reports.s3.amazonaws.com/beta-1.42-rustdoc-1/beta-2020-02-05/gh/yeliknewo.souls/log.txt)\r\n\r\n</details>", "labels": ["P-high", "T-compiler", "regression-from-stable-to-beta"], "number_of_comments": 4, "created_at": "2020-02-15 17:36:38", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565773516": {"author_username": "matthewjasper", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69189, "title": "Erase regions in writeback", "body": "Regions in `TypeckTables` (except canonicalized user annotations) are now erased. Further, we no longer do lexical region solving on item bodies with `-Zborrowck=mir`.\r\n\r\ncc #68261\r\nr? @nikomatsakis ", "labels": ["S-waiting-on-review"], "number_of_comments": 2, "created_at": "2020-02-15 16:28:24", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 1}}, "565752143": {"author_username": "timvermeulen", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69187, "title": "Missed optimization: repeated pointer increments don't compile to a memcpy", "body": "```rust\r\npub unsafe fn copy(slice: &[u8], dst: *mut u8) {\r\n    let mut src = slice.as_ptr();\r\n    let mut dst = dst;\r\n\r\n    for _ in 0..slice.len() {\r\n        *dst = *src;\r\n        src = src.add(1);\r\n        dst = dst.add(1);\r\n    }\r\n}\r\n```\r\nThis doesn't currently compile to a `memcpy` ([Godbolt](https://godbolt.org/z/vpaa9a)).\r\n\r\nI figured this was worth filing because this seems to be the main reason that a naive `iter::Zip` implementation isn't optimal, which is why it's implemented the way it is.", "labels": ["A-LLVM", "C-enhancement", "I-slow", "T-compiler"], "number_of_comments": 4, "created_at": "2020-02-15 14:04:36", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565731668": {"author_username": "RalfJung", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69185, "title": "Unify and improve const-prop lints", "body": "Add a single helper method for all lints emitted by const-prop, and make that lint different from the CTFE `const_err` lint. Also consistently check overflow on *arithmetic*, not on the assertion, to make behavior the same for debug and release builds.\r\n\r\nSee [this summary comment](https://github.com/rust-lang/rust/pull/69185#issuecomment-587924754) for details and the latest status.\r\n\r\nIn terms of lint formatting, I went for what seems to be the better style: have a general message above the code, and then a specific message at the span:\r\n```\r\nerror: this arithmetic operation will overflow\r\n  --> $DIR/const-err2.rs:21:18\r\n   |\r\nLL |     let a_i128 = -std::i128::MIN;\r\n   |                  ^^^^^^^^^^^^^^^ attempt to negate with overflow\r\n```\r\nWe could also just have the specific message above and no text at the span if that is preferred.\r\n\r\nI also converted some of the existing tests to use compiletest revisions, so that the same test can check a bunch of different compile flags.\r\n\r\nFixes https://github.com/rust-lang/rust/issues/69020.\r\nHelps with https://github.com/rust-lang/rust/issues/69021: debug/release are now consistent, but the assoc-const test in that issue still fails (there is a FIXME in the PR for this). The reason seems to be that const-prop notices the assoc const in `T::N << 42` and does not even bother calling `const_prop` on that operation.\r\nHas no effect on https://github.com/rust-lang/rust/issues/61821; the duplication there has entirely different reasons.", "labels": ["S-waiting-on-bors"], "number_of_comments": 18, "created_at": "2020-02-15 10:54:06", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565721889": {"author_username": "dhardy", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69184, "title": "GAT + enum: incorrect unused lifetime error", "body": "This is a follow up on #67089, which now works. The following doesn't ([play link](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=d6570106bebc880bc301f30de216b611)):\r\n```rust\r\n#![feature(generic_associated_types)]\r\n\r\ntrait A {\r\n    type B<'a>;\r\n    \r\n    fn make_b<'a>(&'a self) -> Self::B<'a>;\r\n}\r\n\r\nstruct S {}\r\n\r\nimpl A for S {\r\n    type B<'a> = &'a S;\r\n    fn make_b<'a>(&'a self) -> &'a Self {\r\n        self\r\n    }\r\n}\r\n\r\nenum E<'a> {\r\n    S(<S as A>::B<'a>),\r\n}\r\n```\r\nError is:\r\n```\r\n18 | enum E<'a> {\r\n   |        ^^ unused parameter\r\n```\r\nhowever, this lifetime clearly is used and is required.", "labels": ["A-lifetimes", "A-lint", "C-bug", "F-generic_associated_types", "T-compiler", "requires-nightly"], "number_of_comments": 5, "created_at": "2020-02-15 09:18:02", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565644690": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69178, "title": "Propagate lifetime resolution errors into tcx.type_of", "body": "Fixes #69136\r\n\r\nPreviously, lifetime resolution errors would cause an error to be\r\nemitted, but would not mark the parent type as 'tainted' in any way.\r\nWe usually abort compilation before this becomes an issue - however,\r\nopaque types can cause us to type-check function bodies before such an\r\nabort occurs. Ths can result in trying to instantiate opaque types that\r\nhave invalid computed generics. Currently, this only causes issues for\r\nnested opaque types, but there's no reason to expect the computed\r\ngenerics to be sane when we had unresolved lifetimes (which can result\r\nin extra lifetime parameters getting added to the generics).\r\n\r\nThis commit tracks 'unresolved lifetime' errors that occur during\r\nlifetime resolution. When we type-check an item, we bail out and return\r\n`tcx.types.err` if a lifetime error was reported for that type. This\r\ncauses us to skip type-checking of types affected by the lifetime error,\r\nwhile still checking unrelated types.\r\n\r\nAdditionally, we now check for errors in 'parent' opaque types (if such\r\na 'parent' exists) when collecting constraints for opaque types. This\r\nreflects the fact that opaque types inherit generics from 'parent'\r\nopaque types - if an error ocurred while type-checking the parent,\r\nwe don't attempt to type-check the child.", "labels": ["S-waiting-on-review"], "number_of_comments": 4, "created_at": "2020-02-15 02:36:31", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565643494": {"author_username": "Lokathor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69177, "title": "[Unstable Book] The `compiler_builtins_lib` apparently doesn't even exist any more.", "body": "The Unstable Book entry on [how to build a `no_std` binary](https://doc.rust-lang.org/unstable-book/language-features/lang-items.html#writing-an-executable-without-stdlib) says that you need to use the `compiler_builtins` crate if you get specific kinds of linker errors about missing intrinsics. This is true.\r\n\r\nIt then points you to the [compiler_builtins_lib](https://doc.rust-lang.org/unstable-book/library-features/compiler-builtins-lib.html) feature as the way to access that crate. This is apparently wrong, because `rustc 1.42.0-nightly (9ed29b6ff 2020-01-29)` claims that there is no such feature at all.\r\n\r\nHowever, the readme for the `compiler_builtins` crate [tells you how and when to use the crate](https://github.com/rust-lang/compiler-builtins#when-and-how-to-use-this-crate). It says to just add the git link and an `extern crate compiler_builtins;` and no lang feature. On Linux x86_64 GNU (but not MUSL) this seems to work, though it's easy to also then get [multiple definition errors](https://github.com/rust-lang/compiler-builtins/issues/336), and that seems to be fixed by setting `codegen-units=1`.\r\n\r\nAnyway there's no `compiler_builtins_lib` feature so that page should probably go away.", "labels": ["C-cleanup", "T-doc"], "number_of_comments": 0, "created_at": "2020-02-15 02:24:05", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565609340": {"author_username": "reinerp", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69174, "title": "Bad quality code for `Clone` on enum types", "body": "For this Rust code, we get some pretty bad assembly:\r\n\r\n```rust\r\n#[derive(Clone)]\r\npub enum Foo {\r\n    A(u8),\r\n    B(bool),\r\n}\r\n\r\n#[derive(Clone)]\r\npub enum Bar {\r\n    C(Foo),\r\n    D(u8),\r\n}\r\n\r\npub fn clone_foo(f: &Foo) -> Foo {\r\n    f.clone()\r\n}\r\n\r\npub fn clone_bar(b: &Bar) -> Bar {\r\n    b.clone()\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=release&edition=2018&gist=c14facc15a40601a2eb8dd10e122e421))\r\n\r\nAssembly:\r\n\r\n```\r\nplayground::clone_bar:\r\n\tmovb\t1(%rdi), %al\r\n\tcmpb\t$1, (%rdi)\r\n\tjne\t.LBB1_2\r\n\txorl\t%ecx, %ecx\r\n\tmovl\t$1, %edx\r\n\tjmp\t.LBB1_3\r\n\r\n.LBB1_2:\r\n\tmovzbl\t2(%rdi), %edx\r\n\txorl\t%ecx, %ecx\r\n\ttestb\t%dl, %dl\r\n\tsetne\t%cl\r\n\tcmpb\t$1, %al\r\n\tsete\t%al\r\n\tcmovnel\t%edx, %ecx\r\n\tshll\t$16, %ecx\r\n\txorl\t%edx, %edx\r\n\r\n.LBB1_3:\r\n\torl\t%edx, %ecx\r\n\tmovzbl\t%al, %eax\r\n\tshll\t$8, %eax\r\n\torl\t%ecx, %eax\r\n\tretq\r\n```\r\n\r\nTo see that it's possibly to do better, we can simply add a `Copy` instance to the types. Then the code _even for `Clone`_ gets much better:\r\n\r\n```rust\r\n#[derive(Clone, Copy)]\r\npub enum Foo {\r\n    A(u8),\r\n    B(bool),\r\n}\r\n\r\n#[derive(Clone, Copy)]\r\npub enum Bar {\r\n    C(Foo),\r\n    D(u8),\r\n}\r\n\r\npub fn clone_foo(f: &Foo) -> Foo {\r\n    f.clone()\r\n}\r\n\r\npub fn clone_bar(b: &Bar) -> Bar {\r\n    b.clone()\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=release&edition=2018&gist=4215a15ed3879563d06ab23e548ff8b1))\r\n\r\nAssembly:\r\n\r\n```\r\nplayground::clone_bar:\r\n\tmovzwl\t(%rdi), %ecx\r\n\tmovzbl\t2(%rdi), %eax\r\n\tshll\t$16, %eax\r\n\torl\t%ecx, %eax\r\n\tretq\r\n```\r\n\r\nIt's still not perfect (why are there two 2-byte loads instead of a single 4-byte load?) but it's much better.", "labels": [], "number_of_comments": 4, "created_at": "2020-02-14 23:41:32", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565597057": {"author_username": "Centril", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69173, "title": "unused_unsafe: stop interpreting `unsafe fn`s as unsafe contexts", "body": "In other words, the following will result in a lint being emitted today:\r\n```rust\r\nunsafe fn _bar() {}\r\n\r\nunsafe fn _foo() {\r\n    unsafe {\r\n        _bar();\r\n    }\r\n}\r\n```\r\n\r\n==>\r\n\r\n```rust\r\nwarning: unnecessary `unsafe` block\r\n --> src/lib.rs:4:5\r\n  |\r\n3 | unsafe fn _foo() {\r\n  | ---------------- because it's nested under this `unsafe` fn\r\n4 |     unsafe {\r\n  |     ^^^^^^ unnecessary `unsafe` block\r\n  |\r\n  = note: `#[warn(unused_unsafe)]` on by default\r\n```\r\n\r\nBased on the discussion in a recent language team meeting (see summary as outlined by @nikomatsakis in https://github.com/rust-lang/rfcs/pull/2585#issuecomment-586325462), we would like to stop emitting the lint in this case where we have unsafe operations inside an `unsafe { ... }` inside an `unsafe fn` (it's probably easiest to not emit the lint at all as opposed to emitting a different lint name, but this can be determined as part of the implementation).\r\n\r\ncc @RalfJung @rust-lang/lang \n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\nThis issue has been assigned to @LeSeulArtichaut via [this comment](https://github.com/rust-lang/rust/issues/69173#issuecomment-587110831).\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"LeSeulArtichaut\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "labels": ["A-lint", "C-enhancement", "E-mentor", "T-compiler"], "number_of_comments": 3, "created_at": "2020-02-14 22:59:44", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565554540": {"author_username": "Amanieu", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69171, "title": "[WIP] Implement new asm! syntax from RFC 2850", "body": "This PR implements the new `asm!` syntax proposed in https://github.com/rust-lang/rfcs/pull/2850.\r\n\r\nThe implementation is not yet complete, but I feel that it has come to the point where some review & guidance from @rust-lang/compiler would be helpful.\r\n\r\nNote: This PR is based on top of #68404, so you'll want to ignore the first two commits when reviewing.\r\n\r\nRemaining tasks:\r\n- [ ] Resolve various `TODO` comments in the code.\r\n- [ ] Validate operand types against a whitelist of allowed types (int, float, pointer, etc).\r\n- [ ] Automatically convert `fn` operands to function pointers.\r\n- [ ] Warn if an operand is smaller than the register it is placed in.\r\n- [ ] Borrow-check operands to avoid having two outputs point to the same place.\r\n- [ ] Check that `sym` operands point to a `static` or `fn`.\r\n- [x] Lower to MIR\r\n- [ ] Lower to LLVM\r\n- [ ] Add tests\r\n\r\nSome notes/questions on the implementation:\r\n- The macro expansion is heavily based on the `format_args!` macro, which makes sense since it uses basically the same format. However there may be a bit of code duplication as a result.\r\n- `sym` operands take a `Path` operand which must point to either a function or a static. This is currently stored in the AST and HIR as an `Expr` (with `ExprKind::Path`) since it then works transparently with existing passes (e.g. liveness). However it is a bit of a lie since the asm doesn't actually read the `static`, it only takes its address.\r\n- I'm not sure how best to represent inline assembly in MIR. I can think of several options:\r\n  - ~Represent it as a `Statement`, like the previous implementation. This effectively acts as a parallel `Assign` since it reads/writes to multiple places at once for outputs.~\r\n  - ~Represent it as an `RValue` which takes its inputs as arguments and returns a tuple of outputs. The outputs are then moved to their destinations with `Assign`. This is closer to the LLVM representation, but it may be difficult to model the borrow checking behavior (we want to avoid multiple outputs to the same place).~\r\n  - Represent it as a `Terminator` like a `Call`. This works well because the new `asm!` has a `noreturn` flag which indicates that it never returns.", "labels": ["S-waiting-on-review"], "number_of_comments": 6, "created_at": "2020-02-14 21:02:49", "reactions": {"total_count": 15, "+1": 8, "-1": 0, "laugh": 0, "heart": 1, "hooray": 2}}, "565424441": {"author_username": "ababo", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69169, "title": "Trait bounds were not satisfied", "body": "I'm not sure if this is a compiler bug, but since I didn't get any answers on StackOverflow I'd try to add an issue here.\r\n\r\nI tried this code:\r\n\r\n```rust\r\nuse futures_util::compat::Future01CompatExt;\r\nuse gluon::{\r\n    new_vm,\r\n    vm::api::{FunctionRef, Getable, Pushable, VmType},\r\n    ThreadExt,\r\n};\r\n\r\npub type Error = gluon::Error;\r\n\r\npub struct Script<'vm, 'value, In, Out>\r\nwhere\r\n    In: VmType + Pushable<'vm>,\r\n    Out: VmType + Getable<'vm, 'value> + Send + Sync,\r\n{\r\n    vm: gluon::RootedThread,\r\n}\r\n\r\nimpl<'vm, 'value, In, Out> Script<'vm, 'value, In, Out>\r\nwhere\r\n    In: VmType + Pushable<'vm>,\r\n    Out: VmType + Getable<'vm, 'value> + Send + Sync,\r\n{\r\n    pub fn read(text: &str) -> Result<Script<In, Out>, Error> {\r\n        let mut vm = new_vm();\r\n\r\n        vm.run_io(true);\r\n\r\n        vm.load_script(\"main\", text).map(|()| Script { vm: vm })\r\n    }\r\n\r\n    pub async fn run(&mut self, input: &In) -> Result<Out, Error> {\r\n        let func: FunctionRef<fn(In) -> Out> = self.vm.get_global(\"main\")?;\r\n\r\n        return func.call_async(input).compat().await;\r\n    }\r\n}\r\n```\r\nAs you can see I explicitly bound `In` and `Out` with the needed traits, but still get \"trait bounds were not satisfied\" error.\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.41.0\r\nbinary: rustc\r\ncommit-hash: unknown\r\ncommit-date: unknown\r\nhost: x86_64-alpine-linux-musl\r\nrelease: 1.41.0\r\nLLVM version: 9.0\r\n```", "labels": ["A-diagnostics", "A-lifetimes", "C-enhancement", "T-compiler"], "number_of_comments": 6, "created_at": "2020-02-14 16:16:36", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565329422": {"author_username": "GuillaumeGomez", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69167, "title": "Source code external url", "body": "Fixes #67804\r\n\r\ncc @jyn514 \r\ncc @ollie27 \r\n\r\nr? @kinnison ", "labels": ["S-waiting-on-author"], "number_of_comments": 5, "created_at": "2020-02-14 13:33:26", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 2}}, "565183395": {"author_username": "haraldh", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69163, "title": "Move the <dyn Error>::chain() method to a trait", "body": "Because `chain()` was only implemented for `dyn Error`, users had\r\nto cast errors to a `&(dyn Error)` to use the `chain()` method.\r\n\r\n```rust\r\n    let mut iter = (&my_error as &(dyn Error)).chain();\r\n    // or\r\n    let mut iter = <dyn Error>::chain(&my_error);\r\n    // or\r\n    let mut iter = Error::chain(&my_error);\r\n```\r\n\r\nWhat I would liked to have is\r\n\r\n```rust\r\npub trait Error: Debug + Display {\r\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\r\n        None\r\n    }\r\n\r\n    fn chain(&self) -> Chain<'_> where Self: Sized + 'static {\r\n        Chain {\r\n            current: Some(self),\r\n        }\r\n    }\r\n}\r\n\r\nimpl dyn Error + 'static {\r\n    fn chain(&self) -> Chain<'_> {\r\n        Chain {\r\n            current: Some(self),\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThis doesn't work, because of:\r\nhttps://github.com/rust-lang/rust/issues/69161\r\n\r\nThis patch introduces an ErrorChain trait, which accomplishes the\r\njob and is implemented for `Error` and `dyn Error + 'static`.", "labels": ["S-waiting-on-review"], "number_of_comments": 9, "created_at": "2020-02-14 08:44:40", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565182293": {"author_username": "haraldh", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69161, "title": "Disambiguate method call for impl on dyn Trait", "body": "```rust\r\npub trait Error: Debug + Display {\r\n    fn source(&self) -> Option<&(dyn Error + 'static)> {\r\n        None\r\n    }\r\n\r\n    fn chain(&self) -> Chain<'_> where Self: Sized + 'static {\r\n        Chain {\r\n            current: Some(self),\r\n        }\r\n    }\r\n}\r\n\r\nimpl dyn Error + 'static {\r\n    fn chain(&self) -> Chain<'_> {\r\n        Chain {\r\n            current: Some(self),\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nSeems like the compiler tries the trait method for an `dyn Error + 'static` even though it does not work, because of !Sized and does not consider taking the `impl dyn Error + 'static`.\r\n\r\nPlayground: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=a6845b426451f1d7a5105a9bd3a00499\r\n\r\nerror:\r\n```\r\nerror[E0034]: multiple applicable items in scope\r\n  --> src/main.rs:82:28\r\n   |\r\n82 |     let mut iter = dyn_err.chain();\r\n   |                    --------^^^^^--\r\n   |                    |       |\r\n   |                    |       multiple `chain` found\r\n   |                    help: disambiguate the method call for candidate #2: `Error::chain(&dyn_err)`\r\n   |\r\nnote: candidate #1 is defined in an impl for the type `(dyn Error + 'static)`\r\n  --> src/main.rs:16:5\r\n   |\r\n16 |     fn chain(&self) -> Chain<'_> {\r\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\nnote: candidate #2 is defined in the trait `Error`\r\n  --> src/main.rs:8:5\r\n   |\r\n8  |     fn chain(&self) -> Chain<'_> where Self: Sized + 'static {\r\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n```", "labels": ["A-traits", "C-feature-request", "T-lang"], "number_of_comments": 1, "created_at": "2020-02-14 08:42:07", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565156099": {"author_username": "lzutao", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69160, "title": "rustdoc: Hide the \"Show hidden undocumented items\"", "body": "I enabled in \"Auto-hide trait implementations documentation\" feature in Settings.\r\nBut the \"Show hidden undocumented items\" strings still displays and it is quite distracting to me:\r\n![image](https://user-images.githubusercontent.com/15225902/74510822-258cc700-4f37-11ea-9c42-ae6f24505757.png)\r\n\r\nIt would be nice if it hide those strings completely by default.", "labels": ["C-enhancement", "T-rustdoc"], "number_of_comments": 0, "created_at": "2020-02-14 07:35:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565088608": {"author_username": "chrissimpkins", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69155, "title": "Add support for LLVM globals corresponding to miri allocations should be named alloc123", "body": "Adds support for this request from @eddyb in #69134:\r\n\r\n> That is, if -Zfewer-names is false (usually only because of --emit=llvm-ir), we should use the same name for LLVM globals we generate out of miri allocs as #67133 does in MIR output (allocN).\r\n>\r\n>This way, we can easily see the mapping between MIR and LLVM IR (and it shouldn't be any costlier for regular compilation, which would continue to use unnamed globals).\r\n\r\nr? @eddyb \r\ncc @oli-obk ", "labels": ["S-waiting-on-review"], "number_of_comments": 3, "created_at": "2020-02-14 03:58:26", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565074895": {"author_username": "nnethercote", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69153, "title": "Re-evaluate `Hash{Set,Map}` vs `FxHash{Set,Map}` once #69152 lands", "body": "rustc uses `FxHash{Set,Map}` everywhere rather than `Hash{Set,Map}`, because the `DefaultHasher` used by `Hash{Set,Map}` is slow.\r\n\r\nBut once #69152 lands, `DefaultHasher` will be a lot faster when hashing integers, which is a common case; in one microbenchmark I saw a ~2.5x speed-up. Combine that with the fact that `FxHasher` is a lower-quality hasher and so tends to result in more collisions, and the default hash tables might be faster. (On a different microbenchmark I saw that `HashSet<u32>` was a little bit faster than `FxHashSet<u32>`.)\r\n\r\nWe should evaluate this, probably by replacing every `FxHash{Set,Map}` with `Hash{Set,Map}`. (It keeps things simpler if we exclusively used one or the other, rather than a mix.)\r\n\r\nI briefly tried to do this, but we have a lint that produces this message if you try to use `Hash{Set,Map}`: \"error: Prefer FxHashSet over HashSet, it has better performance\". I couldn't work out how to disable it.\r\n\r\ncc @rust-lang/wg-compiler-performance \r\ncc @cbreeden \r\ncc @Amanieu \r\n\r\n", "labels": ["I-compiletime", "T-compiler", "WG-compiler-performance"], "number_of_comments": 4, "created_at": "2020-02-14 03:06:25", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565055034": {"author_username": "nnethercote", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69152, "title": "Speed up `DefaultHasher`, `SipHasher`, and `SipHasher13`.", "body": "This PR applies the speedups to `SipHasher128` from #68914 to the Sip hashers in `libcore`, and also adds the missing `write_*` methods required so that they can benefit from the speedups. Default hashing of integers is now something like 2.5x faster, and default hash tables should be more competitive with hash tables from the `fxhash` crate.\r\n\r\nIt also undoes a part of #68914's changes to `SipHasher128` because I found they were a pessimisation.\r\n\r\nr? @michaelwoerister", "labels": ["S-waiting-on-review", "T-libs", "relnotes"], "number_of_comments": 11, "created_at": "2020-02-14 01:53:33", "reactions": {"total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "heart": 2, "hooray": 0}}, "565042075": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69151, "title": "rustc segfaults when printing a backtrace for ICEs when debug=true is set", "body": "When `debug=true` is set in `config.toml,` my machine generates a `librustc_driver.so` with a size of 2.2 GB, of which 2.1 GB is debuginfo. This ends up triggering https://github.com/ianlancetaylor/libbacktrace/issues/32. Since `backtrace-rs` [ignores errors from `libbacktrace`](https://github.com/rust-lang/backtrace-rs/blob/190b2f9bb1df384be686eadd1d14cb95de0d87d4/src/symbolize/libbacktrace.rs#L156), we continue trying to print the backtrace, which leads to a segfaut since the `strtab` has been freed due to the `libbacktrace` error.\r\n\r\nThere are a couple of ways that we can address this:\r\n\r\n1) Fix the `libbacktrace` bug - I think this should be fairly straightforward, but I haven't attempted it yet.\r\n2) Switch over to using `backtrace-rs`'s `gimli` backend - however, I don't think it's feature-complete atm.\r\n\r\nIt would probably also be a good idea to investigate why 2.1 GB of debuginfo is getting generated - this seems really excessive.", "labels": ["A-debuginfo", "C-bug", "I-crash", "T-compiler"], "number_of_comments": 4, "created_at": "2020-02-14 01:07:20", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "565006596": {"author_username": "phaazon", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69149, "title": "rustc fails to resolve an associated type when using Self: Trait<A> in a method of a trait", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\n_Somewhat_ minimal reproducible code:\r\n\r\n```rust\r\npub trait Foo<L> {\r\n    type Repr;\r\n\r\n    fn foo(repr: &Self::Repr);\r\n}\r\n\r\npub trait Bar {\r\n    fn bar<L>(repr: &Self::Repr)\r\n    where\r\n        Self: Foo<L>;\r\n}\r\n\r\n// now let\u2019s implement Bar for a type\r\n#[derive(Debug)]\r\npub struct Hello {\r\n    pub handle: u32,\r\n}\r\n\r\nimpl<L> Foo<L> for u32 {\r\n    type Repr = Hello;\r\n\r\n    fn foo(repr: &Self::Repr) {\r\n        println!(\"{:?}\", repr);\r\n    }\r\n}\r\n\r\n// the weird things start here; notice how we need <Self as Base<L>> here\r\nimpl Bar for u32 {\r\n    fn bar<L>(repr: &<Self as Foo<L>>::Repr)\r\n    where\r\n        Self: Foo<L>,\r\n    {\r\n        println!(\r\n            \"{}\",\r\n            repr.handle // <- opaque type here\r\n            //unsafe { std::mem::transmute::<_, &Hello>(repr) }.handle // <- current workaround :()\r\n        );\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let h = Hello { handle: 3 };\r\n    u32::bar::<()>(&h);\r\n}\r\n```\r\n\r\nI expected to see this happen: code should compile just fine.\r\n\r\nInstead, this happened: result from _rustc_:\r\n\r\n```\r\nerror[E0609]: no field `handle` on type `&<u32 as Foo<L>>::Repr`\r\n  --> src/main.rs:52:18\r\n   |\r\n52 |             repr.handle // <- opaque type here\r\n   |                  ^^^^^^\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\nBug present in both _stable_ and _nightly_ (I haven\u2019t tested _beta_ but I guess it\u2019s there too).\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.41.0 (5e1a79984 2020-01-27)\r\nbinary: rustc\r\ncommit-hash: 5e1a799842ba6ed4a57e91f7ab9435947482f7d8\r\ncommit-date: 2020-01-27\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.41.0\r\nLLVM version: 9.0\r\n```\r\n\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\nN/A\r\n```\r\n\r\n</p>\r\n</details>\r\n", "labels": ["C-bug"], "number_of_comments": 1, "created_at": "2020-02-13 23:16:38", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564964431": {"author_username": "estebank", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69148, "title": "Account for bounds and asociated items when denying `_`", "body": "Fix #68801, #69204. Follow up to #67597 and #68071.\r\n\r\nOutput for the original ICE report:\r\n\r\n```\r\n    Checking vinoteca v5.0.0 (/Users/ekuber/workspace/vinoteca)\r\nerror[E0121]: the type placeholder `_` is not allowed within types on item signatures\r\n  --> src/producers.rs:43:70\r\n   |\r\n43 | pub fn top<Table: diesel::Table + diesel::query_dsl::InternalJoinDsl<_, diesel::query_source::joins::Inner, _>>(table: Table, limit: usize, connection: DbConn) -> RestResult<Vec<TopWineType>> {\r\n   |                                                                      ^ not allowed in type signatures       ^ not allowed in type signatures\r\n\r\nerror: aborting due to previous error\r\n```", "labels": ["S-waiting-on-review", "T-compiler"], "number_of_comments": 4, "created_at": "2020-02-13 21:36:37", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564961644": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69147, "title": "Incorrect trait-object warning when returning a type-alias-impl-trait", "body": "The following code:\r\n\r\n```rust\r\n#![feature(type_alias_impl_trait)]\r\n\r\ntype Foo = impl Copy;\r\nfn bar(val: &u8) -> Foo + 'static {\r\n    true\r\n}\r\n```\r\n\r\nproduces the following messages:\r\n\r\n```\r\nerror[E0404]: expected trait, found opaque type `Foo`\r\n --> src/lib.rs:4:21\r\n  |\r\n4 | fn bar(val: &u8) -> Foo + 'static {\r\n  |                     ^^^ not a trait\r\n\r\nwarning: trait objects without an explicit `dyn` are deprecated\r\n --> src/lib.rs:4:21\r\n  |\r\n4 | fn bar(val: &u8) -> Foo + 'static {\r\n  |                     ^^^^^^^^^^^^^ help: use `dyn`: `dyn Foo + 'static`\r\n  |\r\n  = note: `#[warn(bare_trait_objects)]` on by default\r\n```\r\n\r\nThe error message is correct - `Foo` is not a trait, so writing `+ 'static` makes no sense. However, the warning message is completely inapplicable - `Foo` is not a trait, so adding `dyn` will just produce a different error.\r\n\r\nWe should suppress this warning if the user didn't actually write down the name of a trait.", "labels": ["A-lint", "C-bug", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-13 21:30:45", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564935613": {"author_username": "matthewjasper", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69145, "title": "Fix MIR typeck soundness holes", "body": "* Check types of static items\r\n* Always check lifetime bounds of `Copy` impls\r\n\r\nr? @nikomatsakis \r\ncloses #69114 ", "labels": ["S-waiting-on-bors", "T-compiler", "beta-accepted", "beta-nominated", "stable-accepted", "stable-nominated"], "number_of_comments": 6, "created_at": "2020-02-13 20:35:56", "reactions": {"total_count": 8, "+1": 0, "-1": 0, "laugh": 0, "heart": 2, "hooray": 6}}, "564849617": {"author_username": "Datarecovery09", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69140, "title": "Compiler failed to spawn thread, \"Resource temporarily unavailable\" on hello-world; Ubuntu VM.", "body": "<!--\r\nThank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\r\na minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\r\nhow to create smaller examples.\r\n\r\nhttp://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\r\n\r\n-->\r\nSeemingly random bug; cannot reproduce reliably. Tends to vanish for some time when I reboot the system, but always comes back after some time. CPU and RAM are barely used when it occurs.\r\n\r\n### System\r\n```\r\nDistributor ID: Ubuntu\r\nDescription:    Ubuntu 18.04.4 LTS\r\nRelease:        18.04\r\nCodename:       bionic\r\n```\r\n\r\n### Code\r\n```\r\nfn main() {\r\n    println!(\"Hello, world!\");\r\n}\r\n```\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\nBug occurs in nightly and stable versions.\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.43.0-nightly (58b834344 2020-02-05)\r\nbinary: rustc\r\ncommit-hash: 58b834344fc7b9185e7a50db1ff24e5eb07dae5e\r\ncommit-date: 2020-02-05\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\n### Error output\r\n\r\n```\r\n`rustc --crate-name hello --edition=2018 src/main.rs --error-format=json --json=diagnostic-rendered-ansi --crate-type bin --emit=dep-info,link -C debuginfo=2 -C metadata=3030fab4ddb057dd -C extra-filename=-3030fab4ddb057dd --out-dir /home/jweber/rust/hello/target/debug/deps -C incremental=/home/jweber/rust/hello/target/debug/incremental -L dependency=/home/jweber/rust/hello/target/debug/deps`\r\nthread '<unnamed>' panicked at 'failed to spawn thread: Os { code: 11, kind: WouldBlock, message: \"Resource temporarily unavailable\" }', /rustc/58b834344fc7b9185e7a50db1ff24e5eb07dae5e/src/libstd/thread/mod.rs:619:5\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary><strong>Backtrace</strong></summary>\r\n<p>\r\n\r\n```\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1428\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:474\r\n  12: rust_begin_unwind\r\n             at src/libstd/panicking.rs:378\r\n  13: core::panicking::panic_fmt\r\n             at src/libcore/panicking.rs:85\r\n  14: core::option::expect_none_failed\r\n             at src/libcore/option.rs:1199\r\n  15: std::thread::spawn\r\n  16: rustc_codegen_ssa::back::write::spawn_work\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n", "labels": ["C-bug", "I-ICE", "O-linux", "T-compiler"], "number_of_comments": 6, "created_at": "2020-02-13 17:46:56", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564846994": {"author_username": "GuillaumeGomez", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69139, "title": "clean up E0308 explanation", "body": "r? @Dylan-DPC ", "labels": ["S-waiting-on-review"], "number_of_comments": 2, "created_at": "2020-02-13 17:42:18", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564812364": {"author_username": "steffahn", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69137, "title": "The \"type_alias_impl_trait\" feature has problems handling lifetime parameters.", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI was starting with this function (which does compile on nightly):\r\n```rust\r\n#![feature(unboxed_closures)]\r\n#![feature(type_alias_impl_trait)]\r\nfn curry<'a, A: 'a, B, C, F: Fn(A, B) -> C> (f: &'a F)\r\n    -> impl Fn<(A,), Output = impl FnOnce(B) -> C + 'a> + 'a\r\n{\r\n    move |a| move |b| f(a,b)\r\n}\r\n```\r\nand wanted to give a name to its return type.\r\nThe straightforward approach seems to be _(please correct me if the \"right\" way to do this is different)_:\r\n```rust\r\n#![feature(unboxed_closures)]\r\n#![feature(type_alias_impl_trait)]\r\ntype Curried<'a, A: 'a, B, C, F: Fn(A, B) -> C>\r\n = impl Fn<(A,), Output = impl FnOnce(B) -> C + 'a> + 'a;\r\n\r\nfn curry<'a, A: 'a, B, C, F: Fn(A, B) -> C> (f: &'a F)\r\n    -> Curried<'a, A, B, C, F>\r\n{\r\n    move |a| move |b| f(a,b)\r\n}\r\n```\r\nBut the compiler is currently unhappy with the lifetimes. I'm getting the following.\r\n```\r\nerror: cannot infer an appropriate lifetime\r\n  --> src/main.rs:11:5\r\n   |\r\n6  |  = impl Fn<(A,), Output = impl FnOnce(B) -> C + 'a> + 'a;\r\n   |                           ------------------------ this return type evaluates to the `'static` lifetime...\r\n...\r\n11 |     move |a| move |b| f(a,b)\r\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ ...but this borrow...\r\n   |\r\nnote: ...can't outlive the lifetime `'a` as defined on the function body at 8:10\r\n  --> src/main.rs:8:10\r\n   |\r\n8  | fn curry<'a, A: 'a, B, C, F: Fn(A, B) -> C> (f: &'a F)\r\n   |          ^^\r\nhelp: you can add a bound to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the function body at 8:10\r\n   |\r\n9  |     -> Curried<'a, A, B, C, F> + '_\r\n   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nerror: cannot infer an appropriate lifetime\r\n  --> src/main.rs:11:14\r\n   |\r\n6  |  = impl Fn<(A,), Output = impl FnOnce(B) -> C + 'a> + 'a;\r\n   |                           ------------------------ this return type evaluates to the `'static` lifetime...\r\n...\r\n11 |     move |a| move |b| f(a,b)\r\n   |              ^^^^^^^^^^^^^^^ ...but this borrow...\r\n   |\r\nnote: ...can't outlive the lifetime `'a` as defined on the function body at 8:10\r\n  --> src/main.rs:8:10\r\n   |\r\n8  | fn curry<'a, A: 'a, B, C, F: Fn(A, B) -> C> (f: &'a F)\r\n   |          ^^\r\nhelp: you can add a bound to the return type to make it last less than `'static` and match the lifetime `'a` as defined on the function body at 8:10\r\n   |\r\n9  |     -> Curried<'a, A, B, C, F> + '_\r\n   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\nerror: aborting due to 2 previous errors\r\n```\r\n\r\nIt works without the lifetimes (i.e. after removing parametrization over 'a and replacing all occurrences of 'a with 'static), like this:\r\n```rust\r\n#![feature(unboxed_closures)]\r\n#![feature(type_alias_impl_trait)]\r\ntype Curried<A: 'static, B, C, F: Fn(A, B) -> C>\r\n = impl Fn<(A,), Output = impl FnOnce(B) -> C + 'static> + 'static;\r\n\r\nfn curry<A: 'static, B, C, F: Fn(A, B) -> C> (f: &'static F)\r\n    -> Curried<A, B, C, F>\r\n{\r\n    move |a| move |b| f(a,b)\r\n}\r\n\r\nuse std::ops::Add;\r\nfn main() {\r\n    let x = curry(&i32::add)(1)(2);\r\n    println!(\"{}\", x); // prints \"3\"\r\n}\r\n```\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\nCurrent behavior only since #67844 was fixed (after `nightly-2020-02-14`). Before that, this code triggered an ICE.\r\n", "labels": ["A-closures", "A-lifetimes", "C-bug", "F-type_alias_impl_trait", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-13 16:42:25", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564799004": {"author_username": "steffahn", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69136, "title": "ICE: src\\librustc\\ty\\subst.rs:496: Region parameter out of range when substituting in region 'a", "body": "<!--\r\nThank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\r\na minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\r\nhow to create smaller examples.\r\n\r\nhttp://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\r\n\r\n-->\r\n\r\n### Code\r\n\r\n```rust\r\n#![feature(type_alias_impl_trait)]\r\n\r\ntrait SomeTrait where {}\r\n\r\ntrait WithAssoc<A> where {\r\n\ttype AssocType;\r\n}\r\n\r\ntype Return<A> // 'a is not in scope\r\n = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\r\n\r\nfn my_fun() -> Return<()> {}\r\n\r\nfn main() {}\r\n```\r\n\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\nAppears since `nightly-2020-02-14`. More precisely, the ICE appears since #69008 was merged.\r\nPossibly related to #67844.\r\nNote that the code should not compile.\r\n\r\n### Error output\r\n\r\n```\r\nerror[E0261]: use of undeclared lifetime name `'a`\r\n  --> src/main.rs:11:51\r\n   |\r\n10 | type Return<A> // 'a is not in scope\r\n   |             - help: consider introducing lifetime `'a` here: `'a,`\r\n11 |  = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\r\n   |                                                   ^^ undeclared lifetime\r\n\r\nerror: internal compiler error: src/librustc/ty/subst.rs:496: Region parameter out of range when substituting in region 'a (root type=None) (index=0)\r\n\r\nthread 'rustc' panicked at 'Box<Any>', <::std::macros::panic macros>:2:4\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-dev running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nerror: aborting due to 2 previous errors\r\n\r\nFor more information about this error, try `rustc --explain E0261`.\r\n\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary><strong>Backtrace</strong></summary>\r\n<p>\r\n\r\n```\r\nerror[E0261]: use of undeclared lifetime name `'a`\r\n  --> src/main.rs:11:51\r\n   |\r\n10 | type Return<A> // 'a is not in scope\r\n   |             - help: consider introducing lifetime `'a` here: `'a,`\r\n11 |  = impl WithAssoc<A, AssocType = impl SomeTrait + 'a>;\r\n   |                                                   ^^ undeclared lifetime\r\n\r\nerror: internal compiler error: src/librustc/ty/subst.rs:496: Region parameter out of range when substituting in region 'a (root type=None) (index=0)\r\n\r\nthread 'rustc' panicked at 'Box<Any>', <::std::macros::panic macros>:2:4\r\nstack backtrace:\r\n   0: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n   1: core::fmt::write\r\n   2: std::io::Write::write_fmt\r\n   3: std::sys_common::backtrace::print\r\n   4: std::panicking::default_hook::{{closure}}\r\n   5: std::panicking::default_hook\r\n   6: rustc_driver::report_ice\r\n   7: std::panicking::rust_panic_with_hook\r\n   8: std::panicking::begin_panic\r\n   9: rustc_errors::HandlerInner::span_bug\r\n  10: rustc_errors::Handler::span_bug\r\n  11: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  12: rustc::ty::context::tls::with_opt::{{closure}}\r\n  13: rustc::ty::context::tls::with_opt\r\n  14: rustc::util::bug::opt_span_bug_fmt\r\n  15: rustc::util::bug::span_bug_fmt\r\n  16: <rustc::ty::subst::SubstFolder as rustc::ty::fold::TypeFolder>::fold_region\r\n  17: rustc::ty::fold::TypeFoldable::fold_with\r\n  18: <rustc::ty::subst::SubstFolder as rustc::ty::fold::TypeFolder>::fold_binder\r\n  19: rustc::ty::subst::Subst::subst\r\n  20: <core::iter::adapters::Map<I,F> as core::iter::traits::iterator::Iterator>::fold\r\n  21: <alloc::vec::Vec<T> as alloc::vec::SpecExtend<T,I>>::spec_extend\r\n  22: rustc::ty::GenericPredicates::instantiate_into\r\n  23: rustc::ty::GenericPredicates::instantiate\r\n  24: rustc::infer::opaque_types::Instantiator::fold_opaque_ty\r\n  25: <rustc::ty::fold::BottomUpFolder<F,G,H> as rustc::ty::fold::TypeFolder>::fold_ty\r\n  26: rustc::ty::fold::TypeFoldable::fold_with\r\n  27: rustc::ty::structural_impls::<impl rustc::ty::fold::TypeFoldable for rustc::ty::sty::Binder<T>>::fold_with\r\n  28: rustc::ty::fold::TypeFoldable::fold_with\r\n  29: rustc::infer::opaque_types::Instantiator::instantiate_opaque_types_in_map\r\n  30: rustc::infer::opaque_types::Instantiator::fold_opaque_ty\r\n  31: <rustc::ty::fold::BottomUpFolder<F,G,H> as rustc::ty::fold::TypeFolder>::fold_ty\r\n  32: rustc::infer::opaque_types::Instantiator::instantiate_opaque_types_in_map\r\n  33: rustc::infer::opaque_types::<impl rustc::infer::InferCtxt>::instantiate_opaque_types\r\n  34: rustc_typeck::check::FnCtxt::instantiate_opaque_types_from_value\r\n  35: rustc_typeck::check::check_fn\r\n  36: rustc::ty::context::GlobalCtxt::enter_local\r\n  37: rustc::infer::InferCtxtBuilder::enter\r\n  38: rustc_typeck::check::typeck_tables_of_with_fallback\r\n  39: rustc_typeck::check::typeck_tables_of\r\n  40: rustc::ty::query::__query_compute::typeck_tables_of\r\n  41: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::typeck_tables_of>::compute\r\n  42: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  43: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  44: rustc_typeck::collect::find_opaque_ty_constraints::ConstraintLocator::check\r\n  45: <rustc_typeck::collect::find_opaque_ty_constraints::ConstraintLocator as rustc_hir::intravisit::Visitor>::visit_item\r\n  46: rustc_hir::intravisit::walk_crate\r\n  47: rustc_typeck::collect::find_opaque_ty_constraints\r\n  48: rustc_typeck::collect::type_of\r\n  49: rustc::ty::query::__query_compute::type_of\r\n  50: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::type_of>::compute\r\n  51: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  52: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  53: <rustc_typeck::collect::CollectItemTypesVisitor as rustc_hir::intravisit::Visitor>::visit_item\r\n  54: rustc::hir::map::Map::visit_item_likes_in_module\r\n  55: rustc_typeck::collect::collect_mod_item_types\r\n  56: rustc::ty::query::__query_compute::collect_mod_item_types\r\n  57: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::collect_mod_item_types>::compute\r\n  58: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  59: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  60: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::ensure_query\r\n  61: rustc_session::session::Session::track_errors\r\n  62: rustc_typeck::check_crate\r\n  63: rustc_interface::passes::analysis\r\n  64: rustc::ty::query::__query_compute::analysis\r\n  65: rustc::dep_graph::graph::DepGraph::with_eval_always_task\r\n  66: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  67: rustc::ty::context::tls::enter_global\r\n  68: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  69: scoped_tls::ScopedKey<T>::set\r\n  70: syntax::attr::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-dev running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [typeck_tables_of] processing `my_fun`\r\n#1 [type_of] processing `Return`\r\n#2 [collect_mod_item_types] collecting item types in top-level module\r\n#3 [analysis] running analysis passes on this crate\r\nend of query stack\r\nerror: aborting due to 2 previous errors\r\n\r\nFor more information about this error, try `rustc --explain E0261`.\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n", "labels": ["C-bug", "F-type_alias_impl_trait", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-02-13 16:22:37", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564779078": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69134, "title": "LLVM globals corresponding to miri allocations should be named alloc123.", "body": "That is, if `-Zfewer-names` is `false` (usually only because of `--emit=llvm-ir`), we should use the same name for LLVM globals we generate out of miri allocs as #67133 does in MIR output (`allocN`).\r\n\r\nThis way, we can easily see the mapping between MIR and LLVM IR (and it shouldn't be any costlier for regular compilation, which would continue to use unnamed globals).\r\n\r\nRelevant code (btw this could probably use extra caching keyed on `AllocId`?):\r\nhttps://github.com/rust-lang/rust/blob/be493fe8cc40c3d3f6030a1313c1ff747fce770d/src/librustc_codegen_llvm/common.rs#L260-L267\r\n\r\ncc @rust-lang/wg-mir-opt @bjorn3 \n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\nThis issue has been assigned to @chrissimpkins via [this comment](https://github.com/rust-lang/rust/issues/69134#issuecomment-586080842).\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"chrissimpkins\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "labels": ["A-codegen", "C-enhancement", "E-easy", "T-compiler"], "number_of_comments": 4, "created_at": "2020-02-13 15:54:21", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 1, "hooray": 0}}, "564724305": {"author_username": "matthiaskrgr", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69132, "title": "better warning when passing format string and variable in wrong order to format/println", "body": "I accidentally came up with something like this\r\n````rust\r\nfn main() {\r\n    let greeting = \"hello world\";\r\n\r\n    println!(greeting, \"{}\");\r\n}\r\n````\r\nrustc suggested\r\n````\r\nerror: format argument must be a string literal\r\n --> src/main.rs:4:14\r\n  |\r\n4 |     println!(greeting, \"{}\");\r\n  |              ^^^^^^^^\r\n  |\r\nhelp: you might be missing a string literal to format with\r\n  |\r\n4 |     println!(\"{} {}\", greeting, \"{}\");\r\n  |              ^^^^^^^^\r\n\r\n````\r\n\r\nbut it would be better to suggested swapping the order of `greeting` and `\"{}\"` in the case that the format-string is valid.\r\n\r\n```\r\nhelp: did you intend to swap the variable and format-string?\r\n |\r\n4|   println!(\"{}\", greeting);\r\n | \r\n````", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-13 14:34:32", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564720247": {"author_username": "alex179ohm", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69131, "title": "Weird error message when pub crate is implemented on inner mod", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicate the bug.\r\n-->\r\nWhen an inner mod publicly re-exports function,enum or struct with the `pub(crate)` attribute a non-clear error is showed by cargo check and cargo build. \r\n\r\nconsider a crate lib with the following tree:\r\n```\r\ntst/\r\n    src/\r\n     lib.rs\r\n     tmod/\r\n       mod.rs\r\nCargo.toml\r\n```\r\n\r\nwhere the lib.rs correctly declare the mod `tmod` as following:\r\n```rust\r\n// lib.rs\r\nmod tmod;\r\n```\r\nand the mod.rs content is the following:\r\n```rust\r\n// mod.rs\r\npub use magic::magic;\r\npub use magic::Magic;\r\npub use magic::Emagic;\r\n\r\npub mod magic {\r\n       pub(crate) fn magic() {}\r\n       pub(crate) struct Magic;\r\n       pub(crate) enum EMagic {}\r\n}\r\n```\r\n\r\nI expected to see this happen:\r\nI suppose that the correct behavior should be an error message showing me that the `(crate)` attribute is erroneously located on the inner mod and the `pub use` re-exporting lines of the mod.rs file have to be rewritten as `pub(crate) use ...`.\r\nBut I'm not sure about that, the [rust lang reference](https://doc.rust-lang.org/reference/visibility-and-privacy.html) doesn't cover this case, maybe even a successfully build should be fine.\r\n\r\nInstead, this happened:\r\ncargo check and cargo build both shows this unhelpful error:\r\n```\r\nerror[E0364]: `magic` is private, and cannot be re-exported\r\n --> src/tmod/mod.rs:3:9\r\n  |\r\n3 | pub use magic::magic;\r\n  |         ^^^^^^^^^^^^\r\n  |\r\nnote: consider marking `magic` as `pub` in the imported module\r\n --> src/tmod/mod.rs:3:9\r\n  |\r\n3 | pub use magic::magic;\r\n  |         ^^^^^^^^^^^^\r\n\r\nerror[E0364]: `Magic` is private, and cannot be re-exported\r\n --> src/tmod/mod.rs:4:9\r\n  |\r\n4 | pub use magic::Magic;\r\n  |         ^^^^^^^^^^^^\r\n  |\r\nnote: consider marking `Magic` as `pub` in the imported module\r\n --> src/tmod/mod.rs:4:9\r\n  |\r\n4 | pub use magic::Magic;\r\n  |         ^^^^^^^^^^^^\r\n\r\nerror[E0365]: `EMagic` is private, and cannot be re-exported\r\n --> src/tmod/mod.rs:5:9\r\n  |\r\n5 | pub use magic::EMagic;\r\n  |         ^^^^^^^^^^^^^ re-export of private `EMagic`\r\n  |\r\n  = note: consider declaring type or module `EMagic` with `pub`\r\n```\r\nnote that changing the mod.rs file to publicly re-exports the inner mod items with (crate) attribute as follows:\r\n```rust\r\npub(crate) use magic::magic;\r\n\r\npub mod magic {\r\n       pub fn magic() {}\r\n}\r\n```\r\nor even as follows:\r\n```rust\r\npub(crate) use magic::magic;\r\npub mod magic {\r\n       pub(crate) fn magic() {}\r\n}\r\n```\r\nworks fine and build the crate succefully.\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the bug\r\nalso exists in the beta or nightly versions.\r\n-->\r\nthis happens on both stable and nigtly releases\r\n`rustup show`\r\n```\r\nDefault host: x86_64-unknown-linux-gnu\r\nrustup home:  /home/alex/.rustup\r\n\r\ninstalled toolchains\r\n--------------------\r\n\r\nstable-x86_64-unknown-linux-gnu (default)\r\nnightly-x86_64-unknown-linux-gnu\r\n\r\nactive toolchain\r\n----------------\r\n\r\nstable-x86_64-unknown-linux-gnu (default)\r\nrustc 1.41.0 (5e1a79984 2020-01-27)\r\n```\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.41.0 (5e1a79984 2020-01-27)\r\nbinary: rustc\r\ncommit-hash: 5e1a799842ba6ed4a57e91f7ab9435947482f7d8\r\ncommit-date: 2020-01-27\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.41.0\r\nLLVM version: 9.0\r\n```\r\n", "labels": ["C-bug"], "number_of_comments": 0, "created_at": "2020-02-13 14:28:16", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564671841": {"author_username": "dwrensha", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69130, "title": "internal compiler error: \"byte index 4 is not a char boundary\"", "body": "I'm seeing an internal compiler error on the following input (found by [fuzz-rustc](https://github.com/dwrensha/fuzz-rustc)):\r\n\r\n```rust\r\nenum F {\r\nM (\u00a7& u8)}\r\nfn main() {}\r\n```\r\n\r\n```\r\n$ rustc main.rs\r\nerror: unknown start of token: \\u{a7}\r\n --> main.rs:2:4\r\n  |\r\n2 | M (\u00a7& u8)}\r\n  |    ^\r\n\r\nerror[E0106]: missing lifetime specifier\r\n --> main.rs:2:5\r\n  |\r\n2 | M (\u00a7& u8)}\r\n  |     ^ expected named lifetime parameter\r\n  |\r\nthread 'rustc' panicked at 'byte index 4 is not a char boundary; it is inside '\u00a7' (bytes 3..5) of `M (\u00a7& u8)}`', src/libcore/str/mod.rs:2154:5\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-nightly (a1912f2e8 2020-02-12) running on x86_64-unknown-linux-gnu\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0106`.\r\n```\r\n\r\nThe error happens on `beta` and `nightly` but not on `stable`.", "labels": ["A-resolve", "A-typesystem", "C-bug", "I-ICE", "P-medium", "T-compiler", "glacier", "regression-from-stable-to-beta"], "number_of_comments": 2, "created_at": "2020-02-13 13:09:13", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564542828": {"author_username": "paledega", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69124, "title": "Cannot compiling from source", "body": "![Screenshot_2020-02-13_09-16-19](https://user-images.githubusercontent.com/38860643/74419250-8508ab00-4e41-11ea-9666-cc34f7ca7996.png)\r\n", "labels": [], "number_of_comments": 10, "created_at": "2020-02-13 09:16:34", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564519225": {"author_username": "Sherlock-Holo", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69123, "title": "Unhelpful suggestion for \"cannot infer type\" error", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI tried this code:\r\n\r\n```rust\r\nfn main() {\r\n    let map: HashMap<i32, i32, _> = HashMap::from_iter(vec![(1, 1), (2, 2)].into_iter());\r\n}\r\n```\r\n\r\nI expected to see this happen: \r\n\r\nwhen run `cargo check`, it should says\r\n\r\n```\r\n  --> src/main.rs:30:14\r\n   |\r\n30 |     let map: HashMap<i32, i32, _> = HashMap::from_iter(vec![(1, 1), (2, 2)].into_iter());\r\n   |         ---  ^^^^^^^^^^^^^^^^^^^^ cannot infer type\r\n   |         |\r\n   |         consider change `HashMap<i32, i32, _>` to `HashMap<i32, i32>` because it has a default type, or specify a detail type.\r\n```\r\n\r\nInstead, this happened:\r\n\r\n```\r\n  --> src/main.rs:30:14\r\n   |\r\n30 |     let map: HashMap<i32, i32, _> = HashMap::from_iter(vec![(1, 1), (2, 2)].into_iter());\r\n   |         ---  ^^^^^^^^^^^^^^^^^^^^ cannot infer type\r\n   |         |\r\n   |         consider giving `map` the explicit type `std::collections::HashMap<i32, i32, _>`, with the type parameters specified\r\n```\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nustc 1.43.0-nightly (a1912f2e8 2020-02-12)\r\nbinary: rustc\r\ncommit-hash: a1912f2e89b77cfe2a0e64b96f444848fe4e2d49\r\ncommit-date: 2020-02-12\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```\r\n", "labels": ["A-diagnostics", "A-suggestion-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-13 08:32:00", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564515874": {"author_username": "dtolnay", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69122, "title": "Backtrace Debug tweaks", "body": "- Change Debug representation of disabled and unsupported backtraces to use \\<placeholder\\> style, same as what we do for debug printing locked mutexes and mutably borrowed refcells;\r\n\r\n    ```diff\r\n    - Error { msg: \"...\", backtrace: disabled backtrace }\r\n    + Error { msg: \"...\", backtrace: <disabled> }\r\n    ```\r\n\r\n- Remove quotes around unresolved symbol names;\r\n\r\n    ```diff\r\n    - Backtrace [{ fn: \"<unknown>\" }]\r\n    + Backtrace [{ fn: <unknown> }]\r\n    ```\r\n\r\n- Add quotes around file paths;\r\n\r\n    ```diff\r\n    - Backtrace [{ fn: \"krate::main\", file: /path/to/main.rs, line: 10 }]\r\n    + Backtrace [{ fn: \"krate::main\", file: \"/path/to/main.rs\", line: 10 }]\r\n    ```\r\n\r\n- Add test.", "labels": ["S-waiting-on-author"], "number_of_comments": 6, "created_at": "2020-02-13 08:24:30", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564510383": {"author_username": "LegNeato", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69121, "title": "ICE: Encountered error `Unimplemented` selecting `Binder(...)` during codegen", "body": "We are newly hitting this with [Juniper](https://github.com/graphql-rust/juniper/) across all channels and platforms. While there are other issues with similar errors, they either say it only happens with nightly or requires GATs, neither of which are in use here.\r\n\r\n[mac stable](https://github.com/graphql-rust/juniper/runs/442951562), [linux stable](https://github.com/graphql-rust/juniper/runs/442951547?check_suite_focus=true#step:7:2036)\r\n\r\n```\r\nerror: internal compiler error: src/librustc/traits/codegen/mod.rs:53: Encountered error `Unimplemented` selecting `Binder(<&dyn tests::model::Human as types::async_await::GraphQLTypeAsync<value::scalar::DefaultScalarValue>>)` during codegen\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:905:9\r\n```\r\n\r\n### Code\r\n\r\nhttps://github.com/graphql-rust/juniper/\r\n\r\n(sorry, CI passed previously and juniper is big)\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\n  rustc 1.41.0 (5e1a79984 2020-01-27)\r\n  /usr/share/rust/.cargo/bin/cargo -V\r\n  cargo 1.41.0 (626f0f40e 2019-12-03)\r\n  /usr/share/rust/.cargo/bin/rustup -V\r\n  rustup 1.21.1 (7832b2ebe 2019-12-20)\r\n```\r\n\r\n### Error output\r\n\r\n```\r\nerror: internal compiler error: src/librustc/traits/codegen/mod.rs:53: Encountered error `Unimplemented` selecting `Binder(<&dyn tests::model::Human as types::async_await::GraphQLTypeAsync<value::scalar::DefaultScalarValue>>)` during codegen\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:905:9\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary><strong>Backtrace</strong></summary>\r\n<p>\r\n\r\n```\r\nstack backtrace:\r\n   0:     0x7fa7c46d8334 - backtrace::backtrace::libunwind::trace::heb43798aede8bd30\r\n                               at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1:     0x7fa7c46d8334 - backtrace::backtrace::trace_unsynchronized::had2ba7dec4bd2732\r\n                               at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2:     0x7fa7c46d8334 - std::sys_common::backtrace::_print_fmt::hda61f46e822731b2\r\n                               at src/libstd/sys_common/backtrace.rs:84\r\n   3:     0x7fa7c46d8334 - <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt::hfe37fa5de6572965\r\n                               at src/libstd/sys_common/backtrace.rs:61\r\n   4:     0x7fa7c471082c - core::fmt::write::h74887d18db27282c\r\n                               at src/libcore/fmt/mod.rs:1025\r\n   5:     0x7fa7c46cc767 - std::io::Write::write_fmt::h6808f3d5eceed5e5\r\n                               at src/libstd/io/mod.rs:1426\r\n   6:     0x7fa7c46dc7de - std::sys_common::backtrace::_print::hcc0fd4b3552039ef\r\n                               at src/libstd/sys_common/backtrace.rs:65\r\n   7:     0x7fa7c46dc7de - std::sys_common::backtrace::print::h1c9c5c1c0505592d\r\n                               at src/libstd/sys_common/backtrace.rs:50\r\n   8:     0x7fa7c46dc7de - std::panicking::default_hook::{{closure}}::hefb6085c1ab83a59\r\n                               at src/libstd/panicking.rs:193\r\n   9:     0x7fa7c46dc4d1 - std::panicking::default_hook::h1b037d2bf0657ab3\r\n                               at src/libstd/panicking.rs:210\r\n  10:     0x7fa7c4c63da3 - rustc_driver::report_ice::h291d96c9e2421fed\r\n  11:     0x7fa7b2e97108 - <alloc::boxed::Box<F> as core::ops::function::Fn<A>>::call::h323099d2a73c6add\r\n                               at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/liballoc/boxed.rs:1036\r\n  12:     0x7fa7b2e936d4 - proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}::{{closure}}::ha24ac19a9c49fc3e\r\n                              at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libproc_macro/bridge/client.rs:305\r\n  13:     0x7fa7c46dcf90 - std::panicking::rust_panic_with_hook::h787d7f532b084b9a\r\n                               at src/libstd/panicking.rs:475\r\n  14:     0x7fa7c6e4131d - std::panicking::begin_panic::hbf07588df5a435d8\r\n  15:     0x7fa7c6e741b0 - rustc_errors::HandlerInner::bug::h9106a4a32c6aebca\r\n  16:     0x7fa7c6e72eda - rustc_errors::Handler::bug::ha3adcf0d1e898354\r\n  17:     0x7fa7c698aeb2 - rustc::util::bug::opt_span_bug_fmt::{{closure}}::hf2dbb94e1caf11e0\r\n  18:     0x7fa7c6981a93 - rustc::ty::context::tls::with_opt::{{closure}}::h77e81d332b116391\r\n  19:     0x7fa7c69819e8 - rustc::ty::context::tls::with_opt::h98b7d9ea71ef2628\r\n  20:     0x7fa7c698adc8 - rustc::util::bug::opt_span_bug_fmt::h449b5ab685e489af\r\n  21:     0x7fa7c698ad32 - rustc::util::bug::bug_fmt::hd7a0e92aae8f0503\r\n  22:     0x7fa7c6c60f06 - rustc::ty::context::GlobalCtxt::enter_local::h75320721e8f15611\r\n  23:     0x7fa7c689f71d - rustc::traits::codegen::codegen_fulfill_obligation::h7e56543cac918269\r\n  24:     0x7fa7c69ce000 - rustc::ty::query::__query_compute::codegen_fulfill_obligation::h40ad8b8fc83c3c53\r\n  25:     0x7fa7c6c70e1e - rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::codegen_fulfill_obligation>::compute::hd0c46bddecfba3dd\r\n  26:     0x7fa7c66b224d - rustc::dep_graph::graph::DepGraph::with_task_impl::h30d17681588a80d6\r\n  27:     0x7fa7c6acfc6b - rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query::h0e85b7fd8a2b75a4\r\n  28:     0x7fa7c6a54c4e - rustc::ty::instance::Instance::resolve::h1c6a3aeadebe47bb\r\n  29:     0x7fa7c5a8c2ce - <rustc_mir::monomorphize::collector::RootCollector as rustc::hir::itemlikevisit::ItemLikeVisitor>::visit_item::h9eb541f6b1282f10\r\n  30:     0x7fa7c5bc0249 - rustc::hir::Crate::visit_all_item_likes::hfca9e4baee1d1fb1\r\n  31:     0x7fa7c5a881d1 - rustc_mir::monomorphize::collector::collect_roots::h5f8832dee1a3b1c8\r\n  32:     0x7fa7c5900604 - rustc::util::common::time::h85cf9eca271e2861\r\n  33:     0x7fa7c5a87b85 - rustc_mir::monomorphize::collector::collect_crate_mono_items::h33d17dfee48a53ab\r\n  34:     0x7fa7c5900391 - rustc::util::common::time::h739d5f2bfd0ef463\r\n35:     0x7fa7c5cb8804 - rustc_mir::monomorphize::partitioning::collect_and_partition_mono_items::h88345ea2cc4b4f83\r\n  36:     0x7fa7c4f74565 - rustc::ty::query::__query_compute::collect_and_partition_mono_items::ha86c5a894568cba4\r\n  37:     0x7fa7c4e61541 - rustc::dep_graph::graph::DepGraph::with_task_impl::h78de7a22e46ee7ee\r\n  38:     0x7fa7c4ecf8b8 - rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query::h6a461d7278b0e8aa\r\n  39:     0x7fa7c4f31c24 - rustc_codegen_ssa::base::codegen_crate::ha11b1401122ea73e\r\n  40:     0x7fa7c4f11cee - <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate::h4ca5f427c5f93a31\r\n  41:     0x7fa7c4dcca79 - rustc_interface::passes::start_codegen::{{closure}}::hfe69aed584f648ee\r\n  42:     0x7fa7c4dcbf86 - rustc_interface::passes::start_codegen::hec06952a4f85ed2b\r\n  43:     0x7fa7c4d7aeef - rustc::ty::context::tls::enter_global::h606fda582fe5bd72\r\n  44:     0x7fa7c4d299b3 - rustc_interface::queries::Queries::ongoing_codegen::h811aa1430bd7532f\r\n  45:     0x7fa7c4c2a853 - rustc_interface::interface::run_compiler_in_existing_thread_pool::h748d5742f0ee0ec0\r\n  46:     0x7fa7c4bfa922 - std::thread::local::LocalKey<T>::with::h5202d593397bad8e\r\n  47:     0x7fa7c4bf432e - scoped_tls::ScopedKey<T>::set::hd6209c5e8c3d3105\r\n  48:     0x7fa7c4c70344 - syntax::with_globals::hbceb6aa4bd8a40fb\r\n  49:     0x7fa7c4bf4b10 - std::sys_common::backtrace::__rust_begin_short_backtrace::h8147e020da4fdb28\r\n  50:     0x7fa7c46edb2a - __rust_maybe_catch_panic\r\n                               at src/libpanic_unwind/lib.rs:78\r\n  51:     0x7fa7c4c0b359 - core::ops::function::FnOnce::call_once{{vtable.shim}}::h280c79ac2e107446\r\n  52:     0x7fa7c46be76f - <alloc::boxed::Box<F> as core::ops::function::FnOnce<A>>::call_once::h7bfd6e98bcf6c67e\r\n                               at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/liballoc/boxed.rs:1022\r\n  53:     0x7fa7c46ec550 - <alloc::boxed::Box<F> as core::ops::function::FnOnce<A>>::call_once::h9979661149bbc525\r\n                               at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/liballoc/boxed.rs:1022\r\n  54:     0x7fa7c46ec550 - std::sys_common::thread::start_thread::had0bb4166c065276\r\n                               at src/libstd/sys_common/thread.rs:13\r\n                             at src/libstd/sys_common/thread.rs:13\r\n  55:     0x7fa7c46ec550 - std::sys::unix::thread::Thread::new::thread_start::hbc75223688f972da\r\n                               at src/libstd/sys/unix/thread.rs:80\r\n  56:     0x7fa7c44596db - start_thread\r\n  57:     0x7fa7c3d7688f - __clone\r\n  58:                0x0 - <unknown>\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.41.0 (5e1a79984 2020-01-27) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental -C link-dead-code\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [codegen_fulfill_obligation] checking if `types::async_await::GraphQLTypeAsync` fulfills its obligations\r\n#1 [collect_and_partition_mono_items] collect_and_partition_mono_items\r\nend of query stack\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n", "labels": ["C-bug", "E-needs-mcve", "I-ICE", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-13 08:12:10", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564458280": {"author_username": "spunit262", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69120, "title": "Don't give invalid suggestion on desugared span.", "body": "", "labels": ["S-waiting-on-review"], "number_of_comments": 9, "created_at": "2020-02-13 05:57:09", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564362890": {"author_username": "ronghui1219", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69116, "title": "_modsi3 macros.rs:255 crash on armv7 & armv7s iOS Device", "body": "my library have armv7 & arm64 arch, but some user have crash like this\r\n_modsi3 macros.rs:255\r\nand this crash only occur on armv7 and armv7s Devices, such as iPod5,1 , iPhone 4,1, arm64 is fine\r\nhow can i solve this problem?\r\nrustc 1.39.0 (4560ea788 2019-11-04)", "labels": ["E-needs-mcve"], "number_of_comments": 7, "created_at": "2020-02-13 00:25:15", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564334823": {"author_username": "ilyavenner", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69114, "title": "Static lifetimes checking regression in rustc 1.41.0", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI tried [this code](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=551de68b1179d7eb692e6c286b0979da):\r\n\r\n```rust\r\nstatic FOO: u8 = 42;\r\nstatic mut BAR: &'static u8 = &FOO;\r\n\r\nfn main() {\r\n    unsafe {\r\n        println!(\"{}\", BAR);\r\n        foo();\r\n        println!(\"{}\", BAR);\r\n    }\r\n}\r\n\r\nfn foo() {\r\n    let n = 42;\r\n    unsafe {\r\n        BAR = &n;\r\n    }\r\n}\r\n```\r\n\r\nI expected to see this:\r\n\r\n```\r\nerror[E0597]: `n` does not live long enough\r\n  --> src/main.rs:15:15\r\n   |\r\n15 |         BAR = &n;\r\n   |         ------^^\r\n   |         |     |\r\n   |         |     borrowed value does not live long enough\r\n   |         assignment requires that `n` is borrowed for `'static`\r\n16 |     }\r\n17 | }\r\n   | - `n` dropped here while still borrowed\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0597`.\r\n```\r\n\r\nInstead, happens **undefined behavior**. Program successfully compiles in the Rust `stable 1.41.0` but fails to compile in `stable 1.40.0` (thats what I want).", "labels": ["A-borrow-checker", "A-lifetimes", "C-bug", "I-unsound \ud83d\udca5", "P-high", "T-compiler", "regression-from-stable-to-stable"], "number_of_comments": 4, "created_at": "2020-02-12 23:08:44", "reactions": {"total_count": 7, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564320841": {"author_username": "JustAPerson", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69112, "title": "Conflicting error messages for HRTB in `impl Trait`", "body": "Rust declares the lifetime `'a` is both undeclared and that it is a shadowing declaration\r\n\r\n```rust\r\n#[derive(Debug)]\r\nstruct Ctx<'d> {\r\n    phantom: std::marker::PhantomData<&'d ()>   \r\n}\r\nfn map<'c, 'd: 'c>(ctx: &'c mut Ctx<'d>, data: Vec<()>) -> impl for<'a> Iterator<Item = ()> + 'a where 'c: 'a {\r\n    data.into_iter().inspect(|t| println!(\"{:?}\", ctx))\r\n}\r\n```\r\n\r\nMy more complicated example is trying to use the `&'c mut Ctx<'d>` reference in one of the closures passed to `Iterator::map()` so I need to somehow incorporate the lifetime `'c` into the return type.\r\n\r\nInstead I get this confusing error:\r\n```\r\nerror[E0261]: use of undeclared lifetime name `'a`\r\n --> src/lib.rs:5:95\r\n  |\r\n5 | fn map<'c, 'd: 'c>(ctx: &'c mut Ctx<'d>, data: Vec<()>) -> impl for<'a> Iterator<Item = ()> + 'a where 'c: 'a {\r\n  |                                                                                               ^^ undeclared lifetime\r\n\r\nerror[E0496]: lifetime name `'a` shadows a lifetime name that is already in scope\r\n --> src/lib.rs:5:69\r\n  |\r\n5 | fn map<'c, 'd: 'c>(ctx: &'c mut Ctx<'d>, data: Vec<()>) -> impl for<'a> Iterator<Item = ()> + 'a where 'c: 'a {\r\n  |                                                                     ^^                        -- first declared here\r\n  |                                                                     |\r\n  |                                                                     lifetime 'a already in scope\r\n\r\nerror[E0261]: use of undeclared lifetime name `'a`\r\n --> src/lib.rs:5:108\r\n  |\r\n5 | fn map<'c, 'd: 'c>(ctx: &'c mut Ctx<'d>, data: Vec<()>) -> impl for<'a> Iterator<Item = ()> + 'a where 'c: 'a {\r\n  |                                                                                                            ^^ undeclared lifetime\r\n\r\nerror: aborting due to 3 previous errors\r\n```\r\n\r\nYou'll notice the `help` text of the first error says \"undeclared lifetime\" but the `help` of the second says \"first declared here\" and then gives a bogus \"already in scope\" hint.\r\n", "labels": ["A-diagnostics", "A-impl-trait", "A-lifetimes", "C-bug", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-12 22:37:55", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564294022": {"author_username": "rodrimati1992", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69111, "title": "Implementing `Index<LocalType>` for arrays causes usize indexing to fail.", "body": "I tried this code:\r\n[link to playground](https://play.rust-lang.org/?version=stable&mode=release&edition=2018&gist=2e8cacc7a57123869d77f2c7cb68ee6c)\r\n```rust\r\n\r\nstruct One;\r\n\r\nimpl<T> Index<One> for [T;10] {\r\n    type Output=T;\r\n    fn index(&self,_:One)->&T{\r\n        let this:&[T]=self;\r\n        &this[1]\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let array=[0,1,2,3,4,5,6,7,8,9];\r\n    array[1];\r\n}\r\n```\r\n\r\nI expected the code to compile without errors.\r\n\r\nInstead I got this compiler error:\r\n```\r\nerror[E0308]: mismatched types\r\n  --> src/main.rs:15:11\r\n   |\r\n15 |     array[1];\r\n   |           ^ expected struct `One`, found integer\r\n```\r\n\r\nIt produces the same error for stable beta and nightly.\r\n\r\nThe `impl<T> Index<One> for [T;10]` impl started being allowed on Rust 1.41,while on Rust 1.40 it prints the expected orphan impl error:\r\n```\r\nerror[E0210]: type parameter `T` must be used as the type parameter for some local type (e.g., `MyStruct<T>`)\r\n\r\n --> <source>:5:6\r\n\r\n  |\r\n\r\n5 | impl<T> Index<One> for [T;10] {\r\n\r\n  |      ^ type parameter `T` must be used as the type parameter for some local type\r\n\r\n  |\r\n\r\n  = note: only traits defined in the current crate can be implemented for a type parameter\r\n```", "labels": ["C-bug", "T-libs"], "number_of_comments": 2, "created_at": "2020-02-12 21:45:36", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564277226": {"author_username": "Amanieu", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69110, "title": "format! allows named arguments to be referenced by position", "body": "The following example compiles, but shouldn't.\r\n```rust\r\nprintln!(\"{0} {foo}\", foo = 2);\r\n```\r\n\r\nThis seems to be an unintentional regression that was introduced somewhere between 1.11.0 and 1.12.0, most likely by #33642.\r\n\r\nHowever, this code has been accepted on stable for multiple years now (1.12 was in 2016), so fixing this might break existing code. We could still change this back to an error if crater reports no regressions since it is reasonable to say that the code in question is clearly incorrect and was not caught by the compiler by mistake.", "labels": ["C-bug", "T-libs"], "number_of_comments": 2, "created_at": "2020-02-12 21:16:41", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564249794": {"author_username": "estebank", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69107, "title": "Detect when if/else is tail expression has mismatched types that could be a boxed trait", "body": "Given the following\r\n```rust\r\nstruct S;\r\nstruct Y;\r\n\r\ntrait Trait {}\r\n\r\nimpl Trait for S {}\r\nimpl Trait for Y {}\r\n\r\nfn baz() -> impl Trait {\r\n    if true {\r\n        S\r\n    } else {\r\n        Y\r\n    }\r\n}\r\n```\r\n[we currently emit](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=33b39a8ed7e34ca644fca8a23c5aa146)\r\n```\r\nerror[E0308]: `if` and `else` have incompatible types\r\n  --> src/main.rs:13:9\r\n   |\r\n10 | /     if true {\r\n11 | |         S\r\n   | |         - expected because of this\r\n12 | |     } else {\r\n13 | |         Y\r\n   | |         ^ expected struct `S`, found struct `Y`\r\n14 | |     }\r\n   | |_____- `if` and `else` have incompatible types\r\n```\r\n\r\n[We should suggest changing](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=493cbd88403ec9abebf2c18dc3b7486a) the return type from `impl Trait` to `Box<dyn Trait>` and boxing the two branches. I think this is the last missing suggestion we can give involding `impl Trait` and `dyn Trait` returns.\r\n\r\nFollow up to https://github.com/rust-lang/rust/issues/68110.", "labels": ["A-diagnostics", "A-suggestion-diagnostics", "C-enhancement", "D-papercut", "P-low", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-12 20:26:03", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564181242": {"author_username": "Matthias247", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69101, "title": "Bounds check optimizations are not applied if the accessed slice len is smaller than the upfront checked slice len", "body": "When using a loop and checking exact bounds upfront, vectorized instructions are used:\r\n\r\n```rust\r\npub fn xorl(a: &[u8], b: &[u8], c: &mut [u8]) {\r\n    let (a_bound, b_bound, c_bound) = (&a[..1024], &b[..1024], &mut c[..1024]);\r\n    for i in 0..1024 {\r\n        c[i] = a[i] ^ b[i];\r\n    }\r\n}\r\n```\r\n[Godbolt](https://godbolt.org/z/MVajmQ)\r\n\r\nHowever when the upfront checks actually tests for a bigger slice size, the same optimizations are not applied:\r\n\r\n```rust\r\npub fn xorl(a: &[u8], b: &[u8], c: &mut [u8]) {\r\n    let (a_bound, b_bound, c_bound) = (&a[..2048], &b[..2048], &mut c[..2048]);\r\n    for i in 0..1024 {\r\n        c[i] = a[i] ^ b[i];\r\n    }\r\n}\r\n```\r\n[Godbolt](https://godbolt.org/z/CkwKK4)\r\n\r\nSince slices of size 2048 are always also at least of size 1024, I would expect the generated code to be equivalent.\r\n\r\n### Meta\r\n\r\n`rustc --version --verbose`:\r\n\r\nHappens on nightly as well as 1.40 - as seen in Godbolt\r\n", "labels": ["A-LLVM", "C-bug", "I-slow", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-12 18:20:29", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564091110": {"author_username": "HeroicKatora", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69099, "title": "Tracking Issue for `std::cell::{Ref, RefMut}::leak`", "body": "#68712 adds methods to convert `RefCell` guards `Ref`/`RefMut` into references with the lifetime of the underlying cell.\r\n\r\nThe feature gate for the issue is `#![feature(cell_leak)]`.\r\n\r\n### Unresolved Questions\r\n\r\n- [ ] Should similar methods be provided for `MutexGuard` and  `RwLockReadGuard`/`RwLockWriteGuard`?\r\n- [ ] Should `unsafe` methods be added to forcefully revert a leak?\r\n\r\n", "labels": ["B-unstable", "C-tracking-issue", "T-libs"], "number_of_comments": 0, "created_at": "2020-02-12 15:50:11", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564080826": {"author_username": "nikomatsakis", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69098, "title": "Tracking issue for target_feature 1.1 RFC", "body": "This is a tracking issue for the RFC \"target_feature 1.1\" (rust-lang/rfcs#2396).\r\n\r\n## People\r\n\r\n*Last updated in Feb 2020:*\r\n\r\n* Shepherd: @gnzlbg (person who can help answer tricky questions that arise during implementation)\r\n* Lang team liaison: @joshtriplett (main point of contact from lang team)\r\n\r\n## Step\r\n\r\n- [ ] Implement the RFC\r\n- [ ] Adjust documentation ([see instructions on rustc-guide][doc-guide])\r\n- [ ] Stabilization PR ([see instructions on rustc-guide][stabilization-guide])\r\n\r\n[stabilization-guide]: https://rust-lang.github.io/rustc-guide/stabilization_guide.html#stabilization-pr\r\n[doc-guide]: https://rust-lang.github.io/rustc-guide/stabilization_guide.html#documentation-prs\r\n\r\n## Unresolved questions\r\n\r\nNone presently.\r\n\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\nThis issue has been assigned to @LeSeulArtichaut via [this comment](https://github.com/rust-lang/rust/issues/69098#issuecomment-587674426).\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"LeSeulArtichaut\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "labels": ["B-RFC-approved", "C-tracking-issue", "T-lang"], "number_of_comments": 1, "created_at": "2020-02-12 15:34:23", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "564027788": {"author_username": "lszxb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69096, "title": "Rustc overflow its stack when using impl Trait and the struct containing the function itself", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI tried this code:\r\n\r\n```rust\r\nfn main() {\r\n    test();\r\n}\r\n\r\nfn test() -> impl P {\r\n    Lazy { f: test }\r\n}\r\n\r\ntrait P {}\r\n\r\nstruct Lazy<F> {\r\n    f: F\r\n}\r\n\r\nimpl<F> P for Lazy<F> {}\r\n```\r\nThen I got `thread 'rustc' has overflowed its stack`.\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.43.0-nightly (07a34df18 2020-02-08)\r\nbinary: rustc\r\ncommit-hash: 07a34df18b437319a7ff510077bbab95cf7ec6bc\r\ncommit-date: 2020-02-08\r\nhost: x86_64-pc-windows-gnu\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->", "labels": ["A-codegen", "A-impl-trait", "C-bug", "I-crash", "ICEBreaker-Cleanup-Crew", "P-high", "T-compiler"], "number_of_comments": 14, "created_at": "2020-02-12 14:14:05", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563971176": {"author_username": "andrewreds", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69092, "title": "Rustc crashes with nul byte inside inline assembly", "body": "### Code\r\n\r\n#### Fails\r\n```rust\r\n#![feature(asm)]\r\n\r\nfn main() {\r\n    unsafe { asm!(\".ascii \\\"Xen\\0\\\"\"); }\r\n}\r\n```\r\n\r\n#### Works\r\n```rust\r\n#![feature(asm)]\r\n\r\nfn main() {\r\n    unsafe { asm!(\".ascii \\\"Xen\\\\0\\\"\"); }\r\n}\r\n```\r\n\r\n```rust\r\n#![feature(asm)]\r\n\r\nfn main() {\r\n    unsafe { asm!(\".asciz \\\"Xen\\\"\"); }\r\n}\r\n```\r\n\r\n### Meta\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.43.0-nightly (fc23a8183 2020-02-11)\r\nbinary: rustc\r\ncommit-hash: fc23a81831d5b41510d3261c20c34dd8d32f0f31\r\ncommit-date: 2020-02-11\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\n### Error output\r\n\r\n```\r\nthread 'rustc' panicked at 'called `Result::unwrap()` on an `Err` value: NulError(11, [46, 97, 115, 99, 105, 105, 32, 34, 88, 101, 110, 0, 34])', src/librustc_codegen_llvm/asm.rs:77:19\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-nightly (fc23a8183 2020-02-11) running on x86_64-unknown-linux-gnu\r\n\r\n```\r\n\r\n<details><summary><strong>Backtrace</strong></summary>\r\n<p>\r\n\r\n```\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1428\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:474\r\n  12: rust_begin_unwind\r\n             at src/libstd/panicking.rs:378\r\n  13: core::panicking::panic_fmt\r\n             at src/libcore/panicking.rs:85\r\n  14: core::option::expect_none_failed\r\n             at src/libcore/option.rs:1211\r\n  15: rustc_codegen_llvm::asm::<impl rustc_codegen_ssa::traits::asm::AsmBuilderMethods for rustc_codegen_llvm::builder::Builder>::codegen_inline_asm\r\n  16: rustc_codegen_ssa::mir::block::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_block\r\n  17: rustc_codegen_ssa::mir::codegen_mir\r\n  18: <rustc::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt>::define\r\n  19: rustc_codegen_llvm::base::compile_codegen_unit::module_codegen\r\n  20: rustc::dep_graph::graph::DepGraph::with_task\r\n  21: rustc_codegen_llvm::base::compile_codegen_unit\r\n  22: rustc_codegen_ssa::base::codegen_crate\r\n  23: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  24: rustc_interface::passes::QueryContext::enter\r\n  25: rustc_interface::queries::Queries::ongoing_codegen\r\n  26: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  27: scoped_tls::ScopedKey<T>::set\r\n  28: syntax::attr::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n```\r\n\r\n</p>\r\n</details>\r\n\r\n\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\nThis issue has been assigned to @euclio via [this comment](https://github.com/rust-lang/rust/issues/69092#issuecomment-585277602).\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"euclio\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "labels": ["A-inline-assembly", "C-bug", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 1, "created_at": "2020-02-12 12:35:14", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563698490": {"author_username": "yaahc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69084, "title": "Split non macro portion of unused_doc_comment from macro part into two passes/lints", "body": "## Motivation\r\n\r\nThis change is motivated by the needs of the [spandoc library](https://github.com/yaahc/spandoc). The specific use case is that my macro is removing doc comments when an attribute is applied to a fn with doc comments, but I would like the lint to still appear when I forget to add the `#[spandoc]` attribute to a fn, so I don't want to have to silence the lint globally.\r\n\r\n## Approach\r\n\r\nThis change splits the `unused _doc_comment` lint into two lints, `unused_macro_doc_comment` and `unused_doc_comment`. The non macro portion is moved into an `early_lint_pass` rather than a pre_expansion_pass. This allows proc macros to silence `unused_doc_comment` warnings by either adding an attribute to silence it or by removing the doc comment before the early_pass runs.\r\n\r\nThe `unused_macro_doc_comment` lint however will still be impossible for proc-macros to silence, but the only alternative that I can see is to remove this lint entirely, which I don't think is acceptable / is a decision I'm not comfortable making personally, so instead I opted to split the macro portion of the check into a separate lint so that it can be silenced globally with an attribute if necessary without needing to globally silence the `unused_doc_comment` lint as well, which is still desireable.\r\n\r\nfixes https://github.com/rust-lang/rust/issues/67838", "labels": ["S-waiting-on-author"], "number_of_comments": 27, "created_at": "2020-02-12 02:35:10", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563676022": {"author_username": "estebank", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69083, "title": "Detect cases where `Box::pin` was likely intended", "body": "When `BoxFuture` is expected and we supply `Pin::new(async { /* .. */ })`, `Box::new(async { /* .. */ })` or `Pin::new(Box::new(async { /* .. */ }))` we should lead the user in the right direction instead of what we do now:\r\n\r\n```\r\nerror[E0277]: the trait bound `dyn std::future::Future<Output = i32> + std::marker::Send: std::marker::Unpin` is not satisfied\r\n  --> file5.rs:10:5\r\n   |\r\n10 |     Pin::new(async { 42 })\r\n   |     ^^^^^^^^ the trait `std::marker::Unpin` is not implemented for `dyn std::future::Future<Output = i32> + std::marker::Send`\r\n   |\r\n   = note: required by `std::pin::Pin::<P>::new`\r\n```\r\n```\r\nerror[E0308]: mismatched types\r\n  --> file5.rs:10:5\r\n   |\r\n9  | fn foo() -> BoxFuture<'static, i32> {\r\n   |             ----------------------- expected `std::pin::Pin<std::boxed::Box<(dyn std::future::Future<Output = i32> + std::marker::Send + 'static)>>` because of return type\r\n10 |     Box::new(async { 42 })\r\n   |     ^^^^^^^^^^^^^^^^^^^^^^\r\n   |     |\r\n   |     expected struct `std::pin::Pin`, found struct `std::boxed::Box`\r\n   |     help: you need to pin and box this expression: `Box::pin(Box::new(async { 42 }))`\r\n   |\r\n   = note: expected struct `std::pin::Pin<std::boxed::Box<(dyn std::future::Future<Output = i32> + std::marker::Send + 'static)>>`\r\n              found struct `std::boxed::Box<impl std::future::Future>`\r\n```\r\n```\r\nerror[E0277]: the trait bound `dyn std::future::Future<Output = i32> + std::marker::Send: std::marker::Unpin` is not satisfied\r\n  --> file5.rs:10:5\r\n   |\r\n10 |     Pin::new(Box::new(async { 42 }))\r\n   |     ^^^^^^^^ the trait `std::marker::Unpin` is not implemented for `dyn std::future::Future<Output = i32> + std::marker::Send`\r\n   |\r\n   = note: required by `std::pin::Pin::<P>::new`\r\n```\r\n\r\nFor the second case we could suggest `Box::into_pin` once https://github.com/rust-lang/rust/issues/62370 stabilizes. The other two cases can be handled with a `rustc_on_unimplemented` note.", "labels": ["A-async-await", "A-diagnostics", "A-suggestion-diagnostics", "AsyncAwait-Triaged", "C-enhancement", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-12 01:28:37", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563652640": {"author_username": "tmandry", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69081, "title": "Support static linking LLVM with ThinLTO", "body": "As [discussed here](https://github.com/rust-lang/rust/pull/57286#issuecomment-559197822), we'd like to support static linking LLVM with ThinLTO, even if that isn't what happens on our CI bots. This changes the `llvm.link-shared` config flag to default to `true` if `llvm.thinlto` is enabled, but allows the user to override that default instead of forcing shared linking.\r\n\r\nr? @Mark-Simulacrum \r\ncc @alexcrichton @petrhosek ", "labels": ["S-waiting-on-bors", "relnotes"], "number_of_comments": 8, "created_at": "2020-02-12 00:46:39", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563651586": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69080, "title": "rustc_codegen_llvm: don't generate any type debuginfo for -Cdebuginfo=1.", "body": "Fixes #69074 by adding more checks for `DebugInfo::Full` in a few places in `rustc_codegen_llvm`, bringing us in line with what `clang -g1` generates (no debuginfo types, nor debuginfo for `static`s).\r\n\r\n**TODO**: finish the last commit (i.e. ensure the compiler never emits type debuginfo at `-Cdebuginfo=1`, but instead ICEs).\r\n\r\n<hr/>\r\n\r\nMy local build's (`debuginfo-level=1`, `debug-assertions=1`) `librustc_driver-*.so` went from just over 1GiB (1019MiB) down to 402MiB.\r\n\r\nIt's still bad, but the `.debug_*` sections themselves (as reported by `objdump`) went from something like 853MiB down to 236MiB, i.e. roughly a 3.6x reduction.\r\n\r\n<hr/>\r\n\r\nSadly, I don't think this is enough to justify *shipping* all of this debuginfo, but now it's more plausible that we could at least *build* with `debuginfo-level=1` *then* strip it.\r\nThat would give us real backtraces for e.g. ICEs during builds, but I don't know how often that's relevant.\r\n\r\nThere's also the possibility of making it slimmer by omitting parameters to functions, or perhaps some deduplication (I think right now there is no DWARF reuse across CGUs? maybe ThinLTO helps?).\r\n\r\nr? @michaelwoerister cc @rust-lang/wg-codegen @alexcrichton @Mark-Simulacrum ", "labels": ["S-waiting-on-review"], "number_of_comments": 2, "created_at": "2020-02-12 00:44:39", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563614973": {"author_username": "CAD97", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69079, "title": "Allow calculating the layout behind a pointer", "body": "There was some discussion around allowing this previously.\r\n\r\nThis does make the requirement for raw pointers to have valid metadata exposed as part of the std API (as a safety invariant, not validity invariant), though I think this is not strictly necessarily required as of current. cc @rust-lang/wg-unsafe-code-guidelines \r\n\r\nNaming is hard; I picked the best \"obvious\" name I could come up with.\r\n\r\nIf it's agreed that this is actually a desired API surface, I'll file a tracking issue and update the attributes.", "labels": ["S-waiting-on-review", "T-lang", "T-libs", "needs-fcp"], "number_of_comments": 9, "created_at": "2020-02-11 23:44:02", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 1}}, "563577515": {"author_username": "petrochenkov", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69078, "title": "LLVM: rustllvm produces unsilenceable warnings on new versions of GCC (9.2.0)", "body": "... which are pretty annoying.\r\nIt probably wouldn't be a problem if Cargo didn't cache the warnings and didn't display them on every build, even if `rustllvm` isn't actually built.\r\n\r\nExample of the warnings:\r\n```\r\nwarning: In file included from ../rustllvm/rustllvm.h:4,\r\nwarning:                  from ../rustllvm/PassWrapper.cpp:6:\r\nwarning: C:/msys64/home/we/rust/src/llvm-project/llvm/include/llvm/ADT/ArrayRef.h: In instantiation of 'llvm::ArrayRef<T>::ArrayRef(const std::initializer_list<_Tp>&) [with T = long long unsigned int]':\r\nwarning: C:/msys64/home/we/rust/src/llvm-project/llvm/include/llvm/IR/DIBuilder.h:644:74:   required from here\r\nwarning: C:/msys64/home/we/rust/src/llvm-project/llvm/include/llvm/ADT/ArrayRef.h:101:37: warning: initializing 'llvm::ArrayRef<long long unsigned int>::Data' from 'std::initializer_list<long long unsigned int>::begin' does not extend the lifetime of the underlying array [-Winit-list-lifetime]\r\nwarning:   101 |     : Data(Vec.begin() == Vec.end() ? (T*)nullptr : Vec.begin()),\r\n```\r\n\r\nThis is fixed in LLVM upstream (https://github.com/llvm/llvm-project/commit/6c2151bf4c829958891e65a4cc396daa6d308eb0), so that commit can be cherry-picked into our LLVM fork.\r\n\r\nThe commit seems to be included into LLVM 10, but I'm not sure when https://github.com/rust-lang/rust/pull/67759 will be able to land.", "labels": ["A-LLVM", "E-easy"], "number_of_comments": 1, "created_at": "2020-02-11 23:05:33", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563537672": {"author_username": "cjgillot", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69076, "title": "Split librustc::{traits,infer} to their respective crates", "body": "Followup on #67953.\r\n\r\nI tried to follow the existing module structures.\r\n\r\ncc @eddyb  \r\nr? @Zoxc", "labels": ["S-waiting-on-author"], "number_of_comments": 5, "created_at": "2020-02-11 22:29:28", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563458915": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69074, "title": "-Cdebuginfo=1 wastefully produces full type descriptions.", "body": "This example makes `-Cdebuginfo=1` emit the variant (see [`godbolt` output](https://godbolt.org/z/4YCBzk)):\r\n```rust\r\npub enum Foo {\r\n    ThisShouldNotBeInDebugInfo([u8; 1337])\r\n}\r\n\r\nimpl Foo {\r\n    pub fn foo() {}\r\n}\r\n```\r\nIts resulting LLVM IR shows all of these DebugInfo metadata nodes:\r\n```llvm\r\n!6 = !DICompositeType(tag: DW_TAG_structure_type, name: \"Foo\", scope: !8, file: !7, size: 10696, align: 8, elements: !{!10}, identifier: \"65d4d9f1044eb0325dc66254af8523df\")\r\n!10 = !DICompositeType(tag: DW_TAG_variant_part, scope: !8, file: !7, size: 10696, align: 8, elements: !{!12}, templateParams: !4, identifier: \"65d4d9f1044eb0325dc66254af8523df_variant_part\")\r\n!12 = !DIDerivedType(tag: DW_TAG_member, name: \"ThisShouldNotBeInDebugInfo\", scope: !10, file: !7, baseType: !13, size: 10696, align: 8)\r\n!13 = !DICompositeType(tag: DW_TAG_structure_type, name: \"ThisShouldNotBeInDebugInfo\", scope: !6, file: !7, size: 10696, align: 8, elements: !{!15}, templateParams: !4, identifier: \"65d4d9f1044eb0325dc66254af8523df::ThisShouldNotBeInDebugInfo\")\r\n!15 = !DIDerivedType(tag: DW_TAG_member, name: \"__0\", scope: !13, file: !7, baseType: !16, size: 10696, align: 8)\r\n!16 = !DICompositeType(tag: DW_TAG_array_type, baseType: !17, size: 10696, align: 8, elements: !{!19})\r\n!17 = !DIBasicType(name: \"u8\", size: 8, encoding: DW_ATE_unsigned)\r\n!19 = !DISubrange(count: 1337)\r\n```\r\n\r\nBut at `-Cdebuginfo=1`, this is really what we want to see:\r\n```rust\r\n!6 = !DICompositeType(tag: DW_TAG_structure_type, name: \"Foo\", scope: !8, file: !7)\r\n```\r\n\r\nIf this doesn't work we can always just use `DINamespace` instead.\r\n\r\n<hr/>\r\n\r\nIIUC, this specific example is caused from the way we handle inherent `impl`s, but there might be others, so we probably want to make the debuginfo generating infrastructure ICE when it's trying to generate non-trivial type debuginfo but `-Cdebuginfo=1` is set.\r\n\r\nOh, and, I found this because `librustc_driver-*.so` is 1GB with `debuginfo-level=1` (and `debug-assertions=1`) in `config.toml`, and most of that is type debuginfo.\r\n\r\ncc @rust-lang/compiler @alexcrichton", "labels": ["A-debuginfo", "C-bug", "I-compiletime", "T-compiler"], "number_of_comments": 7, "created_at": "2020-02-11 20:30:42", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563439971": {"author_username": "sethwm", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69073, "title": "Clarify \"cannot find macro `X` in this scope\"", "body": "I always forget that program order matters for macro definitions.  In the [example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0e2900e51a17037b753c2c451e12146b), I get the error:\r\n\r\n```\r\nerror: cannot find macro `five_times` in this scope\r\n```\r\n\r\nAnd inevitably I spend a long time trying to debug it when I eventually remember that for `macro_use`, program order matters.  If the compiler error message provided a hint like \"macro `five_times` exists but is defined after the code attempting to use it.  try reordering the use statements\" (or choose better phrasing), that'd save a lot of time.  ", "labels": ["A-diagnostics", "A-macros", "A-resolve", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-11 19:55:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563430394": {"author_username": "ecstatic-morse", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69072, "title": "O(log n) lookup of associated items by name", "body": "Resolves #68957, in which compile time is quadratic in the number of associated items. This PR makes name lookup use binary search instead of a linear scan to improve its asymptotic performance. As a result, the pathological case from that issue now runs in 8 seconds on my local machine, as opposed to many minutes on the current stable.\r\n\r\nCurrently, method resolution must do a linear scan through all associated items of a type to find one with a certain name. This PR changes the result of the `associated_items` query to a data structure that preserves the definition order of associated items (which is used, e.g., for the layout of trait object vtables) while adding an index of those items sorted by (unhygienic) name. When doing name lookup, we first find all items with the same `Symbol` using binary search, then run hygienic comparison to find the one we are looking for. Ideally, this would be implemented using an insertion-order preserving, hash-based multi-map, but one is not readily available.\r\n\r\nSomeone who is more familiar with identifier hygiene could probably make this better by auditing the uses of the `AssociatedItems` interface. My goal was to preserve the current behavior exactly, even if it seemed strange (I left at least one FIXME to this effect). For example, some places use comparison with `ident.modern()` and some places use `tcx.hygienic_eq` which requires the `DefId` of the containing `impl`. I don't know whether those approaches are equivalent or which one should be preferred.", "labels": ["S-waiting-on-bors"], "number_of_comments": 41, "created_at": "2020-02-11 19:37:41", "reactions": {"total_count": 7, "+1": 6, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563397168": {"author_username": "nikomatsakis", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69069, "title": "arbitrary self types causes unexpected error messages", "body": "This example:\r\n\r\n```rust\r\n#![feature(arbitrary_self_types)]\r\ntrait Test<T: core::ops::Deref<Target = Self>> {\r\n    fn is_some(self: T);\r\n}\r\n\r\nfn f() {\r\n    let x = Some(2);\r\n    if x.is_some() {\r\n        println!(\"Some\");\r\n    }\r\n}\r\n```\r\n[Playground link](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=83f8fd48766d3bcd61212a70b6db86df)\r\n\r\ngives the error \r\n\r\n```\r\nerror[E0277]: the trait bound `std::option::Option<{integer}>: std::ops::Deref` is not satisfied\r\n --> src/lib.rs:8:10\r\n  |\r\n8 |     if x.is_some() {\r\n  |          ^^^^^^^ the trait `std::ops::Deref` is not implemented for `std::option::Option<{integer}>`\r\n\r\nerror[E0308]: mismatched types\r\n --> src/lib.rs:8:8\r\n  |\r\n8 |     if x.is_some() {\r\n  |        ^^^^^^^^^^^ expected `bool`, found `()`\r\n\r\nerror: aborting due to 2 previous errors\r\n\r\n```\r\n\r\nrather than an error because the `Test` trait is not implemented.\r\n\r\nThis is presumably just a case where improved diagnostics would be good. The [inherent `is_some` method](https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some) winds up not triggering because it requires auto-ref rather than being passed \"by value\".\r\n\r\n_Originally posted by @tguser402 in https://github.com/rust-lang/rust/issues/66312#issuecomment-568805751_", "labels": ["A-diagnostics", "C-enhancement", "D-confusing", "D-papercut", "F-arbitrary_self_types", "T-compiler"], "number_of_comments": 2, "created_at": "2020-02-11 18:33:55", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563375372": {"author_username": "DustinByfuglien", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69067, "title": "Confusing E0495 error explanation", "body": "Consider example.\r\nThe error explanation is very confusing for me:\r\n1. Its not obvious what is the problem and what I can do for solving it\r\n2. There are confusing why Rust explains that '&&Foo' is both expected and found:\r\n~~~\r\n   = note: expected  `&&Foo`\r\n              found  `&&Foo`\r\n~~~\r\n\r\n```rust\r\n#![feature(trait_alias)]\r\n#![feature(generator_trait)]\r\n#![feature(generators)]\r\n\r\nuse std::ops::Generator;\r\n\r\ntrait MyGenerator = Generator<Yield = (), Return = ()>;\r\ntrait Bar {\r\n    fn bar(&self) -> Box<dyn MyGenerator>;\r\n}\r\n\r\nstruct Foo;\r\n\r\nimpl Bar for Foo {\r\n    fn bar(&self) -> Box<dyn MyGenerator> {\r\n        Box::new(|| {\r\n            let _x = self;\r\n            yield;\r\n        })\r\n    }\r\n}\r\n\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=32ff6f1912ba199046ac323a7613fbc1))\r\n\r\nErrors:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nerror[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\r\n  --> src/lib.rs:16:18\r\n   |\r\n16 |           Box::new(|| {\r\n   |  __________________^\r\n17 | |             let _x = self;\r\n18 | |             yield;\r\n19 | |         })\r\n   | |_________^\r\n   |\r\nnote: first, the lifetime cannot outlive the anonymous lifetime #1 defined on the method body at 15:5...\r\n  --> src/lib.rs:15:5\r\n   |\r\n15 | /     fn bar(&self) -> Box<dyn MyGenerator> {\r\n16 | |         Box::new(|| {\r\n17 | |             let _x = self;\r\n18 | |             yield;\r\n19 | |         })\r\n20 | |     }\r\n   | |_____^\r\nnote: ...so that the types are compatible\r\n  --> src/lib.rs:16:18\r\n   |\r\n16 |           Box::new(|| {\r\n   |  __________________^\r\n17 | |             let _x = self;\r\n18 | |             yield;\r\n19 | |         })\r\n   | |_________^\r\n   = note: expected  `&&Foo`\r\n              found  `&&Foo`\r\n   = note: but, the lifetime must be valid for the static lifetime...\r\nnote: ...so that the expression is assignable\r\n  --> src/lib.rs:16:9\r\n   |\r\n16 | /         Box::new(|| {\r\n17 | |             let _x = self;\r\n18 | |             yield;\r\n19 | |         })\r\n   | |__________^\r\n   = note: expected  `std::boxed::Box<(dyn std::ops::Generator<Yield = (), Return = ()> + 'static)>`\r\n              found  `std::boxed::Box<dyn std::ops::Generator<Yield = (), Return = ()>>`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0495`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```", "labels": ["A-diagnostics", "A-lifetimes", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-11 17:51:03", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563364295": {"author_username": "TimDiekmann", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69065, "title": "Separate `dealloc` from `AllocRef` into `DeallocRef`", "body": "This creates a new trait `DeallocRef`, makes it a supertrait of `AllocRef` and moves `dealloc` into the new trait.\r\n\r\nWith this way, it is possible to have allocators, which cannot allocate new memory, but free old one. This comes in handy when dealing with FFI interfaces, which returns a pointer and a `free` function.\r\n\r\nFor a full discussion on this topic please see https://github.com/rust-lang/wg-allocators/issues/9\r\n\r\nr? @Amanieu \r\n\r\ncloses rust-lang/wg-allocators#9", "labels": ["S-waiting-on-review"], "number_of_comments": 3, "created_at": "2020-02-11 17:30:52", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563360856": {"author_username": "manuthambi", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69064, "title": "Lifetime elision doesn't work right with nested self receivers. ", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\nSeems like lifetime elision doesn't work quite right with nested self receivers. The error messages are also misleading. Of course this can be worked around by providing the annotation in the code\r\n\r\n\r\n```rust\r\nuse std::rc::Rc;\r\n\r\nstruct S {\r\n    val: String,\r\n}\r\n\r\nimpl S {\r\n    // error[E0623]: lifetime mismatch\r\n    //  --> src/lib.rs:9:9\r\n    //   |\r\n    // 8 |     fn rc1(self: &Rc<Self>, _s: &str) -> &str {\r\n    //   |                  ---------               ----\r\n    //   |                  |\r\n    //   |                  this parameter and the return type are declared with different lifetimes...\r\n    // 9 |         self.val.as_ref()\r\n    //   |         ^^^^^^^^^^^^^^^^^ ...but data from `self` is returned here\r\n    fn rc1(self: &Rc<Self>, _s: &str) -> &str {\r\n        self.val.as_ref()\r\n    }\r\n\r\n    //     error[E0106]: missing lifetime specifier\r\n    //   --> src/lib.rs:11:32\r\n    //    |\r\n    // 11 |     fn rc2(self: &Rc<Self>) -> &str {\r\n    //    |                                ^ help: consider giving it a 'static lifetime: `&'static`\r\n    //    |\r\n    //    = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from\r\n    fn rc2(self: &Rc<Self>) -> &str {\r\n        self.val.as_ref()\r\n    }\r\n\r\n\r\n    // Compiles fine\r\n    fn ref1(&self, _s: &str) -> &str {\r\n        self.val.as_ref()\r\n    }\r\n\r\n    // Compiles fine\r\n    fn ref2(&self) -> &str {\r\n        self.val.as_ref()\r\n    }\r\n}\r\n```\r\n\r\n#64325", "labels": ["A-lifetimes", "C-bug", "F-arbitrary_self_types", "T-compiler", "T-lang"], "number_of_comments": 1, "created_at": "2020-02-11 17:24:51", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563209453": {"author_username": "zonyitoo", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69061, "title": "SocketAddr from UnixDatagram recv_from missing the last character (on OS X)", "body": "I tried this code:\r\n\r\n```rust\r\nuse std::os::unix::net::UnixDatagram;\r\n\r\nfn main() {\r\n    let socket = UnixDatagram::bind(\"/tmp/shadowsocks-manager.sock\").unwrap();\r\n\r\n    let mut buf = [0u8; 65536];\r\n    loop {\r\n        let (n, src_addr) = socket.recv_from(&mut buf).unwrap();\r\n        println!(\"size={} src={:?}\", n, src_addr);\r\n    }\r\n}\r\n```\r\n\r\nSend request with a Python test script:\r\n\r\n```python\r\nimport socket\r\n\r\ncli = socket.socket(socket.AF_UNIX, socket.SOCK_DGRAM)\r\ncli.bind('/tmp/shadowsocks-manager-c.sock')\r\ncli.connect('/tmp/shadowsocks-manager.sock')\r\n\r\ncli.send(b'ping')\r\nprint(cli.recv(1506))\r\n```\r\n\r\nI expected to see this happen: \r\n\r\n```\r\nsize=4 src=\"/tmp/shadowsocks-manager-c.sock\" (pathname)\r\n```\r\n\r\nInstead, this happened: \r\n\r\n```\r\nsize=4 src=\"/tmp/shadowsocks-manager-c.soc\" (pathname)\r\n```\r\n\r\nMissing the last character.\r\n\r\n### Meta\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.42.0-nightly (859764425 2020-01-07)\r\nbinary: rustc\r\ncommit-hash: 85976442558bf2d09cec3aa49c9c9ba86fb15c1f\r\ncommit-date: 2020-01-07\r\nhost: x86_64-apple-darwin\r\nrelease: 1.42.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\n### Problem\r\n\r\nOn OS X, `sockaddr_un` is defined as\r\n\r\n```c\r\n/*\r\n * [XSI] Definitions for UNIX IPC domain.\r\n */\r\nstruct  sockaddr_un {\r\n\tunsigned char   sun_len;        /* sockaddr len including null */\r\n\tsa_family_t     sun_family;     /* [XSI] AF_UNIX */\r\n\tchar            sun_path[104];  /* [XSI] path name (gag) */\r\n};\r\n```\r\n\r\nwhich has one more byte `sun_len` before `sun_path` than Linux's definition:\r\n\r\n```c\r\n#define\t__SOCKADDR_COMMON(sa_prefix) \\\r\n  sa_family_t sa_prefix##family\r\n\r\n/* Structure describing the address of an AF_LOCAL (aka AF_UNIX) socket.  */\r\nstruct sockaddr_un\r\n  {\r\n    __SOCKADDR_COMMON (sun_);\r\n    char sun_path[108];\t\t/* Path name.  */\r\n  };\r\n```\r\n\r\nThis issue also exists in Tokio (Mio), too. https://github.com/tokio-rs/tokio/issues/2230", "labels": ["C-bug", "T-libs"], "number_of_comments": 9, "created_at": "2020-02-11 13:33:21", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563187971": {"author_username": "Mark-Simulacrum", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69060, "title": "non-deterministic syn-opt run", "body": "https://perf.rust-lang.org/detailed-query.html?commit=e369f6b617bc5124ec5d02626dc1c821589e6eb3&base_commit=4d1241f5158ffd66730e094d8f199ed654ed52ae&benchmark=syn-opt&run_name=patched%20incremental:%20println\r\n\r\nThis perf run was expected to be a no-op, but appears to have resulted in slightly less queries being run (2 def_span and 2 metadata reads). \r\n\r\ncc @eddyb", "labels": ["A-reproducibility", "C-bug", "T-compiler"], "number_of_comments": 4, "created_at": "2020-02-11 12:54:47", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563110209": {"author_username": "olegnn", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69054, "title": "Incorrect error for type already defined in scope using raw identifiers", "body": "This code\r\n\r\n```rust\r\ntrait T<r#fn> {\r\n    fn f<r#fn>() {}\r\n}\r\n\r\nfn main() {}\r\n\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=73f56a1b4d4ac37801c60b8e8738242d))\r\n\r\nGives incorrect error for type declared using raw identifiers:\r\n\r\n```\r\nerror[E0403]: the name `fn` is already used for a generic parameter in this item's generic parameters\r\n --> src/main.rs:2:10\r\n  |\r\n1 | trait T<r#fn> {\r\n  |         ---- first use of `fn`\r\n2 |     fn f<r#fn>() {}\r\n  |          ^^^^ already used\r\n\r\nwarning: type parameter `fn` should have an upper camel case name\r\n --> src/main.rs:1:9\r\n  |\r\n1 | trait T<r#fn> {\r\n  |         ^^^^ help: convert the identifier to upper camel case: `Fn`\r\n  |\r\n  = note: `#[warn(non_camel_case_types)]` on by default\r\n\r\nwarning: type parameter `fn` should have an upper camel case name\r\n --> src/main.rs:2:10\r\n  |\r\n2 |     fn f<r#fn>() {}\r\n  |          ^^^^ help: convert the identifier to upper camel case: `Fn`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0403`.\r\nerror: could not compile `playground`.\r\n```", "labels": [], "number_of_comments": 0, "created_at": "2020-02-11 10:32:09", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563110178": {"author_username": "olegnn", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69053, "title": "Incorrect help message for type declared on struct using raw identifier", "body": "This code\r\n```rust\r\nstruct r#struct<r#fn>;\r\n\r\nfn main() {}\r\n\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=67fec620c3f519c8b8f8b13f209b0a1e))\r\n\r\nProduces incorrect help message:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nwarning: type `struct` should have an upper camel case name\r\n --> src/main.rs:1:8\r\n  |\r\n1 | struct r#struct<r#fn>;\r\n  |        ^^^^^^^^ help: convert the identifier to upper camel case: `Struct`\r\n  |\r\n  = note: `#[warn(non_camel_case_types)]` on by default\r\n\r\nwarning: type parameter `fn` should have an upper camel case name\r\n --> src/main.rs:1:17\r\n  |\r\n1 | struct r#struct<r#fn>;\r\n  |                 ^^^^ help: convert the identifier to upper camel case: `Fn`\r\n\r\nerror[E0392]: parameter `fn` is never used\r\n --> src/main.rs:1:17\r\n  |\r\n1 | struct r#struct<r#fn>;\r\n  |                 ^^^^ unused parameter\r\n  |\r\n  = help: consider removing `fn`, referring to it in a field, or using a marker such as `std::marker::PhantomData`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0392`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```", "labels": [], "number_of_comments": 7, "created_at": "2020-02-11 10:32:05", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "563110155": {"author_username": "olegnn", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69052, "title": "`r#` stripped from raw idents in lint and `type annotations needed` error", "body": "This code\r\n\r\n```rust\r\nfn r<r#trait>() {}\r\n\r\nfn main() {\r\n    r();\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=a12ec17055cf3c08f4b6d59b31969dfc))\r\n\r\nGives incorrect warning and error for type declared using raw identifiers:\r\n\r\n```\r\nwarning: type parameter `trait` should have an upper camel case name\r\n --> src/main.rs:1:6\r\n  |\r\n1 | fn r<r#trait>() {}\r\n  |      ^^^^^^^ help: convert the identifier to upper camel case: `Trait`\r\n  |\r\n  = note: `#[warn(non_camel_case_types)]` on by default\r\n\r\nerror[E0282]: type annotations needed\r\n --> src/main.rs:4:5\r\n  |\r\n4 |     r();\r\n  |     ^ cannot infer type for type parameter `trait`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0282`.\r\nerror: could not compile `playground`.\r\n```\r\n\r\nNOTE: This is about the diagnostics not including the `r#` in each case.", "labels": ["A-diagnostics", "C-bug", "D-incorrect", "T-compiler"], "number_of_comments": 6, "created_at": "2020-02-11 10:32:03", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562875846": {"author_username": "Lucretiel", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69043, "title": "Feature request: `swap_retain`", "body": "I'd like to propose a version of `Vec::retain` that operates more efficiently because it doesn't try to preserve the ordering of retained elements, similar to `Vec::swap_remove`. Possible names would be `retain_unordered` or `swap_retain` (for parity with `swap_remove`). A simple implementation would look like this, though there may obviously be more efficient / optimizer-friendly versions:\r\n\r\n```rust\r\nfn swap_retain(&mut self, mut pred: impl FnMut(&T) -> bool) {\r\n    for i in 0.. {\r\n        while i < self.len() && !pred(&self[i]) {\r\n            self.swap_remove(i);\r\n        }\r\n    }\r\n}\r\n```", "labels": ["A-collections", "C-feature-request", "T-libs"], "number_of_comments": 4, "created_at": "2020-02-10 22:49:15", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562813333": {"author_username": "petrochenkov", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69041, "title": "proc_macro: Stabilize `Span::resolved_at` and `Span::located_at`", "body": "Introduced in https://github.com/rust-lang/rust/pull/47149.\r\nPart of https://github.com/rust-lang/rust/issues/54725.\r\n\r\nMotivation: https://github.com/rust-lang/rust/pull/68716#issuecomment-583918919.\r\nIdentifiers in proc macros may want to inherit span locations for diagnostics from one tokens (e.g. some tokens from the macro input), but resolve those identifiers from some different location (e.g. from the macro's definition site).\r\nThis becomes especially important when multiple resolution locations become available with stabilization of [`Span::mixed_site`](https://github.com/rust-lang/rust/pull/68716).\r\n\r\nWhy I think this is the right API for setting span's location and hygiene - https://github.com/rust-lang/rust/pull/69041#issuecomment-586644778.\r\n\r\nr? @dtolnay ", "labels": ["A-macros", "S-waiting-on-review", "T-lang", "T-libs", "needs-fcp", "relnotes"], "number_of_comments": 3, "created_at": "2020-02-10 20:37:39", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562790714": {"author_username": "shepmaster", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69039, "title": "Using a String as a generator resume argument causes a segfault", "body": "I tried this code:\r\n\r\n```rust\r\n#![feature(generators, generator_trait)]\r\n\r\nuse std::{\r\n    io,\r\n    ops::{Generator, GeneratorState},\r\n};\r\n\r\nfn my_scenario() -> impl Generator<String, Yield = &'static str, Return = String> {\r\n    |_arg: String| {\r\n        let my_name = yield \"What is your name?\";\r\n        let my_mood = yield \"How are you feeling?\";\r\n        format!(\"{} is {}\", my_name.trim(), my_mood.trim())\r\n    }\r\n}\r\n\r\nfn main() {\r\n    let mut my_session = Box::pin(my_scenario());\r\n\r\n    loop {\r\n        let mut line = String::new();\r\n\r\n        match my_session.as_mut().resume(line) {\r\n            GeneratorState::Yielded(prompt) => {\r\n                println!(\"{}\", prompt);\r\n            }\r\n            GeneratorState::Complete(v) => {\r\n                println!(\"{}\", v);\r\n                break;\r\n            }\r\n        }\r\n\r\n        line = String::new();\r\n        io::stdin().read_line(&mut line).unwrap();\r\n    }\r\n}\r\n```\r\n\r\nI expected to see see the output \"Person is Mood\", instead, I got a segfault:\r\n\r\n```\r\n./target/debug/example\r\nWhat is your name?\r\nPerson\r\nHow are you feeling?\r\nMood\r\nzsh: segmentation fault  ./target/debug/example\r\n```\r\n\r\n`rustc +nightly-2020-02-10 --version --verbose`:\r\n\r\n```\r\nrustc 1.43.0-nightly (71c7e149e 2020-02-09)\r\nbinary: rustc\r\ncommit-hash: 71c7e149e42cb0fc78a80db70d2525973311d488\r\ncommit-date: 2020-02-09\r\nhost: x86_64-apple-darwin\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\n* thread #1, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=EXC_I386_GPFLT)\r\n  * frame #0: 0x0000000100023e23 so`core::str::_$LT$impl$u20$str$GT$::trim::hb5debbd36d4b73d0 [inlined] core::str::next_code_point_reverse::hf0fce3726ea99362 at mod.rs:554:21 [opt]\r\n    frame #1: 0x0000000100023e13 so`core::str::_$LT$impl$u20$str$GT$::trim::hb5debbd36d4b73d0 [inlined] _$LT$core..str..Chars$u20$as$u20$core..iter..traits..double_ended..DoubleEndedIterator$GT$::next_back::hc11021e0120a3995 at mod.rs:631 [opt]\r\n    frame #2: 0x0000000100023e13 so`core::str::_$LT$impl$u20$str$GT$::trim::hb5debbd36d4b73d0 [inlined] _$LT$core..str..CharIndices$u20$as$u20$core..iter..traits..double_ended..DoubleEndedIterator$GT$::next_back::h66ffec0553639954 at mod.rs:722 [opt]\r\n    frame #3: 0x0000000100023e13 so`core::str::_$LT$impl$u20$str$GT$::trim::hb5debbd36d4b73d0 [inlined] _$LT$core..str..pattern..MultiCharEqSearcher$LT$C$GT$$u20$as$u20$core..str..pattern..ReverseSearcher$GT$::next_back::hbe5e94cd1a3aa61a at pattern.rs:540 [opt]\r\n    frame #4: 0x0000000100023dc6 so`core::str::_$LT$impl$u20$str$GT$::trim::hb5debbd36d4b73d0 [inlined] core::str::pattern::ReverseSearcher::next_reject_back::h865e71e64b0a0a65 at pattern.rs:201 [opt]\r\n    frame #5: 0x0000000100023dc6 so`core::str::_$LT$impl$u20$str$GT$::trim::hb5debbd36d4b73d0 [inlined] _$LT$core..str..pattern..CharPredicateSearcher$LT$F$GT$$u20$as$u20$core..str..pattern..ReverseSearcher$GT$::next_reject_back::h30b729c431f6e983 at pattern.rs:615 [opt]\r\n    frame #6: 0x0000000100023dc6 so`core::str::_$LT$impl$u20$str$GT$::trim::hb5debbd36d4b73d0 [inlined] core::str::_$LT$impl$u20$str$GT$::trim_matches::h4d77028f159152d3 at mod.rs:3828 [opt]\r\n    frame #7: 0x0000000100023c41 so`core::str::_$LT$impl$u20$str$GT$::trim::hb5debbd36d4b73d0 at mod.rs:3631 [opt]\r\n    frame #8: 0x0000000100002235 so`so::my_scenario::_$u7b$$u7b$closure$u7d$$u7d$::h5123a67f3a151902((null)=String @ 0x00007ffeefbff148) at main.rs:12:28\r\n    frame #9: 0x000000010000328d so`so::main::h64afc6de80b00fef at main.rs:22:14\r\n    frame #10: 0x0000000100003682 so`std::rt::lang_start::_$u7b$$u7b$closure$u7d$$u7d$::h2f745c4383613da0 at rt.rs:67:33\r\n    frame #11: 0x000000010000c1a8 so`std::panicking::try::do_call::hb3640f3c79a55ca9 [inlined] std::rt::lang_start_internal::_$u7b$$u7b$closure$u7d$$u7d$::h060e10b65682cba1 at rt.rs:52:12 [opt]\r\n    frame #12: 0x000000010000c19c so`std::panicking::try::do_call::hb3640f3c79a55ca9 at panicking.rs:303 [opt]\r\n    frame #13: 0x000000010000d9cb so`__rust_maybe_catch_panic at lib.rs:86:7 [opt]\r\n    frame #14: 0x000000010000ca3c so`std::rt::lang_start_internal::h06d0538a60720103 [inlined] std::panicking::try::h28c1481276f9013c at panicking.rs:281:12 [opt]\r\n    frame #15: 0x000000010000ca09 so`std::rt::lang_start_internal::h06d0538a60720103 [inlined] std::panic::catch_unwind::h8d148cd6572d34ca at panic.rs:394 [opt]\r\n    frame #16: 0x000000010000ca09 so`std::rt::lang_start_internal::h06d0538a60720103 at rt.rs:51 [opt]\r\n    frame #17: 0x0000000100003662 so`std::rt::lang_start::hb165706ba3f75183(main=(so`so::main::h64afc6de80b00fef at main.rs:16), argc=1, argv=0x00007ffeefbff420) at rt.rs:67:4\r\n    frame #18: 0x0000000100003612 so`main + 34\r\n    frame #19: 0x00007fff6794c7fd libdyld.dylib`start + 1\r\n```\r\n\r\n</p>\r\n</details>\r\n", "labels": ["A-generators", "C-bug", "F-generators", "I-unsound \ud83d\udca5", "T-compiler", "requires-nightly"], "number_of_comments": 13, "created_at": "2020-02-10 19:55:43", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562735663": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69036, "title": "rustc: don't resolve Instances which would produce malformed shims.", "body": "There are some `InstanceDef` variants (shims and drop \"glue\") which contain a `Ty`, and that `Ty` is used in generating the shim MIR. But if that `Ty` mentions any generic parameters, the generated shim would refer to them (but they won't match the `Substs` of the `Instance`), or worse, generating the shim would fail because not enough of the type is known.\r\n\r\nIdeally we would always produce a \"skeleton\" of the type, e.g. `(_, _)` for dropping any tuples with two elements, or `Vec<_>` for dropping any `Vec` value, but that's a lot of work, and they would still not match the `Substs` of the `Instance` as it exists today, so `Instance` would probably need to change.\r\n\r\nBy making `Instance::resolve` return `None` in the still-generic cases, we get behavior similar to specialization, where a default can only be used if there are no more generic parameters which would allow a more specialized `impl` to match.\r\n\r\n<hr/>\r\n\r\nThis was found while testing the MIR inliner with #68965, because it was trying to inline shims.\r\n\r\ncc @rust-lang/wg-mir-opt", "labels": ["S-waiting-on-author"], "number_of_comments": 12, "created_at": "2020-02-10 18:11:39", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562707503": {"author_username": "jonas-schievink", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69033, "title": "Use generator resume arguments in the async/await lowering", "body": "This removes the TLS requirement from async/await and enables it in `#![no_std]` crates.\r\n\r\nCloses https://github.com/rust-lang/rust/issues/56974\r\n\r\nI'm not confident the HIR lowering is completely correct, there seem to be quite a few undocumented invariants in there. The `async-std` and tokio test suites are passing with these changes though.", "labels": ["S-waiting-on-review"], "number_of_comments": 9, "created_at": "2020-02-10 17:17:28", "reactions": {"total_count": 30, "+1": 0, "-1": 0, "laugh": 0, "heart": 11, "hooray": 19}}, "562674624": {"author_username": "estebank", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69029, "title": "[TEST] Defer evaluation of method receiver type", "body": "When encountering `MethodCall` expressions where the receiver type is\r\nstill being inferred, and the receiver expression is a `Path`\r\n(potentially accessing a simple binding), we delay the evaluation of\r\nthat receiver until after the rest of the block has been evaluated. This\r\nallows otherwise invalid expressions to be successfully inferred, for\r\nexample the following:\r\n\r\n```rust\r\nfn foo() -> Vec<u16> {\r\n    let mut s = vec![].into_iter().collect();\r\n    s.push(0);\r\n    s\r\n}\r\n```\r\n\r\nnow succeeds, just like the following always have:\r\n\r\n```rust\r\nfn foo() -> Vec<u16> {\r\n    let s = vec![].into_iter().collect();\r\n    s\r\n}\r\nfn bar() -> Vec<u16> {\r\n    vec![].into_iter().collect()\r\n}\r\n```\r\n\r\nThese changes will not affect the following, which will continue to\r\nrequire type annotations:\r\n\r\n```rust\r\nfn foo(data: &[u32]) -> String {\r\n    data.iter().sum().to_string()\r\n             // ^^^\r\n             // |\r\n             // type annotations needed\r\n             // specify the type argument: `sum::<S>`\r\n}\r\n```\r\n\r\nThis last example would fail even if we weren't restricting the new\r\nbehavior to `Path` receiver expressions because `S` would be resolved to\r\n`&u32`, which can't be converted to `String`.\r\n\r\nhttps://github.com/rust-lang/rust/issues/68991\r\nhttps://github.com/rust-lang/rust/issues/42333", "labels": ["S-waiting-on-review"], "number_of_comments": 11, "created_at": "2020-02-10 16:24:47", "reactions": {"total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 3}}, "562642758": {"author_username": "Kinrany", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69025, "title": "Rustdoc: prioritize matches with same casing in search results", "body": "It would be convenient if [the results] for a lowercase `filter` showed exact match `filter` before `Filter`, and vice versa.\r\n\r\n[the results]: https://docs.rs/futures/0.3.4/futures/index.html?search=filter\r\n", "labels": ["C-enhancement", "T-rustdoc"], "number_of_comments": 7, "created_at": "2020-02-10 15:36:29", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562639439": {"author_username": "ordian", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69024, "title": "Missed optimization on fixed-size bytes comparison", "body": "https://play.rust-lang.org/?version=stable&mode=release&edition=2018&gist=99eabb4a672da50556a9eb7d4f4016e9\r\n\r\ncc #62531\r\n\r\nThe generated assembly calles into `memcmp`, but still is slower.\r\n```asm\r\nplayground::H256::eq_libc:\r\n\tmovdqu\t(%rdi), %xmm0\r\n\tmovdqu\t16(%rdi), %xmm1\r\n\tmovdqu\t(%rsi), %xmm2\r\n\tpcmpeqb\t%xmm0, %xmm2\r\n\tmovdqu\t16(%rsi), %xmm0\r\n\tpcmpeqb\t%xmm1, %xmm0\r\n\tpand\t%xmm2, %xmm0\r\n\tpmovmskb\t%xmm0, %eax\r\n\tcmpl\t$65535, %eax\r\n\tsete\t%al\r\n\tretq\r\n\r\nplayground::H256::eq_derived:\r\n\tcmpq\t%rsi, %rdi\r\n\tje\t.LBB1_1\r\n\tmovdqu\t(%rdi), %xmm0\r\n\tmovdqu\t16(%rdi), %xmm1\r\n\tmovdqu\t(%rsi), %xmm2\r\n\tpcmpeqb\t%xmm0, %xmm2\r\n\tmovdqu\t16(%rsi), %xmm0\r\n\tpcmpeqb\t%xmm1, %xmm0\r\n\tpand\t%xmm2, %xmm0\r\n\tpmovmskb\t%xmm0, %eax\r\n\tcmpl\t$65535, %eax\r\n\tsete\t%al\r\n\tretq\r\n\r\n.LBB1_1:\r\n\tmovb\t$1, %al\r\n\tretq\r\n\r\nplayground::H256::cmp_libc:\r\n\tpushq\t%rax\r\n\tmovl\t$32, %edx\r\n\tcallq\t*memcmp@GOTPCREL(%rip)\r\n\txorl\t%ecx, %ecx\r\n\ttestl\t%eax, %eax\r\n\tsetne\t%cl\r\n\tmovl\t$255, %eax\r\n\tcmovnsl\t%ecx, %eax\r\n\tpopq\t%rcx\r\n\tretq\r\n\r\nplayground::H256::cmp_derived:\r\n\tpushq\t%rax\r\n\tmovl\t$32, %edx\r\n\tcallq\t*memcmp@GOTPCREL(%rip)\r\n\ttestl\t%eax, %eax\r\n\tsetns\t%cl\r\n\taddb\t%cl, %cl\r\n\taddb\t$-1, %cl\r\n\ttestl\t%eax, %eax\r\n\tmovzbl\t%cl, %ecx\r\n\tcmovnel\t%ecx, %eax\r\n\tpopq\t%rcx\r\n\tretq\r\n```\r\n\r\n", "labels": ["C-enhancement", "I-slow", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-10 15:31:29", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562589328": {"author_username": "RalfJung", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69021, "title": "\"exceeding_bitshifts\" lint does not work in debug mode and in associated consts", "body": "The `exceeding_bitshifts` lint should fire on the following code in debug mode, but it only fires when building in release mode:\r\n```rust\r\n#![allow(const_err)]\r\n\r\nuse std::i32;\r\n\r\npub fn foo(x: i32) {\r\n    let _ = x << 42; // no warning here\r\n}\r\n```\r\nThe reason is that the lint checks for the `BinOp` MIR rvalue, but in debug mode this function only has a `CheckedBinOp`.\r\n\r\nThe lint also does not work in associated consts (both in debug and release mode):\r\n```rust\r\npub trait Foo {\r\n    const N: i32;\r\n}\r\n\r\nimpl<T: Foo> Foo for Vec<T> {\r\n    const N: i32 = T::N << 42; // no warning here\r\n}\r\n```\r\nThis is probably for the same reason; from what I can tell, `const` bodies *always* use `CheckedBinOp` even in release builds.\r\n\r\nCc @oli-obk @wesleywiser \n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\nThis issue has been assigned to @jumbatm via [this comment](https://github.com/rust-lang/rust/issues/69021#issuecomment-584603723).\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"jumbatm\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "labels": ["A-lint", "C-bug", "T-compiler"], "number_of_comments": 2, "created_at": "2020-02-10 14:16:02", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562576909": {"author_username": "RalfJung", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69020, "title": "Duplicate errors for overflowing division / remainder", "body": "When there is an overflowing division or remainder operation that const_prop can detect, the error is duplicated *in release mode only*:\r\n```rust\r\n#![deny(const_err)]\r\n\r\nuse std::i32;\r\n\r\nfn main() {\r\n    let _ = i32::MIN / -1;\r\n}\r\n```\r\nshows\r\n```\r\nerror: attempt to divide with overflow\r\n --> src/main.rs:6:13\r\n  |\r\n6 |     let _ = i32::MIN / -1;\r\n  |             ^^^^^^^^^^^^^\r\n  |\r\nnote: the lint level is defined here\r\n --> src/main.rs:1:9\r\n  |\r\n1 | #![deny(const_err)]\r\n  |         ^^^^^^^^^\r\n\r\nerror: this expression will panic at runtime\r\n --> src/main.rs:6:13\r\n  |\r\n6 |     let _ = i32::MIN / -1;\r\n  |             ^^^^^^^^^^^^^ attempt to divide with overflow\r\n```\r\nThis is because `!overflow_check` is `true` in release mode but divison and remainder *still* get overflow checks.\r\n\r\n([This test case](https://github.com/rust-lang/rust/blob/4d1241f5158ffd66730e094d8f199ed654ed52ae/src/test/ui/issues/issue-8460-const.rs#L12) already covers the problem, so a fix does not need a new test case, it just needs to adjust the existing test case to no longer expect two `ERROR` per line.)\r\n\r\nCc @oli-obk @wesleywiser ", "labels": ["A-const-eval", "C-bug", "D-verbose", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-10 13:56:05", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562564549": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69019, "title": "Choose a naming scheme for codegen debuginfo emission.", "body": "Right now it's a mix of `debuginfo`, `dbg` and `DI`.\r\n(`DIFoo` is how LLVM refers to its debuginfo metadata)\r\n\r\nI would prefer if we had something consistent, e.g.:\r\n* go full on DWARF and use `dw` and `Dw` as prefixes, followed by DWARF names (e.g. `DwSubprogram` for a function)\r\n  * easier to refer back to the DWARF spec\r\n  * LLVM already uses mostly DWARF concepts, and other formats, like CodeView, have to convert from that\r\n* do our own thing, using `dbg` and `Dbg`, with names chosen by us (e.g. `DbgFn`)\r\n  * nicer/cleaner in the context of Rust/MIR\r\n  * potentially confusing/annoying to people who are familiar with DWARF or LLVM's approximation of it\r\n\r\nPart of the reason I think we should decide now is @bjorn3 has expressed interest in making most of `rustc_codegen_llvm::debuginfo` LLVM-independent, in order to be able to use it in the Cranelift backend to emit DWARF.\r\nA lot of that code is effectively lowering Rust types into DWARF ones, but using LLVM's API to create LLVM metadata nodes instead of directly emitting DWARF.\r\n\r\nIf we go with the DWARF-based naming I would go as far as to say that everything other than debug locations and variables inside functions, should go into a `rustc_codegen_dwarf` (or just `rustc_dwarf`) crate.\r\n\r\ncc @michaelwoerister @nagisa @rust-lang/wg-mir-opt ", "labels": ["A-debuginfo", "T-compiler"], "number_of_comments": 5, "created_at": "2020-02-10 13:34:57", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562546352": {"author_username": "jfrimmel", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69018, "title": "Incorrect dead-code-warning on enum when using Self", "body": "The following code produces an incorrect dead code warning (\"warning: variant is never constructed: `Variant`\"), when using the `Self` keyword. When using the enumeration name (`E`), there is no warning.\r\n```rust\r\n// rustc --edition 2018 --crate-type rlib warning.rs\r\nenum E {\r\n    Variant { _unused: () }\r\n}\r\nimpl E {\r\n    fn new() -> Self {\r\n        Self::Variant { _unused: () }\r\n        // E::Variant { _unused: () } // <-- warning vanishes\r\n    }\r\n}\r\n \r\npub struct S(E);\r\nimpl S {\r\n    pub fn new() -> Self {\r\n        Self(E::new())\r\n    }\r\n}\r\n```\r\n\r\nTested versions:\r\n```\r\nrustc 1.41.0 (5e1a79984 2020-01-27)\r\nrustc 1.42.0-nightly (212b2c7da 2020-01-30)\r\nrustc 1.43.0-nightly (58b834344 2020-02-05)\r\n```\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\nThis issue has been assigned to @matprec via [this comment](https://github.com/rust-lang/rust/issues/69018#issuecomment-584134027).\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"matprec\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "labels": ["A-lint", "C-bug", "T-compiler"], "number_of_comments": 2, "created_at": "2020-02-10 13:02:40", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562523541": {"author_username": "dbdr", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69016, "title": "Inconsistent unused warning for local const inside unused methods (but not functions)", "body": "```rust\r\nfn _unused1(x: i32) -> i32 {\r\n    const F: i32 = 2;\r\n    let g = 1;\r\n    x * F + g\r\n} \r\n\r\npub struct Foo {}\r\n\r\nimpl Foo {\r\n    fn _unused2(x: i32) -> i32 {\r\n        const F: i32 = 2;\r\n        let g = 1;\r\n        x * F + g\r\n    } \r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=c40b89520638bf949f9fec7577cdb31a))\r\n\r\nThere is a warning about F being unused in method _unused2, while there isn't about the same situation in function _unused1:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nwarning: constant item is never used: `F`\r\n  --> src/lib.rs:11:9\r\n   |\r\n11 |         const F: i32 = 2;\r\n   |         ^^^^^^^^^^^^^^^^^\r\n   |\r\n   = note: `#[warn(dead_code)]` on by default\r\n\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.54s\r\n\r\n```\r\nLocal variable g is also not reported as unused in either case. Unless I'm mistaken, F and g are similar in that they are local to the function/method. I would expect no warning for this code.\r\n\r\nNote that this is different from  #47133 because here the const is local, which I think makes the case more clear-cut.", "labels": ["A-lint", "C-bug"], "number_of_comments": 0, "created_at": "2020-02-10 12:17:23", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562359002": {"author_username": "Zoxc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69015, "title": "Fix incremental bugs in the HIR map", "body": "", "labels": ["S-waiting-on-author"], "number_of_comments": 23, "created_at": "2020-02-10 06:48:45", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562271182": {"author_username": "foeb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69011, "title": "Document unsafe blocks in core::fmt", "body": "r? @RalfJung \r\nCC: @rust-lang/wg-unsafe-code-guidelines\r\n#66219\r\n\r\nSorry for the hiatus, but here's a few more files with the unsafe blocks documented! I think working on it smaller chunks like this will be easier for everyone.\r\n", "labels": ["S-waiting-on-review"], "number_of_comments": 4, "created_at": "2020-02-10 00:50:58", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562264306": {"author_username": "jonas-schievink", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 69010, "title": "Add an early-exit to `overlapping_impls`", "body": "This is hit in approx. 37% of all calls when building the stm32f0(x2) crate, saving a small amount of time.\r\n\r\nThis can probably be done more effectively than using `simplify_type`, since that only seems to descend by one layer.", "labels": ["S-waiting-on-author"], "number_of_comments": 18, "created_at": "2020-02-10 00:13:00", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562179915": {"author_username": "LukasKalbertodt", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68995, "title": "Add `with_exact_size` and `with_size_hint` to `Iterator`", "body": "Usually iterator adaptors do a fine job at keeping information about the length of an iterator. But once you throw something like `filter` in your iterator chain, the lower bound is 0, meaning that collecting into a collection can't properly pre-allocate. Also, some iterator adaptors (like `chain`) cannot implemented `ExactSizeIterator` although in many real world cases, the size is perfectly known. \r\n\r\nCurrently, working around those limitations is often tedious and requires quite a bit of additional code. I think it would be a lot nicer to just add a `.with_exact_size(27)` somewhere into your chain. So I'd like to propose adding the following to `Iterator`:\r\n\r\n- **`fn with_size_hint(self, lower: usize, upper: Option<usize>) -> SizeHint`**\r\n  - `SizeHint` would implement `Iterator::size_hint` with the given values, forwarding all other methods to the inner iterator (and implementing the same traits)\r\n- **`fn with_exact_size(self, size: usize) -> ExactSize`**\r\n  - `ExactSize` would implement `ExactSizeIterator` with the given value and override `Iterator::size_hint`. All other methods are forwarded to the inner iterator (and implementing the same traits, plus `ExactSizeIterator`)\r\n\r\nI would have created this as a PR, but I'm short on time and wanted to hear some opinions first. ", "labels": ["A-iterators", "C-feature-request", "T-libs"], "number_of_comments": 5, "created_at": "2020-02-09 13:51:35", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562176584": {"author_username": "albins", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68993, "title": "[WIP] polonius: adapt to the new fact format", "body": "Hopefully the final phase of the ordeal now known as The Great Renaming, in which the Polonius working group renames virtually all of their input facts.\r\n\r\nThis also extends fact generation to support full initialisation tracking and move analysis in Polonius.", "labels": ["S-waiting-on-review"], "number_of_comments": 8, "created_at": "2020-02-09 13:26:04", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 1}}, "562174446": {"author_username": "gnzlbg", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68990, "title": "VecDeque::new allocates", "body": "I've noticed that `VecDeque::new` allocates. We don't guarantee that it doesn't, but this felt inconsistent with, e.g., `Vec::new`, for which we do guarantee that it does not allocate. \r\n\r\nI'm not sure what the appropriate venue is for discussing this, but I think it would make sense to remove the surprise here and guarantee that `VecDeque::new` does not heap-allocate either. \r\n\r\ncc @rust-lang/libs ", "labels": ["A-collections", "C-enhancement", "I-slow", "T-libs"], "number_of_comments": 1, "created_at": "2020-02-09 13:09:29", "reactions": {"total_count": 3, "+1": 3, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562150226": {"author_username": "XAMPPRocky", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68989, "title": "Update RELEASES.md for 1.42.0", "body": "### [Rendered](https://github.com/XAMPPRocky/rust/blob/relnotes-1.42.0/RELEASES.md)\r\n\r\nr? @Mark-Simulacrum \r\ncc @rust-lang/release ", "labels": ["S-waiting-on-review", "T-release"], "number_of_comments": 2, "created_at": "2020-02-09 09:42:17", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562129712": {"author_username": "frostyplanet", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68987, "title": "rustc: Improve unexpected close delimiter hint", "body": "I found writing rust often confused by missing closing \"}\" or \")\" error message.  when editting large file.  the line number in error message is completely wrong, looking through my code the changes are no where near the line. It takes a long time for me to spot the syntax problem.   \r\n\r\n```\r\nerror: unexpected close delimiter: `}`\r\n    --> core/src/tx_file.rs:1218:1\r\n     |\r\n1179 |             None=>{},\r\n     |                   -- this block is empty, you might have not meant to close it\r\n...\r\n1218 | }\r\n     | ^ unexpected close delimiter\r\n\r\n```", "labels": ["A-diagnostics", "A-parser", "C-enhancement", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-09 06:19:10", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562127320": {"author_username": "daboross", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68985, "title": "Parse & reject postfix operators after casts", "body": "This adds an explicit error messages for when parsing `x as Type[0]` or similar expressions. Our add an extra parse case for parsing any postfix operator (dot, indexing, method calls, await) that triggers directly after parsing `as` expressions.\r\n\r\nMy friend and I worked on this together, but they're still deciding on a github username and thus I'm submitting this for both of us.\r\n\r\nIt will immediately error out, but will also provide the rest of the parser with a useful parse tree to deal with.\r\n\r\nThere's one decision we made in how this produces the parse tree. In the situation `&x as T[0]`, one could imagine this parsing as either `&((x as T)[0])` or `((&x) as T)[0]`. We chose the latter for ease of implementation, and as it seemed the most intuitive.\r\n\r\nFeedback welcome! This is our first change to the parser section, and it might be completely horrible.\r\n\r\nFixes #35813.", "labels": ["S-waiting-on-author"], "number_of_comments": 8, "created_at": "2020-02-09 05:51:11", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562125631": {"author_username": "ecstatic-morse", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68984, "title": "Make `u8::is_ascii` a stable `const fn`", "body": "`char::is_ascii` was already stabilized as `const fn` in #55278, so there is no reason for `u8::is_ascii` to go through an unstable period.\r\n\r\ncc @rust-lang/libs ", "labels": ["S-waiting-on-review", "T-libs", "disposition-merge", "final-comment-period", "relnotes"], "number_of_comments": 5, "created_at": "2020-02-09 05:33:34", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562124239": {"author_username": "ecstatic-morse", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68983, "title": "Tracking issue for making ASCII ctype inherent methods `const fn`", "body": "This is a tracking issue for making the inherent methods introduced in #46077 into `const fn`. This includes all functions listed in #39658 for both `u8` and `char`, namely:\r\n\r\n * `is_ascii_alphabetic`\r\n * `is_ascii_uppercase`\r\n * `is_ascii_lowercase`\r\n * `is_ascii_alphanumeric`\r\n * `is_ascii_digit`\r\n * `is_ascii_hexdigit`\r\n * `is_ascii_punctuation`\r\n * `is_ascii_graphic`\r\n * `is_ascii_whitespace`\r\n * `is_ascii_control` \r\n\r\nThe feature gate for the const version of these functions is `#![feature(const_ascii_ctype_on_intrinsics)]`. These cannot be const-stabilized until `#![feature(const_if_match)]` is stable.", "labels": ["A-const-fn", "B-unstable", "C-tracking-issue", "F-const_if_match", "T-libs"], "number_of_comments": 0, "created_at": "2020-02-09 05:19:06", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562123691": {"author_username": "estebank", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68982, "title": "Suggest correct code for associated fn with type parameters", "body": "#68689 partially addresses #50734, but we need to resugar the predicates to unify the output of a trait obligation with related projection obligations (associated types).\r\n\r\nFor example\r\n\r\n```\r\n   = help: implement the missing item: `fn from_iter<T>(_: T) -> Self where T: std::iter::IntoIterator, std::iter::IntoIterator::Item = A { unimplemented!() }`\r\n```\r\n\r\nshould be\r\n\r\n```\r\n   = help: implement the missing item: `fn from_iter<T>(_: T) -> Self where T: std::iter::IntoIterator<Item = A> { unimplemented!() }`\r\n```", "labels": ["A-diagnostics", "A-suggestion-diagnostics", "C-bug", "D-invalid-suggestion", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-09 05:13:18", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562119930": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68980, "title": "Consider emitting LLVM DIFile checksums.", "body": "We already hash the contents of `SourceFile`s to determine whether the file on disk (if it even exists) still has the same contents, across crates.\r\n\r\nI came across [LLVM supporting MD5 and SHA1 checksums](https://llvm.org/docs/LangRef.html#difile) for `DIFile`s, and I'm wondering if it could be useful in a similar way - perhaps debuggers would be able to detect changed sources?\r\n\r\ncc @michaelwoerister ", "labels": ["A-LLVM", "A-debuginfo", "C-enhancement", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-09 04:26:40", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562100008": {"author_username": "varkor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68977, "title": "Revert `compute_const` changes in WF", "body": "See https://github.com/rust-lang/rust/pull/56723/files/03b892860da5aff7a10cf4ca1364dbcacb95bfcd#r376641987. Opening this issue so I don't forget about it.\r\n\r\ncc @eddyb ", "labels": ["A-const-generics", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-09 00:33:44", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562092380": {"author_username": "glandium", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68974, "title": "Can't use ASAN with Xcode clang", "body": "When building rust code with `-Zsanitizer=address` and following through with `-fsanitize=address` for C/C++ code that might be compiled by build scripts, the build ends up failing with (using Xcode 11.3 on travis):\r\n```\r\n  = note: Undefined symbols for architecture x86_64:\r\n            \"___asan_version_mismatch_check_apple_1100\", referenced from:\r\n                _asan.module_ctor in libcinnabar.a(cinnabar-fast-import.o)\r\n                _asan.module_ctor in libcinnabar.a(cinnabar-helper.o)\r\n                _asan.module_ctor in libcinnabar.a(cinnabar-notes.o)\r\n                _asan.module_ctor in libcinnabar.a(cinnabar-util.o)\r\n                _asan.module_ctor in libcinnabar.a(hg-bundle.o)\r\n                _asan.module_ctor in libcinnabar.a(hg-connect.o)\r\n                _asan.module_ctor in libcinnabar.a(hg-connect-http.o)\r\n                ...\r\n          ld: symbol(s) not found for architecture x86_64\r\n          clang: error: linker command failed with exit code 1 (use -v to see invocation)\r\n```\r\n\r\nThere's probably nothing rust can do about it, so this is more about SEOing for people who might hit the same problem.", "labels": ["A-linkage", "A-sanitizers", "C-bug", "O-macos", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-08 23:16:01", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562090963": {"author_username": "glandium", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68973, "title": "rust-mingw is missing libssp*", "body": "The GCC compiler that comes with rust-mingw understands `-fstack-protector-strong` and emits stack-protector code, but the build further fails to link with messages like:\r\n```\r\nC:\\Users\\task_1581171456\\repo\\git-core\\libcinnabar.a(cinnabar-fast-import.o):cinnabar-fast-import.c:(.text+0x291): undefined reference to `__stack_chk_fail'\r\n```\r\n\r\nThe missing symbol is normally added by `gcc` to the `ld` command line via `-lssp_nonshared -lssp`, when it's passed `-fstack-protector-strong` during linking. Adding `-fstack-protector-strong` via `RUSTFLAGS=-Clink-arg=-fstack-protector-strong` doesn't actually work because of `-nostdlib` that rust adds on its own, but `RUSTFLAGS=-Clink-arg=-lssp_nonshared -Clink-arg=-lssp` doesn't work either because libssp* is not provided by rust-mingw.", "labels": ["C-bug", "O-windows-gnu", "T-infra"], "number_of_comments": 0, "created_at": "2020-02-08 23:01:15", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562089462": {"author_username": "Lokathor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68972, "title": "Range bound error in match has bad error message when integer literal wraps", "body": "For a match where I'm matching on a `u8`, I put `251..=256` on accident, and then rather than saying that 256 is out of range for `u8`, it decided to wrap 256 to 0 and then error that 251 is lower than the end of the range:\r\n```\r\nerror[E0030]: lower range bound must be less than or equal to upper                        \r\n  --> src\\lib.rs:86:7\r\n   |\r\n86 |       251..=256 => StarClass::BlueGiant,\r\n   |       ^^^ lower bound larger than upper bound\r\n```\r\nClearly this is not a good situation.\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\nThis issue has been assigned to @hirschenberger via [this comment](https://github.com/rust-lang/rust/issues/68972#issuecomment-584721519).\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"hirschenberger\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "labels": ["A-diagnostics", "C-bug", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-08 22:48:05", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 2, "heart": 0, "hooray": 0}}, "562084481": {"author_username": "matthewjasper", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68970, "title": "Implement a feature for a sound specialization subset", "body": "This implements a new feature (`min_specialization`) that restricts specialization to a subset that is reasonable for the standard library to use.\r\n\r\nThe plan is to then:\r\n\r\n* Update `libcore` and `liballoc` to compile with `min_specialization`.\r\n* Add a lint to forbid use of `feature(specialization)` (and other unsound, type system extending features) in the standard library.\r\n* Fix the soundness issues around `specialization`.\r\n* Remove `min_specialization`\r\n\r\nThe rest of this is an overview from a comment in this PR\r\n\r\n## Basic approach\r\n\r\nTo enforce this requirement on specializations we take the following approach:\r\n1. Match up the substs for `impl2` so that the implemented trait and self-type match those for `impl1`.\r\n2. Check for any direct use of `'static` in the substs of `impl2`.\r\n3. Check that all of the generic parameters of `impl1` occur at most once in the *unconstrained* substs for `impl2`. A parameter is constrained if its value is completely determined by an associated type projection predicate.\r\n4. Check that all predicates on `impl1` also exist on `impl2` (after matching substs).\r\n\r\n## Example\r\n\r\nSuppose we have the following always applicable impl:\r\n\r\n```rust\r\nimpl<T> SpecExtend<T> for std::vec::IntoIter<T> { /* specialized impl */ }\r\nimpl<T, I: Iterator<Item=T>> SpecExtend<T> for I { /* default impl */ }\r\n```\r\n\r\nWe get that the subst for `impl2` are `[T, std::vec::IntoIter<T>]`. `T` is constrained to be `<I as Iterator>::Item`, so we check only `std::vec::IntoIter<T>` for repeated parameters, which it doesn't have. The predicates of `impl1` are only `T: Sized`, which is also a predicate of impl2`. So this specialization is sound.\r\n\r\n## Extensions\r\n\r\nUnfortunately not all specializations in the standard library are allowed by this. So there are two extensions to these rules that allow specializing on some traits.\r\n\r\n### rustc_specialization_trait\r\n\r\nIf a trait is always applicable, then it's sound to specialize on it. We check trait is always applicable in the same way as impls, except that step 4 is now \"all predicates on `impl1` are always applicable\". We require that `specialization` or `min_specialization` is enabled to implement these traits.\r\n\r\n### rustc_specialization_marker\r\n\r\nThere are also some specialization on traits with no methods, including the `FusedIterator` trait which is advertised as allowing optimizations. We allow marking marker traits with an unstable attribute that means we ignore them in point 3 of the checks above. This is unsound but we allow it in the short term because it can't cause use after frees with purely safe code in the same way as specializing on traits methods can. \r\n\r\nr? @nikomatsakis\r\ncc #31844 #67194", "labels": ["F-specialization", "S-waiting-on-review"], "number_of_comments": 2, "created_at": "2020-02-08 22:01:54", "reactions": {"total_count": 14, "+1": 0, "-1": 0, "laugh": 0, "heart": 4, "hooray": 10}}, "562076255": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68965, "title": " rustc_mir: track inlined callees in SourceScopeData.", "body": "*Based on #69036 to allow bootstrapping with the MIR inliner enabled.*\r\n\r\nWe now record which MIR scopes are the roots of *other* (inlined) functions's scope trees, which allows us to generate the correct debuginfo in codegen, similar to what LLVM inlining generates.\r\nThis PR makes the `ui` test `backtrace-debuginfo` pass, if the MIR inliner is turned on by default.\r\n\r\nAlso, `#[track_caller]` is now correct in the face of MIR inlining (cc @anp).\r\n\r\nr? @rust-lang/wg-mir-opt", "labels": ["S-waiting-on-review"], "number_of_comments": 24, "created_at": "2020-02-08 20:51:42", "reactions": {"total_count": 4, "+1": 0, "-1": 0, "laugh": 0, "heart": 4, "hooray": 0}}, "562072178": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68964, "title": "MIR SourceScopes stay around even when all their uses were removed.", "body": "We already have a testcase, namely [`simplify_try`](https://github.com/rust-lang/rust/blob/85ffd44d3d86214fc06be4add039e26f85261a2b/src/test/mir-opt/simplify_try.rs), which replaces enough of the original body to make some `SourceScope`s unused.\r\n\r\nHowever, despite no statements/terminators using those scopes anymore, they stick around.\r\nThe fact that they're gone is in itself a problem (debuginfo is lost, see comments on #66282), but we could argue that `SourceScope`s only used in unreachable code should still be removed, e.g.:\r\n```rust\r\nif false {\r\n    let x = 123;\r\n}\r\n```\r\nThere is no reason to have debuginfo for `x` tracked anywhere once the `x = 123;` block is removed.\r\n\r\n@rust-lang/wg-mir-opt\r\n", "labels": ["A-debuginfo", "A-mir", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-08 20:17:48", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562053878": {"author_username": "olegnn", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68963, "title": "Suggest correct raw identifier in case of typo", "body": "Fixes #68962 ", "labels": ["S-waiting-on-author"], "number_of_comments": 16, "created_at": "2020-02-08 17:46:31", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 1, "hooray": 0}}, "562053400": {"author_username": "olegnn", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68962, "title": "Incorrect raw identifier variable name help suggestion", "body": "Incorrect hint for variable with a similar name defined using raw identifiers\r\n```rust\r\nfn main() {\r\n    let r#final = 1;\r\n    r#fina;\r\n}\r\n\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6214770563a002ca14cd236cc19f14c0))\r\n\r\nErrors:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nerror[E0425]: cannot find value `fina` in this scope\r\n --> src/main.rs:3:5\r\n  |\r\n3 |     r#fina;\r\n  |     ^^^^^^ help: a local variable with a similar name exists: `final`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0425`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```\r\n\r\nShould be `help: a local variable with a similar name exists: r#final`", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-08 17:42:38", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562049433": {"author_username": "bjorn3", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68959, "title": "Cleanup debuginfo generation a bit", "body": "This removes an no longer necessary hack. This also uses `CrateDebugContext` in favor of `CodegenCx` in debuginfo generation.", "labels": ["S-waiting-on-author"], "number_of_comments": 5, "created_at": "2020-02-08 17:14:14", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562014551": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68955, "title": "Audit src/rustllvm/RustWrapper.cpp for C APIs that are now in upstream LLVM.", "body": "Specifically, functions which are implemented in the oldest supported LLVM version.\r\n\r\nWe can also consider to polyfill some functions that are available in our fork, but not in some older supported version, using the same name and signature, instead of our own.\r\n\r\ncc @alexcrichton @nagisa @nikic @hanna-kruppe ", "labels": ["A-LLVM", "C-cleanup", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-08 12:45:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562011428": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68953, "title": "Switch to LLVM{Get,Set}CurrentDebugLocation2.", "body": "I'm still not fully sure what's going on, but see https://github.com/llvm/llvm-project/commit/cce47418c93bcd178379fa8c4df5c3327bc19802.\r\n\r\nWe would probably have to polyfill it on versions that don't have those APIs.", "labels": ["A-LLVM", "A-debuginfo", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-08 12:14:35", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562010500": {"author_username": "faern", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68952, "title": "Stabilize assoc_int_consts associated int/float constants", "body": "The next step in RFC https://github.com/rust-lang/rfcs/pull/2700 (tracking issue #68490). Stabilizing the associated constants that were added in #68325.\r\n\r\n* Stabilize all constants under the `assoc_int_consts` feature flag.\r\n* Update documentation on old constants to say they are soft-deprecated and the new ones should be preferred.\r\n* Update documentation examples to use new constants.\r\n* Remove `uint_macro` and use `int_macro` for all integer types since the macros were identical anyway.\r\n\r\nr? @LukasKalbertodt", "labels": ["S-waiting-on-review", "T-libs", "disposition-merge", "final-comment-period", "needs-fcp", "relnotes"], "number_of_comments": 8, "created_at": "2020-02-08 12:05:47", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562008533": {"author_username": "Disasm", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68951, "title": "Compile error due to the wrong literal data type", "body": "<!--\r\nThank you for filing a bug report! \ud83d\udc1b Please provide a short summary of the bug,\r\nalong with any information you feel relevant to replicating the bug.\r\n-->\r\n\r\nI tried this code:\r\n\r\n```rust\r\nfn main() {\r\n    let array = [0x42u8; 10];\r\n    for b in &array {\r\n        let lo = b & 0xf;\r\n        let hi = (b >> 4) & 0xf;\r\n    }\r\n}\r\n```\r\n[Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=7558b47acf4942b543c5d8bf5a2808cb)\r\n\r\nI expected to see this happen: it should be compiled\r\n\r\nInstead, this happened: \r\n```\r\nerror[E0277]: no implementation for `u8 & i32`\r\n --> src/main.rs:5:27\r\n  |\r\n5 |         let hi = (b >> 4) & 0xf;\r\n  |                           ^ no implementation for `u8 & i32`\r\n  |\r\n  = help: the trait `std::ops::BitAnd<i32>` is not implemented for `u8`\r\n```\r\n\r\n### Meta\r\n<!--\r\nIf you're using the stable version of the compiler, you should also check if the\r\nbug also exists in the beta or nightly versions.\r\n-->\r\n\r\n`rustc --version --verbose`:\r\n```\r\nrustc 1.41.0 (5e1a79984 2020-01-27)\r\nbinary: rustc\r\ncommit-hash: 5e1a799842ba6ed4a57e91f7ab9435947482f7d8\r\ncommit-date: 2020-01-27\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.41.0\r\nLLVM version: 9.0\r\n```\r\nThe same happens on beta and nightly.\r\n\r\n<!--\r\nInclude a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\r\nenvironment. E.g. `RUST_BACKTRACE=1 cargo build`.\r\n-->\r\n<details><summary>Backtrace</summary>\r\n<p>\r\n\r\n```\r\nCompiling playground v0.0.1 (/playground)\r\nerror[E0277]: no implementation for `u8 & i32`\r\n --> src/main.rs:5:27\r\n  |\r\n5 |         let hi = (b >> 4) & 0xf;\r\n  |                           ^ no implementation for `u8 & i32`\r\n  |\r\n  = help: the trait `std::ops::BitAnd<i32>` is not implemented for `u8`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0277`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n\r\n</p>\r\n</details>\r\n", "labels": ["A-inference", "C-bug", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-08 11:46:36", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "562000689": {"author_username": "crlf0710", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68950, "title": "Strange borrowing issue in inherent async method.", "body": "Not sure whether it's a bug, but it is indeed strange...\r\n```rust\r\nstruct A;\r\n// this compiles\r\nfn test(s: &mut A, arg: &str, handler: Box<dyn Fn() + 'static>) {\r\n        \r\n}\r\n// this doesn't\r\nimpl A {\r\n    async fn test2(&mut self, arg: &str, handler: Box<dyn Fn() + 'static>) {\r\n        \r\n    }\r\n}\r\n```\r\n`test2` errors with:\r\n```\r\nerror[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\r\n  --> src/lib.rs:8:76\r\n   |\r\n8  |     async fn test2(&mut self, arg: &str, handler: Box<dyn Fn() + 'static>) {\r\n   |                                                                            ^\r\n   |\r\n```", "labels": ["A-async-await", "AsyncAwait-OnDeck", "AsyncAwait-Triaged", "C-bug", "T-compiler"], "number_of_comments": 3, "created_at": "2020-02-08 10:25:17", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561969547": {"author_username": "Zoxc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68944, "title": "Use queries for the HIR map", "body": "r? @eddyb cc @michaelwoerister ", "labels": ["S-waiting-on-author"], "number_of_comments": 68, "created_at": "2020-02-08 04:41:48", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561966905": {"author_username": "ecstatic-morse", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68943, "title": "Skip `Drop` terminators for enum variants without drop glue", "body": "Split out from #68528.\r\n\r\nWhen doing drop elaboration for an `enum` that may or may not be moved out of (an open drop), we check the discriminant of the `enum` to see whether the live variant has any drop flags and then check the drop flags to see whether we need to drop each field. Sometimes, however, the live\r\nvariant has no move paths and thus no drop flags. In this case, we still emit a drop terminator\r\nfor the entire enum after checking the enum discriminant. This drop shim will check the discriminant of the enum *again* and then drop the fields of the active variant. If the active variant has no drop glue, nothing will be done.\r\n\r\nThis commit skips emitting the drop terminator during drop elaboration when the \"otherwise\" variants, those without move paths, have no drop glue. A common example of this scenario is when an `Option` is moved from, since `Option::None` never needs drop glue. Below is a fragment the pre-codegen CFG for `Option::unwrap_or` in which we check the drop flag (`_5`) for `self` (`_1`), before and after the change.\r\n\r\nBefore:\r\n\r\n![image](https://user-images.githubusercontent.com/29463364/74078927-52942380-49e5-11ea-8e34-4b9d6d94ef25.png)\r\n\r\nAfter:\r\n\r\n![image](https://user-images.githubusercontent.com/29463364/74078945-78b9c380-49e5-11ea-8302-b043c4a7515a.png)\r\n\r\nThis change doesn't do much on its own, but it is a prerequisite to get the perf gains from #68528.\r\n\r\ncc @arielb1 ", "labels": ["S-waiting-on-review"], "number_of_comments": 6, "created_at": "2020-02-08 04:10:37", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561953678": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68941, "title": "Properly handle Spans that reference imported SourceFiles", "body": "Previously, metadata encoding used DUMMY_SP to represent any spans that\r\nreferenced an 'imported' SourceFile - e.g. a SourceFile from an upstream\r\ndependency. This currently has no visible consequences, since these\r\nkinds of spans don't currently seem to be emitted anywhere. However,\r\nthere's no reason that we couldn't start using such spans in\r\ndiagnostics.\r\n\r\nThis PR changes how we encode and decode spans in crate metadata. We\r\nencode spans in one of two ways:\r\n\r\n* 'Local' spans, which reference non-imported SourceFiles, are encoded\r\n  exactly as before.\r\n* 'Foreign' spans, which reference imported SourceFiles, are encoded\r\n  with the CrateNum of their 'originating' crate. Additionally, their\r\n'lo' and 'high' values are rebased on top of the 'originating' crate,\r\nwhich allows them to be used with the SourceMap data encoded for that\r\ncrate.\r\n\r\nTo support this change, I've also made the following modifications:\r\n\r\n* `DefId` and related structs are now moved to `rustc_span`. This allows\r\n  us to use a `CrateNum` inside `SourceFile`. `CrateNum` has special\r\nhandling during deserialization (it gets remapped to be the proper\r\n`CrateNum` from the point of view of the current compilation session),\r\nso using a `CrateNum` instead of a plain integer 'workaround type' helps\r\nto simplify deserialization.\r\n* The `ExternalSource` enum is renamed to `ExternalSourceKind`. There is\r\nnow a struct called `ExternalSource`, which holds an\r\n`ExternalSourceKind` along with the original line number information for\r\nthe file. This is used during `Span` serialization to rebase spans onto\r\ntheir 'owning' crate.", "labels": ["S-waiting-on-review"], "number_of_comments": 10, "created_at": "2020-02-08 02:02:00", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561943747": {"author_username": "ecstatic-morse", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68940, "title": "Remove `qualify_min_const_fn` pass", "body": "Having two MIR const-checking passes is confusing. This PR unifies `qualify_min_const_fn` and `check_consts`.\r\n\r\nAll checks from `qualify_min_const_fn` that were not already implemented in `check_consts` have been assigned a structured error. Unfortunately, this will require a lot of changes to expected test output. This is because `qualify_min_const_fn` bailed out after the first error was found, while `check_consts` reports *all* errors in the function.\r\n\r\ncc @rust-lang/wg-const-eval ", "labels": ["S-waiting-on-author"], "number_of_comments": 3, "created_at": "2020-02-08 00:57:49", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 2}}, "561837689": {"author_username": "tmandry", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68936, "title": "Tests in panic=abort can hang if test spawns a subprocess", "body": "If a test (running in a subprocess, because panic=abort) spawns a sub-subprocess which inherits its stdout or stderr handles, and the sub-subprocess does not exit when the test does, the test framework will hang. This is because [`wait_with_output`](https://github.com/rust-lang/rust/blob/fb29dfcc9ada6ed10308b6e7f405569f61a9af0b/src/libstd/process.rs#L1469-L1491) waits for all stdio handles to be closed.\r\n\r\n```\r\nlibtest runner         (waits for unit test stdio to close)\r\n       |\r\n       |  Stdio::piped\r\n       |\r\nunit test process      (exits, but stdio is now shared with subproc)\r\n      ||\r\n      ||  Stdio::inherit\r\n      ||\r\n\"leaked\" subprocess    (sticks around forever)\r\n```\r\n\r\nSome tests spawn subprocesses, and it can be hard (particularly with panic=abort) to ensure that they are all cleaned up when the test succeeds or fails. In these cases, it would be best not to hang. Hanging is unexpected, and hard to debug.", "labels": ["A-libtest", "C-bug", "T-libs"], "number_of_comments": 1, "created_at": "2020-02-07 19:49:00", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561748612": {"author_username": "axos88", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68934, "title": "Borrow scope for pattern matches - again", "body": "This issue seems to be similar to [this one](https://stackoverflow.com/questions/23328702/rust-cannot-move-out-of-self-because-it-is-borrowed-error), but the referenced issue #6379, does not solve it:\r\n\r\n[playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=a80be0555b914552ed2071ebbf642610)\r\n\r\n\r\n```\r\nenum Either<A,B> {\r\n    Left(A),\r\n    Right(B)\r\n}\r\n\r\nenum Tree<'a, A, B> {\r\n    ALeaf(A),\r\n    BLeaf(B),\r\n    ABranch(&'a mut Tree<'a, A, B>, A),\r\n    BBranch(&'a mut Tree<'a, A, B>, B)\r\n}\r\n\r\nimpl<'a, A: PartialOrd, B> Tree<'a, A ,B> {\r\n    fn deep_fetch(&mut self, value: Either<A, B>) -> Result<&mut Self, (&mut Self, Either<A,B>)> {\r\n        match (self, value) {\r\n            (Tree::ABranch(ref mut a, ref v), Either::Left(vv)) if v > &vv => {\r\n                a.deep_fetch(Either::Left(vv))\r\n            }\r\n\r\n            (this, _v) => Err((this, _v))\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n```\r\n Compiling playground v0.0.1 (/playground)\r\nerror[E0505]: cannot move out of `_` because it is borrowed\r\n  --> src/lib.rs:20:14\r\n   |\r\n14 |     fn deep_fetch(&mut self, value: Either<A, B>) -> Result<&mut Self, (&mut Self, Either<A,B>)> {\r\n   |                   - let's call the lifetime of this reference `'1`\r\n15 |         match (&mut *self, value) {\r\n16 |             (Tree::ABranch(ref mut a, ref v), Either::Left(vv)) if v > &vv => {\r\n   |                            --------- borrow of value occurs here\r\n17 |                 a.deep_fetch(Either::Left(vv))\r\n   |                 ------------------------------ returning this value requires that borrow lasts for `'1`\r\n...\r\n20 |             (this, _v) => Err((this, _v))\r\n   |              ^^^^ move out of value occurs here\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0505`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```", "labels": ["NLL-polonius"], "number_of_comments": 4, "created_at": "2020-02-07 16:40:03", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561676405": {"author_username": "luser", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68931, "title": "Confusing additional warnings when hitting bindings_with_variant_name", "body": "We're working through a Rust training from Ferrous at my company and one of my colleagues wrote some code that hit the `bindings_with_variant_name` warning. A reduced testcase looks like ([on playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=56cdb3e0474225c306c8a1ccd1272e3c)):\r\n```rust\r\npub enum E {\r\n    One,\r\n    Two,\r\n}\r\n\r\npub fn f(e: E) -> u32 {\r\n    match e {\r\n        One => 1,\r\n        Two => 2,\r\n    }\r\n}\r\n``` \r\n\r\nIf you build this code you get the good `bindings_with_variant_name` warnings and then a slew of other warnings. My colleague got lost in the sea of warnings and didn't notice the ones at the top that explained the problem directly:\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nwarning[E0170]: pattern binding `One` is named the same as one of the variants of the type `E`\r\n --> src/lib.rs:8:9\r\n  |\r\n8 |         One => 1,\r\n  |         ^^^ help: to match on the variant, qualify the path: `E::One`\r\n  |\r\n  = note: `#[warn(bindings_with_variant_name)]` on by default\r\n\r\nwarning[E0170]: pattern binding `Two` is named the same as one of the variants of the type `E`\r\n --> src/lib.rs:9:9\r\n  |\r\n9 |         Two => 2,\r\n  |         ^^^ help: to match on the variant, qualify the path: `E::Two`\r\n\r\nwarning: unreachable pattern\r\n --> src/lib.rs:9:9\r\n  |\r\n8 |         One => 1,\r\n  |         --- matches any value\r\n9 |         Two => 2,\r\n  |         ^^^ unreachable pattern\r\n  |\r\n  = note: `#[warn(unreachable_patterns)]` on by default\r\n\r\nwarning: unused variable: `One`\r\n --> src/lib.rs:8:9\r\n  |\r\n8 |         One => 1,\r\n  |         ^^^ help: consider prefixing with an underscore: `_One`\r\n  |\r\n  = note: `#[warn(unused_variables)]` on by default\r\n\r\nwarning: unused variable: `Two`\r\n --> src/lib.rs:9:9\r\n  |\r\n9 |         Two => 2,\r\n  |         ^^^ help: consider prefixing with an underscore: `_Two`\r\n\r\nwarning: variable `One` should have a snake case name\r\n --> src/lib.rs:8:9\r\n  |\r\n8 |         One => 1,\r\n  |         ^^^ help: convert the identifier to snake case (notice the capitalization): `one`\r\n  |\r\n  = note: `#[warn(non_snake_case)]` on by default\r\n\r\nwarning: variable `Two` should have a snake case name\r\n --> src/lib.rs:9:9\r\n  |\r\n9 |         Two => 2,\r\n  |         ^^^ help: convert the identifier to snake case: `two`\r\n\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.55s\r\n```\r\n\r\nIt'd be great if we could suppress those latter warnings in this case since we've already told the user what the exact problem is.\r\n\r\ncc @estebank @skade ", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-07 14:39:09", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561595993": {"author_username": "dragostis", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68926, "title": "Slow compilation", "body": "Using nested tuples in this [example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=c496ff547e257ddbd241e59d10dbd7b4) leads to painfully long compile times:\r\n\r\n```rust\r\nuse rayon::prelude::*;\r\n\r\nfn main() {\r\n    let vec0 = vec![];\r\n    let vec1 = vec![];\r\n    let vec2 = vec![];\r\n    let vec3 = vec![];\r\n    let vec4 = vec![];\r\n    let vec5 = vec![];\r\n    let vec6 = vec![];\r\n    let vec7 = vec![];\r\n    \r\n    (vec0,\r\n    (vec1,\r\n    (vec2,\r\n    (vec3,\r\n    (vec4,\r\n    (vec5,\r\n    (vec6,\r\n    (vec7)))))))).par_extend((1u32..10).into_par_iter().map(|n| (n, (n, (n, (n, (n, (n, (n, n)))))))));\r\n}\r\n```", "labels": ["E-needs-mcve", "I-compiletime", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-07 11:59:45", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561591031": {"author_username": "silwol", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68925, "title": "Different NaN types on mipsel and mips64el than on most other architectures", "body": "The following tests fail on mipsel and mips64el architectures while succeeding most others.\r\n```rust\r\n#[cfg(test)]\r\nmod tests {\r\n    #[test]\r\n    fn min() {\r\n        assert_eq!(1f64.min(std::f64::NAN), 1f64);\r\n    }\r\n    #[test]\r\n    fn max() {\r\n        assert_eq!(1f64.max(std::f64::NAN), 1f64);\r\n    }\r\n}\r\n```\r\nIt succeeded on mipsel up to stable 1.36.0 rustc, and started failing in 1.37.0 and newer. I'll attempt to use [cargo-bisect-rustc](https://github.com/rust-lang/cargo-bisect-rustc) track down the exact nightly version that introduced the change (might take some time because it's a qemu vm that is rather slow).\r\n\r\nhttps://github.com/rust-lang/rust/issues/52897#issuecomment-582514493 was where the initial discussion started, but it seems to be worth a separate issue instead of creating noise there.\r\n\r\nIt looks as if the failing platforms have a signaling NAN (sNAN) in opposite to the succeeding ones with a quiet NAN (qNAN).", "labels": ["C-bug", "O-MIPS", "T-compiler", "T-libs"], "number_of_comments": 6, "created_at": "2020-02-07 11:48:43", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561582092": {"author_username": "ssomers", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68924, "title": "Benchmarking no longer works after rust-lang/rust#68708", "body": "#68708 suspended the ability to benchmark liballoc (and probably others, but not everything). `x.py bench` (with or without  --stage 0) now lists oodles of errors starting with:\r\n```\r\nCompiling getrandom v0.1.14\r\nerror: duplicate lang item in crate `core` (which `rustc_std_workspace_core` depends on): `bool`.\r\n  |\r\n  = note: first defined in crate `core` (which `getrandom` depends on)\r\n```\r\nIt's still possible though to build and test benchmarks with say `x.py test --stage 0 --no-doc`.", "labels": ["A-rustbuild", "C-bug"], "number_of_comments": 1, "created_at": "2020-02-07 11:29:18", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561580522": {"author_username": "jonas-schievink", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68923, "title": "Generators should be able to implement `for<'a> Generator<&'a mut T>`", "body": "With https://github.com/rust-lang/rust/pull/68524, the `Generator` trait has gained a type parameter for the resume argument. Currently, this parameter will not be inferred to a type with late-bound regions. In some cases, this is required for soundness. For example, this generator stores the resume argument across a `yield`, which means that it can not accept arbitrary lifetimes in it:\r\n\r\n```rust\r\nlet gen = |arg: &mut bool| {\r\n    yield ();\r\n    *arg = true;\r\n};\r\n```\r\n\r\nThis generator ends up implementing `Generator<&'x mut bool>` with a specific `'x`, not `for<'x> Generator<&'x mut bool>`.\r\n\r\nHowever, if the resume argument *doesn't* get stored inside the generator state, it should be fine for the generator to implement `for<'x> Generator<&'x mut bool>` instead.\r\n\r\nThis is already how closures behave, since they can also store their arguments inside upvars, so it shouldn't be terribly difficult to extend this to generators. It would be good to come up with lots of test cases beforehand though (perhaps inspired by the tests for closures).", "labels": ["A-generators", "C-enhancement", "F-generators", "T-compiler"], "number_of_comments": 7, "created_at": "2020-02-07 11:25:56", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561565665": {"author_username": "jonas-schievink", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68922, "title": "Rewrite `box_region.rs` to use generator resume arguments", "body": "[`box_region.rs`](https://github.com/rust-lang/rust/blob/3d8778d767f0dde6fe2bc9459f21ead8e124d8cb/src/librustc_data_structures/box_region.rs) makes use of generators, and passes arguments into them via thread-local storage. Now that https://github.com/rust-lang/rust/pull/68524 has landed, this can be rewritten to use generator resume arguments instead, which is much cleaner and possibly also faster.", "labels": ["A-generators", "C-cleanup", "I-compiletime", "T-compiler"], "number_of_comments": 2, "created_at": "2020-02-07 10:55:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561524885": {"author_username": "iliakonnov", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68921, "title": "ICE with proc_macro_attribute on pub(super) function in module", "body": "Compiler panicks when there is function with both `#[proc_macro_attribute]` and `pub(super)` defined in module (not in the root of the crate).\r\n\r\n`lib.rs`:\r\n```rust\r\nmod m;\r\n```\r\n\r\n`m.rs`:\r\n```rust\r\n// This function makes compiler panick:\r\n#[proc_macro_attribute]\r\npub(super) fn pub_super() {}\r\n```\r\n\r\nAll following functions successfully does not compile (which is fine):\r\n```rust\r\n// error: functions tagged with `#[proc_macro_attribute]` must currently reside in the root of the crate\r\n\r\n#[proc_macro_attribute]\r\npub(crate) fn pub_crate() {}\r\n\r\n#[proc_macro_attribute]\r\npub fn just_pub() {}\r\n\r\n#[proc_macro_attribute]\r\nfn nothing() {}\r\n```\r\n\r\n```\r\n$ rustc --crate-type proc-macro lib.rs\r\n\r\nthread 'rustc' panicked at 'path resolved multiple times (PartialRes { base_res: Def(Mod, DefId(0:0)), unresolved_segments: 0 } before, PartialRes { base_res: Def(Mod, DefId(0:0)), unresolved_segments: 0 } now)', src/librustc_resolve/lib.rs:2414:13\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\nerror: internal compiler error: unexpected panic\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-nightly (58b834344 2020-02-05) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: --crate-type proc-macro\r\n```\r\n<details>\r\n  <summary>RUST_BACKTRACE=1</summary>\r\n\r\n```\r\nthread 'rustc' panicked at 'path resolved multiple times (PartialRes { base_res: Def(Mod, DefId(0:0)), unresolved_segments: 0 } before, PartialRes { base_res: Def(Mod, DefId(0:0)), unresolved_segments: 0 } now)', src/librustc_resolve/lib.rs:2414:13\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1428\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:474\r\n  12: rust_begin_unwind\r\n             at src/libstd/panicking.rs:378\r\n  13: std::panicking::begin_panic_fmt\r\n             at src/libstd/panicking.rs:332\r\n  14: rustc_resolve::build_reduced_graph::BuildReducedGraphVisitor::resolve_visibility_speculative\r\n  15: rustc_resolve::build_reduced_graph::BuildReducedGraphVisitor::define_macro\r\n  16: <rustc_resolve::build_reduced_graph::BuildReducedGraphVisitor as syntax::visit::Visitor>::visit_item\r\n  17: syntax::visit::walk_item\r\n  18: <rustc_resolve::build_reduced_graph::BuildReducedGraphVisitor as syntax::visit::Visitor>::visit_item\r\n  19: syntax::visit::walk_item\r\n  20: <rustc_resolve::build_reduced_graph::BuildReducedGraphVisitor as syntax::visit::Visitor>::visit_item\r\n  21: rustc_expand::expand::AstFragment::visit_with\r\n  22: rustc_resolve::macros::<impl rustc_expand::base::Resolver for rustc_resolve::Resolver>::visit_ast_fragment_with_placeholders\r\n  23: rustc_expand::expand::MacroExpander::collect_invocations\r\n  24: rustc_expand::expand::MacroExpander::fully_expand_fragment\r\n  25: rustc_expand::expand::MacroExpander::expand_crate\r\n  26: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  27: rustc_interface::passes::configure_and_expand_inner\r\n  28: rustc_interface::passes::configure_and_expand::{{closure}}\r\n  29: rustc_data_structures::box_region::PinnedGenerator<I,A,R>::new\r\n  30: rustc_interface::passes::configure_and_expand\r\n  31: rustc_interface::queries::Queries::expansion\r\n  32: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  33: scoped_tls::ScopedKey<T>::set\r\n  34: syntax::attr::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-nightly (58b834344 2020-02-05) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: --crate-type proc-macro\r\n\r\nquery stack during panic:\r\nend of query stack\r\n```\r\n\r\n`RUST_BACKTRACE=full` log is available here: https://gist.github.com/iliakonnov/8dbf25041e46c3861f4e1cf2237315f8#file-backtrace-full-log\r\n</details>\r\n\r\nI expected to see ``error: functions tagged with `#[proc_macro_attribute]` must currently reside in the root of the crate`` instead of ICE\r\n```\r\n$ rustc --version --verbose\r\nrustc 1.43.0-nightly (58b834344 2020-02-05)\r\nbinary: rustc\r\ncommit-hash: 58b834344fc7b9185e7a50db1ff24e5eb07dae5e\r\ncommit-date: 2020-02-05\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\nUPD: Also reproduces without `--crate-type proc-macro`. Just `rustc lib.rs` is enough", "labels": ["A-macros", "C-bug", "I-ICE", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-07 09:40:26", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 1, "hooray": 0}}, "561383529": {"author_username": "timvermeulen", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68915, "title": "Fix bugs in Peekable and Flatten when using non-fused iterators", "body": "I fixed a couple of bugs with regard to the `Peekable` and `Flatten`/`FlatMap` iterators when the underlying iterator isn't fused. For testing, I also added a `NonFused` iterator wrapper that panics when `next` or `next_back` is called on an iterator that has returned `None` before, which will hopefully make it easier to spot these mistakes in the future.\r\n\r\n### Peekable\r\n\r\n`Peekable::next_back` was implemented as\r\n```rust\r\nself.iter.next_back().or_else(|| self.peeked.take().and_then(|x| x))\r\n```\r\nwhich is incorrect because when the `peeked` field is `Some(None)`, then `None` has already been returned from the inner iterator and what it returns from `next_back` can no longer be relied upon. `test_peekable_non_fused` tests this.\r\n\r\n### Flatten\r\n\r\nWhen a `FlattenCompat` instance only has a `backiter` remaining (i.e. `self.frontiter` is `None` and `self.iter` is empty), then `next` will call `self.iter.next()` every time, so the `iter` field needs to be fused. I fixed it by giving it the type `Fuse<I>` instead of `I`, I think this is the only way to fix it. `test_flatten_non_fused_outer` tests this.\r\n\r\nFurthermore, previously `FlattenCompat::next` did not set `self.frontiter` to `None` after it returned `None`, which is incorrect when the inner iterator type isn't fused. I just delegated it to `try_fold` because that already handles it correctly. `test_flatten_non_fused_inner` tests this.\r\n\r\nr? @scottmcm ", "labels": ["S-waiting-on-review"], "number_of_comments": 2, "created_at": "2020-02-07 02:31:11", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561245963": {"author_username": "oconnor663", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68905, "title": "`is_x86_feature_detected!(\"avx512f\")` fails to build on nightly", "body": "The following program builds and runs on stable but fails to build on nightly:\r\n\r\n```rust\r\nfn main() {\r\n    dbg!(is_x86_feature_detected!(\"avx512f\"));\r\n}\r\n```\r\n\r\nHere's the build error on `rustc 1.43.0-nightly (58b834344 2020-02-05)`:\r\n\r\n```\r\nerror[E0658]: use of unstable library feature 'stdsimd'\r\n --> src/main.rs:2:10\r\n  |\r\n2 |     dbg!(is_x86_feature_detected!(\"avx512f\"));\r\n  |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |\r\n  = note: for more information, see https://github.com/rust-lang/rust/issues/27731\r\n  = help: add `#![feature(stdsimd)]` to the crate attributes to enable\r\n  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\r\n```\r\n\r\nBut note that if I replace `\"avx512f\"` with `\"avx2\"`, the error goes away.", "labels": ["I-nominated", "T-lang", "T-libs", "regression-from-stable-to-nightly"], "number_of_comments": 14, "created_at": "2020-02-06 20:17:38", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561239305": {"author_username": "vallentin", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68903, "title": "Command causes subsequent ANSI codes to render incorrectly", "body": "I'm experiencing some odd behavior with ANSI codes and `std::process::Command`. The ANSI codes render differently after having executed a command.\r\n\r\n1. In Git Bash using `\\u{1b}[2m` (gray/dim) does not render at all, which is understanble as it might not be supported. However, after executing some command, then it renders correctly.\r\n2. On the other hand, in CMD and PowerShell, then after running some command, then the ANSI codes appear *literally* in the output. (Which is the actual issue.)\r\n\r\nThe command being executed seem to be important, as changing it either results in the issue being triggered or no change at all.\r\n\r\nBoth `spawn() + wait()` and `status()` behave the same. Whereas `output()` does not trigger the issue. So I'm assuming the command is somehow able to affect the inherited stdin/stdout/stderr, causing the issue to persist after the command has finished.\r\n\r\n## Git Bash\r\n\r\nIt's understandable that some ANSI code might not be supported by my terminal. But it's quite odd, that executing some command using `std::process::Command`, results in it rendering correctly after.\r\n\r\n![command-git-bash](https://user-images.githubusercontent.com/17464404/73971627-860c7a80-491f-11ea-89df-c51868826834.png)\r\n\r\n## CMD\r\n\r\nHowever, the real issue is in CMD (and PowerShell), where every ANSI code renders *literally* in the output, after having executed some command.\r\n\r\n![command-cmd](https://user-images.githubusercontent.com/17464404/73971636-89076b00-491f-11ea-9da1-8c44649a2470.png)\r\n\r\n## Minimal, Reproducible Example\r\n\r\nI also tried using the [clicolors-control](https://crates.io/crates/clicolors-control) crate to enable/disable ANSI colors. However the issue still persists, and I originally submitted the issue there earlier mitsuhiko/clicolors-control#15.\r\n\r\n```rust\r\nuse std::process::Command;\r\n\r\nfn main() {\r\n    println!(\"Foo \\u{1b}[36mBar\\u{1b}[0m Baz\"); // Cyan\r\n    println!(\"Foo \\u{1b}[2mBar\\u{1b}[0m Baz <- Not colored\"); // Dim\r\n    println!(\"Foo \\u{1b}[31mBar\\u{1b}[0m Baz\"); // Red\r\n    println!();\r\n\r\n    // ANSI codes render incorrectly if any of these commands are executed\r\n    Command::new(\"git\").arg(\"log\").status().unwrap();\r\n    // Command::new(\"git\").arg(\"diff\").status().unwrap();\r\n\r\n    // However, ANSI codes are not affected if any of these commands are executed\r\n    // Command::new(\"git\").arg(\"--version\").status().unwrap();\r\n    // Command::new(\"cargo\").arg(\"--version\").status().unwrap();\r\n    // Command::new(\"cargo\").arg(\"build\").status().unwrap();\r\n\r\n    println!();\r\n    println!(\"Foo \\u{1b}[36mBar\\u{1b}[0m Baz\"); // Cyan\r\n    println!(\"Foo \\u{1b}[2mBar\\u{1b}[0m Baz\"); // Dim\r\n    println!(\"Foo \\u{1b}[31mBar\\u{1b}[0m Baz\"); // Red\r\n    println!();\r\n}\r\n```\r\n\r\n## Python\r\n\r\nI thought it might be my terminal being weird. So I test the equivalent in Python, and it rendered correctly.\r\n\r\n![command-python](https://user-images.githubusercontent.com/17464404/73974074-00d79480-4924-11ea-98b9-f427d1cbd9ae.png)\r\n\r\n```python\r\nfrom subprocess import run\r\n\r\nprint(\"Foo \\u001b[36mBar\\u001b[0m Baz\") # Cyan\r\nprint(\"Foo \\u001b[2mBar\\u001b[0m Baz\") # Dim\r\nprint(\"Foo \\u001b[31mBar\\u001b[0m Baz\") # Red\r\nprint()\r\n\r\nrun([\"git\", \"log\"])\r\n\r\nprint()\r\nprint(\"Foo \\u001b[36mBar\\u001b[0m Baz\") # Cyan\r\nprint(\"Foo \\u001b[2mBar\\u001b[0m Baz\") # Dim\r\nprint(\"Foo \\u001b[31mBar\\u001b[0m Baz\") # Red\r\n```\r\n\r\n-----\r\n\r\nI've tested in both debug and release mode, as well as stable and nightly. The issue remains the same.\r\n\r\n```\r\n$ rustc --version --verbose\r\nrustc 1.41.0 (5e1a79984 2020-01-27)\r\nbinary: rustc\r\ncommit-hash: 5e1a799842ba6ed4a57e91f7ab9435947482f7d8\r\ncommit-date: 2020-01-27\r\nhost: x86_64-pc-windows-msvc\r\nrelease: 1.41.0\r\nLLVM version: 9.0\r\n\r\n$ cargo --version --verbose\r\ncargo 1.41.0 (626f0f40e 2019-12-03)\r\nrelease: 1.41.0\r\ncommit-hash: 626f0f40efd32e6b3dbade50cd53fdfaa08446ba\r\ncommit-date: 2019-12-03\r\n```", "labels": ["C-bug", "T-libs"], "number_of_comments": 6, "created_at": "2020-02-06 20:03:55", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561201494": {"author_username": "kinseytamsin", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68899, "title": "Add Display and Error impls for proc_macro::LexError", "body": "This should allow LexError to play much nicer with the `?` operator.\r\n\r\nFixes #68896.\r\n\r\n(I'm not sure if I did the stability attributes right, so if I need to change them, please let me know!)", "labels": ["S-waiting-on-review", "T-libs", "disposition-merge", "finished-final-comment-period"], "number_of_comments": 7, "created_at": "2020-02-06 18:48:43", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561114417": {"author_username": "kinseytamsin", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68896, "title": "proc_macro::LexError doesn't implement std::error::Error", "body": "`LexError`, the error type used by `proc_macro::TokenStream`'s `FromStr` implementation, doesn't implement `std::error::Error`. This makes it very un-ergonomic to work with when trying to use the `?` operator to propagate errors in a function that returns a non-specific error type like `Box<dyn std::error::Error>` or the `Error` type provided by the [`anyhow` crate](https://crates.io/crates/anyhow).\r\n\r\nI wrote the following code to demonstrate what I mean:\r\n\r\n```rust\r\nextern crate proc_macro;\r\n\r\nuse std::error::Error;\r\nuse proc_macro::TokenStream;\r\n\r\nfn returns_result_with_nonspecific_error() -> Result<TokenStream, Box<dyn Error>> {\r\n    Ok(r#\"println!(\"hello, world\");\"#.parse()?)\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=4c5735f3e4290a889f1adb872eea98fe))\r\n\r\nErrors:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nerror[E0277]: the trait bound `proc_macro::LexError: std::error::Error` is not satisfied\r\n --> src/lib.rs:7:46\r\n  |\r\n7 |     Ok(r#\"println!(\"hello, world\");\"#.parse()?)\r\n  |                                              ^ the trait `std::error::Error` is not implemented for `proc_macro::LexError`\r\n  |\r\n  = note: required because of the requirements on the impl of `std::convert::From<proc_macro::LexError>` for `std::boxed::Box<dyn std::error::Error>`\r\n  = note: required by `std::convert::From::from`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0277`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```\r\n\r\nSo while this does feel like an easy PR (and if it is, I plan to submit it!), I just wanted to make sure beforehand that there isn't some good reason that this is the case. I've never really worked with procedural macros at all (I noticed this issue through the [`proc-macro2` crate](https://crates.io/crates/proc-macro2)) so I'm not sure if there's something special going on here that I'm not aware of. Thanks in advance for the help :)", "labels": ["C-enhancement", "T-libs"], "number_of_comments": 0, "created_at": "2020-02-06 16:10:21", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561110484": {"author_username": "pietroalbini", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68895, "title": "Crater runs for 1.42.0", "body": "cc @rust-lang/release ", "labels": ["S-waiting-on-review"], "number_of_comments": 10, "created_at": "2020-02-06 16:04:16", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "561043536": {"author_username": "XAMPPRocky", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68891, "title": "Update my mailmap entry", "body": "This PR was made using GitHub's UI and it seems that some the unicode for two other people's name was also changed.", "labels": ["S-waiting-on-author"], "number_of_comments": 2, "created_at": "2020-02-06 14:20:54", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560978851": {"author_username": "tanriol", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68887, "title": "provide a way of overriding the MinGW library path", "body": "The recently landed #67429 introduced a heuristic to search for the system MinGW libraries relative to the cross-gcc (used as linker) itself. However, there are systems that do not follow this pattern. For example, on my Gentoo system:\r\n- `/usr/bin/x86_64-w64-mingw32-gcc` is a symlink to `/usr/x86_64-pc-linux-gnu/x86_64-w64-mingw32/gcc-bin/9.2.0/x86_64-w64-mingw32-gcc`\r\n- `/usr/x86_64-w64-mingw32/usr/lib/` is the directory with the actual libraries in the `/usr/x86_64-w64-mingw32` sysroot\r\n\r\nIt would be useful to have a way of overriding the heuristics and informing `rustc` about the correct library path manually. In the current configuration even `RUSTFLAGS=\"-L  /usr/x86_64-w64-mingw32/usr/lib/\"` does not help because the rustc-provided libraries have higher priority.", "labels": ["A-linkage", "C-feature-request", "O-windows-gnu", "T-compiler"], "number_of_comments": 12, "created_at": "2020-02-06 12:23:51", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560920545": {"author_username": "lu-zero", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68885, "title": "Alignment/Memory access problem for the wasm32-wasi target", "body": "[here](https://github.com/lu-zero/testcase-wasi-alloc) a full testcase.\r\n\r\nAny alignment over 64bit seems to cause the problem even I would expect `v128` to require 128bit alignment.", "labels": ["A-codegen", "C-bug", "E-needs-mcve", "O-wasm", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-06 10:32:51", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560909898": {"author_username": "Zoxc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68884, "title": "Make the `type_of` return a generic type for generators", "body": "Fixes https://github.com/rust-lang/rust/issues/67651.\r\n\r\nr? @nikomatsakis ", "labels": ["S-waiting-on-author"], "number_of_comments": 10, "created_at": "2020-02-06 10:14:37", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 1}}, "560804307": {"author_username": "Zoxc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68879, "title": "[do not merge] Try building the compiler with ThinLTO", "body": "r? @ghost", "labels": ["S-waiting-on-author"], "number_of_comments": 2, "created_at": "2020-02-06 06:19:15", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560782959": {"author_username": "estebank", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68877, "title": "On mismatched argument count point at arguments", "body": "", "labels": ["S-waiting-on-bors"], "number_of_comments": 11, "created_at": "2020-02-06 05:09:00", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560776613": {"author_username": "JustAPerson", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68876, "title": "Poor error message when indexing result of dbg!()", "body": "Consider:\r\n```rust\r\nfn main() {\r\n  dbg!(1, 3)[1];\r\n}\r\n```\r\n\r\nOn nightly (2020-02-05) this yields the error:\r\n```\r\nerror[E0608]: cannot index into a value of type `({integer}, {integer})`\r\n --> src/main.rs:2:3\r\n  |\r\n2 |   dbg!(1, 3)[1];\r\n  |   ^^^^^^^^^^^^^ help: to access tuple elements, use: `($ ($ crate :: dbg ! ($ val)), +,).1`\r\n```\r\n\r\nMaybe the `help: to access tuple elements, use` part should either avoid printing the left-hand side of the dot operator, or use the span of the source file like `help: to access tuple elements, use: 'dbg!(1, 3).1'`", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-06 04:47:14", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560766580": {"author_username": "mortonsc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68875, "title": "ICE from associated const in field type of lifetime-parametric struct", "body": "Attempting to build this code generates an ICE ([play](https://play.rust-lang.org/?version=stable&mode=debug&edition=2015&gist=f9cf0a356a8b7b02076522826002d97c)):\r\n\r\n```rust\r\nstruct DataWrapper<'a> {\r\n    data: &'a [u8; Self::SIZE],\r\n}\r\n\r\nimpl DataWrapper<'_> {\r\n    const SIZE: usize = 14;\r\n}\r\n\r\n```\r\n\r\nThe error message, on my machine:\r\n\r\n```\r\n$ rustc src/main.rs --verbose\r\nerror: internal compiler error: src/librustc_mir/borrow_check/universal_regions.rs:762: cannot convert `ReEarlyBound(0, 'a)` to a region vid\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:905:9\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.41.0 running on x86_64-unknown-linux-gnu\r\n\r\nerror: aborting due to previous error\r\n\r\n```\r\n\r\nLooks like it's related to #56445, but the construction that triggers it is different enough that it seems worth posting.\r\n\r\n", "labels": ["A-borrow-checker", "C-bug", "I-ICE", "T-compiler", "glacier"], "number_of_comments": 1, "created_at": "2020-02-06 04:09:21", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560753865": {"author_username": "Riey", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68874, "title": "&str slicing using SliceIndex is slow", "body": "# Summary\r\n\r\nIt seems closure in unwrap_or_else doesn't inlined\r\n\r\nhttps://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src/libcore/str/mod.rs#L1854\r\nhttps://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src/libcore/str/mod.rs#L1921\r\nhttps://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src/libcore/str/mod.rs#L1986\r\n\r\n\r\nI can't make PR because I don't know how can I fix should this code don't use `unwrap_or_else`? or need some patch for optimizer or LLVM?\r\n# Godbolt\r\n\r\nhttps://godbolt.org/z/TBhkjy\r\n\r\n\r\n# Benchmark\r\n\r\n## Code\r\n\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=765da897030741f77b13ce397dc7f882\r\n\r\n## Result\r\n```\r\nrunning 4 tests\r\ntest benches::bar_itself ... bench:         195 ns/iter (+/- 0) = 5261 MB/s\r\ntest benches::bar_long   ... bench:       2,311 ns/iter (+/- 14) = 5374 MB/s\r\ntest benches::foo_itself ... bench:         383 ns/iter (+/- 2) = 2678 MB/s\r\ntest benches::foo_long   ... bench:       4,606 ns/iter (+/- 7) = 2696 MB/s\r\n\r\ntest result: ok. 0 passed; 0 failed; 0 ignored; 4 measured; 0 filtered out\r\n```\r\n", "labels": ["C-enhancement", "I-slow", "T-libs"], "number_of_comments": 2, "created_at": "2020-02-06 03:21:14", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560732667": {"author_username": "cup", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68872, "title": "undefined reference to `__imp___acrt_iob_func'", "body": "The \"under latest MinGW, cannot link with C code using stdout\" issue was closed\r\ntoday. I tried testing with this:\r\n\r\n~~~\r\n$ rustc -V\r\nrustc 1.43.0-nightly (58b834344 2020-02-05)\r\n~~~\r\n\r\nhttps://github.com/rust-lang/rust/commit/58b834344\r\n\r\nbut I am still getting this type of result:\r\n\r\n~~~\r\njson.cpp:(.text.unlikely+0x34): undefined reference to `__imp___acrt_iob_func'\r\n~~~\r\n\r\n@mati865 ?\r\n", "labels": ["A-linkage", "C-bug", "O-windows-gnu", "T-compiler"], "number_of_comments": 22, "created_at": "2020-02-06 01:59:06", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560601777": {"author_username": "is8ac", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68868, "title": "ICE when type parameter and const generic are in wrong order", "body": "```\r\nerror: internal compiler error: src/librustc/traits/codegen/mod.rs:50: Encountered ambiguity selecting `Binder(<u8 as Foo<u16, Scalar(<ZST>): [type error]>>)` during codegen, presuming due to overflow\r\n```\r\nWhen a const generic not in curly braces appears before a type parameter, rustc panics.\r\n\r\n\r\n## Code\r\n```\r\n#![feature(const_generics)]\r\n\r\npub trait Foo<T, const X: usize> {\r\n    fn foo(&self);\r\n}\r\n\r\npub trait Bar<T, const X: usize> {\r\n    fn bar(&self);\r\n}\r\n\r\nimpl<const X: usize> Bar<u32, X> for u32\r\nwhere\r\n    u8: Foo<X, u16>,\r\n    //u8: Foo<u32, X>,\r\n    //u8: Foo<{ X }, u16>,\r\n{\r\n    fn bar(&self) {\r\n        0u8.foo();\r\n    }\r\n}\r\n\r\nfn main() {}\r\n```\r\nReplacing ` u8: Foo<X, u16>` with `u8: Foo<u32, X>` fixes the problem.\r\nReplacing it with `u8: Foo<{ X }, u16>` produces an informative error message.\r\nCommenting out `0u8.foo();` also prevents the ICE.\r\n\r\nThis is not urgent, it is merely a matter of uninformative compiler errors.\r\n\r\n\r\n## Full Logs\r\n```\r\nerror: internal compiler error: src/librustc/traits/codegen/mod.rs:50: Encountered ambiguity selecting `Binder(<u8 as Foo<u16, Scalar(<ZST>): [type error]>>)` during codegen, presuming due to overflow\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:883:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1428\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:474\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc::ty::context::GlobalCtxt::enter_local\r\n  21: rustc::traits::codegen::codegen_fulfill_obligation\r\n  22: rustc::ty::query::__query_compute::codegen_fulfill_obligation\r\n  23: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::codegen_fulfill_obligation>::compute\r\n  24: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  25: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  26: rustc::ty::instance::Instance::resolve\r\n  27: rustc_mir_build::lints::check\r\n  28: rustc::ty::context::GlobalCtxt::enter_local\r\n  29: rustc_mir_build::build::mir_built\r\n  30: rustc::ty::query::__query_compute::mir_built\r\n  31: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  32: rustc_mir::transform::check_unsafety::unsafety_check_result\r\n  33: rustc::ty::query::__query_compute::unsafety_check_result\r\n  34: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  35: rustc_mir::transform::mir_const\r\n  36: rustc::ty::query::__query_compute::mir_const\r\n  37: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  38: rustc_mir::transform::mir_validated\r\n  39: rustc::ty::query::__query_compute::mir_validated\r\n  40: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  41: rustc_mir::borrow_check::mir_borrowck\r\n  42: rustc::ty::query::__query_compute::mir_borrowck\r\n  43: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::mir_borrowck>::compute\r\n  44: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  45: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  46: rustc::ty::<impl rustc::ty::context::TyCtxt>::par_body_owners\r\n  47: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  48: rustc_interface::passes::analysis\r\n  49: rustc::ty::query::__query_compute::analysis\r\n  50: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  51: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  52: rustc::ty::context::tls::enter_global\r\n  53: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  54: scoped_tls::ScopedKey<T>::set\r\n  55: syntax::attr::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-nightly (c9290dcee 2020-02-04) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [codegen_fulfill_obligation] checking if `Foo` fulfills its obligations\r\n#1 [mir_built] processing `<u32 as Bar<u32, X>>::bar`\r\n#2 [unsafety_check_result] processing `<u32 as Bar<u32, X>>::bar`\r\n#3 [mir_const] processing `<u32 as Bar<u32, X>>::bar`\r\n#4 [mir_validated] processing `<u32 as Bar<u32, X>>::bar`\r\n#5 [mir_borrowck] processing `<u32 as Bar<u32, X>>::bar`\r\n#6 [analysis] running analysis passes on this crate\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `bitnn`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n\r\n## Meta\r\n```\r\nrustc --version --verbose\r\nrustc 1.43.0-nightly (c9290dcee 2020-02-04)\r\nbinary: rustc\r\ncommit-hash: c9290dceee2cb6b882b26ec6e294560e51ef0853\r\ncommit-date: 2020-02-04\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.43.0-nightly\r\nLLVM version: 9.0\r\n```\r\n", "labels": ["A-const-generics", "C-bug", "F-const_generics", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 1, "created_at": "2020-02-05 20:10:50", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560562890": {"author_username": "emilio", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68867, "title": "Bad codegen with simple match statement", "body": "The following code:\r\n\r\n```rust\r\ntype CSSFloat = f32;\r\n\r\npub enum ViewportPercentageLength {\r\n    Vw(CSSFloat),\r\n    Vh(CSSFloat),\r\n    Vmin(CSSFloat),\r\n    Vmax(CSSFloat),\r\n}\r\n\r\nimpl ViewportPercentageLength {\r\n    fn try_sum(&self, other: &Self) -> Result<Self, ()> {\r\n        use self::ViewportPercentageLength::*;\r\n        Ok(match (self, other) {\r\n            (&Vw(one), &Vw(other)) => Vw(one + other),\r\n            (&Vh(one), &Vh(other)) => Vh(one + other),\r\n            (&Vmin(one), &Vmin(other)) => Vmin(one + other),\r\n            (&Vmax(one), &Vmax(other)) => Vmax(one + other),\r\n            _ => return Err(()),\r\n        })\r\n    }\r\n}\r\n\r\n#[no_mangle]\r\npub extern \"C\" fn sum_them(\r\n    one: &ViewportPercentageLength,\r\n    other: &ViewportPercentageLength,\r\n    out: &mut ViewportPercentageLength,\r\n) -> bool {\r\n    match one.try_sum(other) {\r\n        Ok(v) => {\r\n            *out = v;\r\n            true\r\n        }\r\n        Err(()) => false,\r\n    }\r\n}\r\n```\r\n\r\nGenerates the following assembly on Rust Nightly when compiled with `-C opt-level=3`:\r\n\r\n```asm\r\nsum_them:\r\n        mov     eax, dword ptr [rdi]\r\n        movss   xmm0, dword ptr [rdi + 4]\r\n        mov     ecx, dword ptr [rsi]\r\n        movss   xmm1, dword ptr [rsi + 4]\r\n        lea     rsi, [rip + .LJTI0_0]\r\n        movsxd  rax, dword ptr [rsi + 4*rax]\r\n        add     rax, rsi\r\n        jmp     rax\r\n.LBB0_1:\r\n        xor     eax, eax\r\n        test    ecx, ecx\r\n        je      .LBB0_8\r\n        ret\r\n.LBB0_3:\r\n        mov     eax, 2\r\n        cmp     ecx, 2\r\n        je      .LBB0_8\r\n.LBB0_9:\r\n        xor     eax, eax\r\n        ret\r\n.LBB0_5:\r\n        mov     eax, 3\r\n        cmp     ecx, 3\r\n        jne     .LBB0_9\r\n.LBB0_8:\r\n        addss   xmm0, xmm1\r\n        mov     dword ptr [rdx], eax\r\n        movss   dword ptr [rdx + 4], xmm0\r\n        mov     al, 1\r\n        ret\r\n.LBB0_7:\r\n        mov     eax, 1\r\n        cmp     ecx, 1\r\n        jne     .LBB0_9\r\n        jmp     .LBB0_8\r\n.LJTI0_0:\r\n        .long   .LBB0_1-.LJTI0_0\r\n        .long   .LBB0_7-.LJTI0_0\r\n        .long   .LBB0_3-.LJTI0_0\r\n        .long   .LBB0_5-.LJTI0_0\r\n```\r\n\r\nGodbolt link: https://rust.godbolt.org/z/JfkEez\r\n\r\nIt seems to generate one branch for each case of the statement, when I would've expected it to look more like:\r\n\r\n```\r\nif one.enum_discriminant != other.enum_discriminant {\r\n    jump to error case\r\n}\r\nwrite enum into outparam with tag = one.error_discriminant and value one.value != other.value\r\n```\r\n\r\ncc @michaelwoerister @heycam ", "labels": ["A-codegen", "A-mir", "I-slow", "T-compiler"], "number_of_comments": 12, "created_at": "2020-02-05 18:52:40", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560520105": {"author_username": "alexpdp7", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68865, "title": "Please reconsider mips32 \"r1\" support", "body": "Hi,\r\n\r\nIn:\r\n\r\nhttps://github.com/rust-lang/rust/pull/48874\r\n\r\n, the mips targets were bumped to use the mips32r2 instruction set. There's a few systems being sold today which use cheap mips32-non-r1 chips, like:\r\n\r\nhttps://retrogame300.com/collections/all\r\nhttps://retromimi.com/products/retro-game-plus\r\n\r\n, etc. They use buildroot-derived operating systems, which adds some complexity to adding a new target to Rust, so I'm wondering if it could be acceptable to add a new target or revert that change, as it would make things simpler to code for such devices.\r\n\r\nCheers,\r\n\r\n\u00c1lex", "labels": ["C-feature-request", "O-MIPS", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-05 17:26:22", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560435580": {"author_username": "jonas-schievink", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68864, "title": "25% compile time increase on beta when building async-std", "body": "On my machine, `cargo build` on https://github.com/async-rs/async-std/commit/1d875836a2302681a395ee44512a518f0222da4a finishes in ~6.75s on stable 1.41.0, but takes at least 8.50s on the current beta (1.42.0-beta.2 (3d2613e2c 2020-02-04)), an increase of ~25%.\r\n\r\nRecent nightlies are still affected, but my perf improvements in https://github.com/rust-lang/rust/pull/68606 and https://github.com/rust-lang/rust/pull/68672 improve things a bit which hides the regression.", "labels": ["A-async-await", "AsyncAwait-OnDeck", "AsyncAwait-Triaged", "C-bug", "E-needs-bisection", "E-needs-mcve", "I-compiletime", "P-high", "T-compiler", "regression-from-stable-to-beta"], "number_of_comments": 6, "created_at": "2020-02-05 15:10:39", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560290336": {"author_username": "djc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68860, "title": "Improve diagnostics for serializing 'static type from Deserialize<'de>", "body": "With this code:\r\n\r\n```rust\r\nuse serde_json;\r\nuse serde::Deserialize;\r\n\r\nfn foo<'de, D>(b: Vec<u8>) where D: Deserialize<'de> {\r\n    let _ = serde_json::from_slice::<D>(b.as_ref()).unwrap();\r\n}\r\n```\r\n\r\nWe get this error message:\r\n\r\n```rust\r\nerror[E0597]: `b` does not live long enough\r\n --> src/lib.rs:5:41\r\n  |\r\n4 | fn foo<'de, D>(b: Vec<u8>) where D: Deserialize<'de> {\r\n  |        --- lifetime `'de` defined here\r\n5 |     let _ = serde_json::from_slice::<D>(b.as_ref()).unwrap();\r\n  |             ----------------------------^----------\r\n  |             |                           |\r\n  |             |                           borrowed value does not live long enough\r\n  |             argument requires that `b` is borrowed for `'de`\r\n6 | }\r\n  | - `b` dropped here while still borrowed\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=707cd7c8bdd48c7f2f79ffe4fa211416).)\r\n\r\nMy colleague came to me yesterday asking me to explain this error/help fix the problem. Eventually, I figured out that method call tries to propagate the lifetime bound and fails because the target doesn't have any lifetime bounds. I solved it by applying a HRTB (`D: for<'de> Deserialize<'de>`), which worked out okay.\r\n\r\nThe errors here are kind of misleading, because the borrowed value does actually live long enough, and in this example `b` is not actually still borrowed at the end of the function.\r\n\r\ncc @estebank ", "labels": ["A-diagnostics", "A-lifetimes", "C-enhancement", "D-confusing", "D-newcomer-roadblock", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-05 10:51:17", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560240305": {"author_username": "rodrimati1992", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68855, "title": "Worsened debug build codegen in beta", "body": "The assembly generated in debug builds (-C opt-level=0) worsened for this code that uses an associated constant from a trait.This seems to be caused by the fact that the function is generic,even though the associated constant doesn't depend on the generic parameters of the function.\r\n\r\nThe code:\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=83dfb31158166b5ed7a92ca5dd7bb610\r\n\r\n```rust\r\ntrait NeedsDrop:Sized{\r\n    const NEEDS:bool=std::mem::needs_drop::<Self>();\r\n}\r\n\r\nimpl<This> NeedsDrop for This{}\r\n\r\npub fn hello<T>(){\r\n    if <bool>::NEEDS {\r\n        panic!()\r\n    }\r\n}\r\n\r\npub fn hi(){\r\n    hello::<()>();\r\n    hello::<Vec<()>>();\r\n}\r\n```\r\n\r\n\r\nThe entirety of the generated assembly for stable 1.41.0 in a debug build:\r\n```\r\nplayground::hello:\r\n    retq\r\n\r\nplayground::hello:\r\n    retq\r\n\r\nplayground::hi:\r\n    pushq   %rax\r\n    callq   *playground::hello@GOTPCREL(%rip)\r\n    callq   *playground::hello@GOTPCREL(%rip)\r\n    popq    %rax\r\n    retq\r\n```\r\n\r\nThe assembly generated for the same functions by rustc 1.42.0-beta.2 (2020-02-04 3d2613e2ce7e6a354f77) in a debug build:\r\n```\r\nplayground::hello:\r\n    pushq   %rax\r\n    xorl    %eax, %eax\r\n    testb   $1, %al\r\n    jne .LBB45_2\r\n    jmp .LBB45_1\r\n\r\n.LBB45_1:\r\n    popq    %rax\r\n    retq\r\n\r\n.LBB45_2:\r\n    leaq    .Lanon.257b63aea292a17f4811b89c35bea688.2(%rip), %rdi\r\n    leaq    .Lanon.257b63aea292a17f4811b89c35bea688.4(%rip), %rdx\r\n    movq    std::panicking::begin_panic@GOTPCREL(%rip), %rax\r\n    movl    $14, %esi\r\n    callq   *%rax\r\n    ud2\r\n\r\nplayground::hello:\r\n    pushq   %rax\r\n    xorl    %eax, %eax\r\n    testb   $1, %al\r\n    jne .LBB46_2\r\n    jmp .LBB46_1\r\n\r\n.LBB46_1:\r\n    popq    %rax\r\n    retq\r\n\r\n.LBB46_2:\r\n    leaq    .Lanon.257b63aea292a17f4811b89c35bea688.2(%rip), %rdi\r\n    leaq    .Lanon.257b63aea292a17f4811b89c35bea688.4(%rip), %rdx\r\n    movq    std::panicking::begin_panic@GOTPCREL(%rip), %rax\r\n    movl    $14, %esi\r\n    callq   *%rax\r\n    ud2\r\n\r\nplayground::hi:\r\n    pushq   %rax\r\n    callq   *playground::hello@GOTPCREL(%rip)\r\n    callq   *playground::hello@GOTPCREL(%rip)\r\n    popq    %rax\r\n    retq\r\n\r\n```", "labels": ["A-associated-items", "A-const-eval", "I-slow", "P-medium", "T-compiler", "regression-from-stable-to-beta"], "number_of_comments": 7, "created_at": "2020-02-05 09:22:07", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560201816": {"author_username": "Centril", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68853, "title": "Const param as `PatKind::Path` interpreted as a binding instead of being rejected", "body": "```rust\r\n#![feature(const_generics)]\r\n\r\nfn take_const_param<const N: usize>() {\r\n    match 1 {\r\n        N => {},\r\n        _ => {},\r\n    }\r\n}\r\n\r\nfn main() {\r\n    take_const_param::<0>();\r\n    take_const_param::<1>()\r\n}\r\n```\r\n\r\nresults in:\r\n\r\n```\r\nwarning: unreachable pattern\r\n --> src/main.rs:6:9\r\n  |\r\n5 |         N => {},\r\n  |         - matches any value\r\n6 |         _ => {},\r\n  |         ^ unreachable pattern\r\n  |\r\n  = note: `#[warn(unreachable_patterns)]` on by default\r\n\r\nwarning: unused variable: `N`\r\n --> src/main.rs:5:9\r\n  |\r\n5 |         N => {},\r\n  |         ^ help: consider prefixing with an underscore: `_N`\r\n  |\r\n  = note: `#[warn(unused_variables)]` on by default\r\n\r\nwarning: variable `N` should have a snake case name\r\n --> src/main.rs:5:9\r\n  |\r\n5 |         N => {},\r\n  |         ^ help: convert the identifier to snake case: `n`\r\n  |\r\n  = note: `#[warn(non_snake_case)]` on by default\r\n\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.64s\r\n     Running `target/debug/playground`\r\n```\r\n\r\nbut should, similarly to associated constants, result in:\r\n\r\n```rust\r\nerror[E0158]: const parameters cannot be referenced in patterns\r\n --> src/lib.rs:L:C\r\n  |\r\nL |     N => {}\r\n  |     ^\r\n```", "labels": ["A-const-generics", "C-bug", "F-const_generics", "T-compiler", "requires-nightly"], "number_of_comments": 2, "created_at": "2020-02-05 07:59:26", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560168822": {"author_username": "phansch", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68850, "title": "WIP: Suggest similar type or module on resolve failure", "body": "When failing to resolve types or modules, this change tries to provide a\r\nsuggestion with similarly named candidates.\r\n\r\nIf desired, I can try and move some of the diagnostics code in `resolve/lib.rs` to `resolve/diagnostics.rs` as it seems to accumulate a bit in lib.rs. \r\n\r\nFixes #56982", "labels": ["S-waiting-on-author"], "number_of_comments": 6, "created_at": "2020-02-05 06:30:34", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560112893": {"author_username": "CAD97", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68843, "title": "mir\\interpret\\place ice: Layout mismatch when copying!", "body": "With [this patch to rustc](https://github.com/CAD97/rust/tree/0ff88240fd70a273ee6db1144f905b969c6f80b5), I get an ICE compiling stage 1 core:\r\n\r\n```text\r\n   Compiling core v0.0.0 (D:\\repos\\rust-lang\\rust\\src\\libcore)\r\nthread 'rustc' panicked at 'Layout mismatch when copying!\r\nsrc: OpTy {\r\n    op: Immediate(\r\n        Scalar(\r\n            0xffffffffffffffff,\r\n        ),\r\n    ),\r\n    layout: TyLayout {\r\n        ty: isize,\r\n        details: LayoutDetails {\r\n            variants: Single {\r\n                index: 0,\r\n            },\r\n            fields: Union(\r\n                0,\r\n            ),\r\n            abi: Scalar(\r\n                Scalar {\r\n                    value: Int(\r\n                        I64,\r\n                        true,\r\n                    ),\r\n                    valid_range: 0..=18446744073709551615,\r\n                },\r\n            ),\r\n            largest_niche: None,\r\n            align: AbiAndPrefAlign {\r\n                abi: Align {\r\n                    pow2: 3,\r\n                },\r\n                pref: Align {\r\n                    pow2: 3,\r\n                },\r\n            },\r\n            size: Size {\r\n                raw: 8,\r\n            },\r\n        },\r\n    },\r\n}\r\ndest: PlaceTy {\r\n    place: Ptr(\r\n        MemPlace {\r\n            ptr: alloc0+0,\r\n            align: Align {\r\n                pow2: 3,\r\n            },\r\n            meta: None,\r\n        },\r\n    ),\r\n    layout: TyLayout {\r\n        ty: isize,\r\n        details: LayoutDetails {\r\n            variants: Single {\r\n                index: 0,\r\n            },\r\n            fields: Union(\r\n                0,\r\n            ),\r\n            abi: Scalar(\r\n                Scalar {\r\n                    value: Int(\r\n                        I64,\r\n                        true,\r\n                    ),\r\n                    valid_range: 0..=18446744073709551615,\r\n                },\r\n            ),\r\n            largest_niche: None,\r\n            align: AbiAndPrefAlign {\r\n                abi: Align {\r\n                    pow2: 3,\r\n                },\r\n                pref: Align {\r\n                    pow2: 3,\r\n                },\r\n            },\r\n            size: Size {\r\n                raw: 8,\r\n            },\r\n        },\r\n    },\r\n}', src\\librustc_mir\\interpret\\place.rs:855:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::trace_unsynchronized\r\n   1: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n   2: core::fmt::write\r\n   3: std::io::Write::write_fmt\r\n   4: std::panicking::take_hook\r\n   5: std::panicking::take_hook\r\n   6: rustc_driver::report_ice\r\n   7: std::panicking::rust_panic_with_hook\r\n   8: rust_begin_unwind\r\n   9: std::panicking::begin_panic_fmt\r\n  10: rustc_mir::interpret::place::<impl rustc_mir::interpret::eval_context::InterpCx<M>>::mplace_array_fields\r\n  11: rustc_mir::interpret::step::<impl rustc_mir::interpret::eval_context::InterpCx<M>>::eval_rvalue_into_place\r\n  12: rustc_mir::interpret::step::<impl rustc_mir::interpret::eval_context::InterpCx<M>>::run\r\n  13: rustc_mir::const_eval::eval_queries::const_eval_raw_provider\r\n  14: rustc::ty::query::__query_compute::const_eval_raw\r\n  15: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  16: rustc_mir::const_eval::eval_queries::const_eval_validated_provider\r\n  17: rustc::ty::query::__query_compute::const_eval_validated\r\n  18: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  19: rustc_mir::const_eval::eval_queries::const_eval_validated_provider\r\n  20: rustc::ty::query::__query_compute::const_eval_validated\r\n  21: <rustc::traits::Vtable<N> as core::clone::Clone>::clone\r\n  22: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  23: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  24: rustc::mir::interpret::queries::<impl rustc::ty::context::TyCtxt>::const_eval_poly\r\n  25: <rustc_typeck::collect::CollectItemTypesVisitor as rustc_hir::intravisit::Visitor>::visit_item\r\n  26: rustc::hir::map::Map::visit_item_likes_in_module\r\n  27: rustc_typeck::collect::collect_mod_item_types\r\n  28: rustc::ty::query::__query_compute::collect_mod_item_types\r\n  29: rustc::ty::fold::<impl rustc::ty::context::TyCtxt>::anonymize_late_bound_regions\r\n  30: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  31: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  32: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::ensure_query\r\n  33: rustc_typeck::check_crate\r\n  34: rustc_interface::passes::create_global_ctxt\r\n  35: rustc::ty::query::__query_compute::analysis\r\n  36: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  37: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  38: rustc::ty::context::tls::enter_global\r\n  39: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  40: scoped_tls::ScopedKey<T>::set\r\n  41: syntax::attr::with_globals\r\n  42: rustc_data_structures::cold_path\r\n  43: _rust_maybe_catch_panic\r\n  44: core::fmt::Write::write_fmt\r\n  45: <alloc::boxed::Box<F> as core::ops::function::FnOnce<A>>::call_once\r\n  46: std::sys_common::thread::start_thread\r\n  47: std::sys::windows::thread::Thread::new\r\n  48: BaseThreadInitThunk\r\n  49: RtlUserThreadStart\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.43.0-dev running on x86_64-pc-windows-msvc\r\n\r\nnote: compiler flags: -Z external-macro-backtrace -Z binary-dep-depinfo -Z force-unstable-if-unmarked -C opt-level=3 -C debuginfo=0 -C target-feature=+crt-static -C prefer-dynamic -C debug-assertions=n --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [const_eval_raw] const-evaluating `cmp::Ordering::Less::{{constant}}#0`\r\n#1 [const_eval_validated] const-evaluating + checking `cmp::Ordering::Less::{{constant}}#0`\r\n#2 [const_eval_validated] const-evaluating + checking `cmp::Ordering::Less::{{constant}}#0`\r\n#3 [collect_mod_item_types] collecting item types in module `cmp`\r\n#4 [analysis] running analysis passes on this crate\r\nend of query stack\r\nerror: could not compile `core`.\r\n```\r\n\r\nAs this is an ICE compiling core I'm not exactly sure how to minimize it.", "labels": ["C-bug", "E-needs-mcve", "I-ICE", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-05 03:10:51", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560103662": {"author_username": "wesleywiser", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68841, "title": "MIR inliner ICEs trying to inline async closures", "body": "As @bjorn3 [noted](https://github.com/rust-lang/rust/pull/68795#issuecomment-581898999), the MIR inliner seems to fail when dealing with opaque return types. \r\n\r\nTest case:\r\n\r\n```rust\r\n#![feature(async_closure)]\r\n\r\nuse std::future::Future;\r\n\r\nfn async_closure() -> impl Future<Output = u8> {\r\n    (async move || -> u8 {\r\n        42\r\n    })()\r\n}\r\n\r\nfn main() {\r\n    let _fut = async_closure();\r\n}\r\n```\r\n\r\nInvocation:\r\n\r\n```\r\nrustc -Z mir-opt-level=2 --edition 2018 test.rs\r\n```\r\n\r\n<details><summary>ICE:</summary>\r\n\r\n```\r\nerror: internal compiler error: src/librustc/traits/codegen/mod.rs:57: Encountered error `OutputTypeParameterMismatch(Binder(<[closure@async-closure.rs:10:5: 12:7] as std::ops::Fn<()>>), Binder(<[closure@async-closure.rs:10:5: 12:7] as std::ops::Fn<()>>), Sorts(ExpectedFound { expected: impl std::future::Future, found: std::future::GenFuture<[static generator@async-closure.rs:10:26: 12:6 {}]> }))` selecting `Binder(<[closure@async-closure.rs:10:5: 12:7] as std::ops::Fn<()>>)` during codegen\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:883:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /home/wesley/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /home/wesley/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1428\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: <alloc::boxed::Box<F> as core::ops::function::Fn<A>>::call\r\n             at ./src/liballoc/boxed.rs:1029\r\n  11: rustc_driver::report_ice\r\n             at src/librustc_driver/lib.rs:1157\r\n  12: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:474\r\n  13: std::panicking::begin_panic\r\n             at ./src/libstd/panicking.rs:397\r\n  14: rustc_errors::HandlerInner::bug\r\n             at src/librustc_errors/lib.rs:883\r\n  15: rustc_errors::Handler::bug\r\n             at src/librustc_errors/lib.rs:658\r\n  16: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n             at src/librustc/util/bug.rs:36\r\n  17: rustc::ty::context::tls::with_opt::{{closure}}\r\n             at src/librustc/ty/context.rs:1805\r\n  18: rustc::ty::context::tls::with_context_opt\r\n             at src/librustc/ty/context.rs:1757\r\n  19: rustc::ty::context::tls::with_opt\r\n             at src/librustc/ty/context.rs:1805\r\n  20: rustc::util::bug::opt_span_bug_fmt\r\n             at src/librustc/util/bug.rs:32\r\n  21: rustc::util::bug::bug_fmt\r\n             at src/librustc/util/bug.rs:12\r\n  22: rustc::traits::codegen::codegen_fulfill_obligation::{{closure}}\r\n             at src/librustc/traits/codegen/mod.rs:57\r\n  23: rustc::infer::InferCtxtBuilder::enter::{{closure}}\r\n             at src/librustc/infer/mod.rs:535\r\n  24: rustc::ty::context::GlobalCtxt::enter_local::{{closure}}::{{closure}}\r\n             at src/librustc/ty/context.rs:1529\r\n  25: rustc::ty::context::tls::enter_context::{{closure}}\r\n             at src/librustc/ty/context.rs:1696\r\n  26: rustc::ty::context::tls::set_tlv\r\n             at src/librustc/ty/context.rs:1681\r\n  27: rustc::ty::context::tls::enter_context\r\n             at src/librustc/ty/context.rs:1696\r\n  28: rustc::ty::context::GlobalCtxt::enter_local::{{closure}}\r\n             at src/librustc/ty/context.rs:1529\r\n  29: rustc::ty::context::tls::with_related_context::{{closure}}\r\n             at src/librustc/ty/context.rs:1784\r\n  30: rustc::ty::context::tls::with_context::{{closure}}\r\n             at src/librustc/ty/context.rs:1768\r\n  31: rustc::ty::context::tls::with_context_opt\r\n             at src/librustc/ty/context.rs:1757\r\n  32: rustc::ty::context::tls::with_context\r\n             at src/librustc/ty/context.rs:1768\r\n  33: rustc::ty::context::tls::with_related_context\r\n             at src/librustc/ty/context.rs:1781\r\n  34: rustc::ty::context::GlobalCtxt::enter_local\r\n             at src/librustc/ty/context.rs:1521\r\n  35: rustc::infer::InferCtxtBuilder::enter\r\n             at src/librustc/infer/mod.rs:534\r\n  36: rustc::traits::codegen::codegen_fulfill_obligation\r\n             at src/librustc/traits/codegen/mod.rs:34\r\n  37: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::codegen_fulfill_obligation>::compute::{{closure}}\r\n             at src/librustc/ty/query/plumbing.rs:951\r\n  38: rustc::ty::query::__query_compute::codegen_fulfill_obligation\r\n             at src/librustc/ty/query/plumbing.rs:902\r\n  39: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::codegen_fulfill_obligation>::compute\r\n             at src/librustc/ty/query/plumbing.rs:943\r\n  40: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n             at src/librustc/dep_graph/graph.rs:341\r\n  41: rustc::dep_graph::graph::DepGraph::with_task\r\n             at src/librustc/dep_graph/graph.rs:209\r\n  42: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job::{{closure}}::{{closure}}\r\n             at src/librustc/ty/query/plumbing.rs:557\r\n  43: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query::{{closure}}::{{closure}}\r\n             at src/librustc/ty/query/plumbing.rs:278\r\n  44: rustc::ty::context::tls::enter_context::{{closure}}\r\n             at src/librustc/ty/context.rs:1696\r\n  45: rustc::ty::context::tls::set_tlv\r\n             at src/librustc/ty/context.rs:1681\r\n  46: rustc::ty::context::tls::enter_context\r\n             at src/librustc/ty/context.rs:1696\r\n  47: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query::{{closure}}\r\n             at src/librustc/ty/query/plumbing.rs:278\r\n  48: rustc::ty::context::tls::with_related_context::{{closure}}\r\n             at src/librustc/ty/context.rs:1784\r\n  49: rustc::ty::context::tls::with_context::{{closure}}\r\n             at src/librustc/ty/context.rs:1768\r\n  50: rustc::ty::context::tls::with_context_opt\r\n             at src/librustc/ty/context.rs:1757\r\n  51: rustc::ty::context::tls::with_context\r\n             at src/librustc/ty/context.rs:1768\r\n  52: rustc::ty::context::tls::with_related_context\r\n             at src/librustc/ty/context.rs:1781\r\n  53: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query\r\n             at src/librustc/ty/query/plumbing.rs:267\r\n  54: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job::{{closure}}\r\n             at src/librustc/ty/query/plumbing.rs:547\r\n  55: rustc::ty::query::plumbing::with_diagnostics\r\n             at src/librustc/ty/query/plumbing.rs:212\r\n  56: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job\r\n             at src/librustc/ty/query/plumbing.rs:546\r\n  57: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n             at src/librustc/ty/query/plumbing.rs:380\r\n  58: rustc::ty::query::TyCtxtAt::codegen_fulfill_obligation\r\n             at src/librustc/ty/query/plumbing.rs:1057\r\n  59: rustc::ty::query::<impl rustc::ty::context::TyCtxt>::codegen_fulfill_obligation\r\n             at src/librustc/ty/query/plumbing.rs:1020\r\n  60: rustc::ty::instance::resolve_associated_item\r\n             at src/librustc/ty/instance.rs:417\r\n  61: rustc::ty::instance::Instance::resolve\r\n             at src/librustc/ty/instance.rs:270\r\n  62: rustc_mir::transform::inline::Inliner::get_valid_function_call\r\n             at src/librustc_mir/transform/inline.rs:189\r\n  63: rustc_mir::transform::inline::Inliner::run_pass\r\n             at src/librustc_mir/transform/inline.rs:83\r\n  64: <rustc_mir::transform::inline::Inline as rustc_mir::transform::MirPass>::run_pass\r\n             at src/librustc_mir/transform/inline.rs:43\r\n  65: rustc_mir::transform::run_passes::{{closure}}\r\n             at src/librustc_mir/transform/mod.rs:167\r\n  66: rustc_mir::transform::run_passes\r\n             at src/librustc_mir/transform/mod.rs:174\r\n  67: rustc_mir::transform::run_optimization_passes\r\n             at src/librustc_mir/transform/mod.rs:272\r\n  68: rustc_mir::transform::optimized_mir\r\n             at src/librustc_mir/transform/mod.rs:343\r\n  69: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::optimized_mir>::compute\r\n             at src/librustc/ty/query/plumbing.rs:943\r\n  70: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n             at src/librustc/dep_graph/graph.rs:341\r\n  71: rustc::dep_graph::graph::DepGraph::with_task\r\n             at src/librustc/dep_graph/graph.rs:209\r\n  72: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job::{{closure}}::{{closure}}\r\n             at src/librustc/ty/query/plumbing.rs:557\r\n  73: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query::{{closure}}::{{closure}}\r\n             at src/librustc/ty/query/plumbing.rs:278\r\n  74: rustc::ty::context::tls::enter_context::{{closure}}\r\n             at src/librustc/ty/context.rs:1696\r\n  75: rustc::ty::context::tls::set_tlv\r\n             at src/librustc/ty/context.rs:1681\r\n  76: rustc::ty::context::tls::enter_context\r\n             at src/librustc/ty/context.rs:1696\r\n  77: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query::{{closure}}\r\n             at src/librustc/ty/query/plumbing.rs:278\r\n  78: rustc::ty::context::tls::with_related_context::{{closure}}\r\n             at src/librustc/ty/context.rs:1784\r\n  79: rustc::ty::context::tls::with_context::{{closure}}\r\n             at src/librustc/ty/context.rs:1768\r\n  80: rustc::ty::context::tls::with_context_opt\r\n             at src/librustc/ty/context.rs:1757\r\n  81: rustc::ty::context::tls::with_context\r\n             at src/librustc/ty/context.rs:1768\r\n  82: rustc::ty::context::tls::with_related_context\r\n             at src/librustc/ty/context.rs:1781\r\n  83: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query\r\n             at src/librustc/ty/query/plumbing.rs:267\r\n  84: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job::{{closure}}\r\n             at src/librustc/ty/query/plumbing.rs:547\r\n  85: rustc::ty::query::plumbing::with_diagnostics\r\n             at src/librustc/ty/query/plumbing.rs:212\r\n  86: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job\r\n             at src/librustc/ty/query/plumbing.rs:546\r\n  87: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n             at src/librustc/ty/query/plumbing.rs:380\r\n  88: rustc::ty::query::TyCtxtAt::optimized_mir\r\n             at src/librustc/ty/query/plumbing.rs:1057\r\n  89: rustc::ty::query::<impl rustc::ty::context::TyCtxt>::optimized_mir\r\n             at src/librustc/ty/query/plumbing.rs:1020\r\n  90: rustc::ty::<impl rustc::ty::context::TyCtxt>::instance_mir\r\n             at src/librustc/ty/mod.rs:2883\r\n  91: rustc_mir::monomorphize::collector::collect_neighbours\r\n             at src/librustc_mir/monomorphize/collector.rs:1162\r\n  92: rustc_mir::monomorphize::collector::collect_items_rec\r\n             at src/librustc_mir/monomorphize/collector.rs:371\r\n  93: rustc_mir::monomorphize::collector::collect_items_rec\r\n             at src/librustc_mir/monomorphize/collector.rs:381\r\n  94: rustc_mir::monomorphize::collector::collect_crate_mono_items::{{closure}}::{{closure}}\r\n             at src/librustc_mir/monomorphize/collector.rs:296\r\n  95: core::iter::traits::iterator::Iterator::for_each::call::{{closure}}\r\n             at ./src/libcore/iter/traits/iterator.rs:656\r\n  96: core::iter::traits::iterator::Iterator::fold::ok::{{closure}}\r\n             at ./src/libcore/iter/traits/iterator.rs:2000\r\n  97: core::iter::traits::iterator::Iterator::try_fold\r\n             at ./src/libcore/iter/traits/iterator.rs:1876\r\n  98: core::iter::traits::iterator::Iterator::fold\r\n             at ./src/libcore/iter/traits/iterator.rs:2003\r\n  99: core::iter::traits::iterator::Iterator::for_each\r\n             at ./src/libcore/iter/traits/iterator.rs:659\r\n 100: rustc_mir::monomorphize::collector::collect_crate_mono_items::{{closure}}\r\n             at src/librustc_mir/monomorphize/collector.rs:294\r\n 101: rustc_data_structures::profiling::VerboseTimingGuard::run\r\n             at ./src/librustc_data_structures/profiling.rs:518\r\n 102: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n             at ./src/librustc_session/utils.rs:9\r\n 103: rustc_mir::monomorphize::collector::collect_crate_mono_items\r\n             at src/librustc_mir/monomorphize/collector.rs:293\r\n 104: rustc_mir::monomorphize::partitioning::collect_and_partition_mono_items\r\n             at src/librustc_mir/monomorphize/partitioning.rs:868\r\n 105: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::collect_and_partition_mono_items>::compute::{{closure}}\r\n             at ./src/librustc/ty/query/plumbing.rs:951\r\n 106: rustc::ty::query::__query_compute::collect_and_partition_mono_items\r\n             at ./src/librustc/ty/query/plumbing.rs:902\r\n 107: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n             at ./src/librustc/dep_graph/graph.rs:341\r\n 108: rustc::dep_graph::graph::DepGraph::with_eval_always_task\r\n             at ./src/librustc/dep_graph/graph.rs:388\r\n 109: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job::{{closure}}::{{closure}}\r\n             at ./src/librustc/ty/query/plumbing.rs:549\r\n 110: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query::{{closure}}::{{closure}}\r\n             at ./src/librustc/ty/query/plumbing.rs:278\r\n 111: rustc::ty::context::tls::enter_context::{{closure}}\r\n             at ./src/librustc/ty/context.rs:1696\r\n 112: rustc::ty::context::tls::set_tlv\r\n             at ./src/librustc/ty/context.rs:1681\r\n 113: rustc::ty::context::tls::enter_context\r\n             at ./src/librustc/ty/context.rs:1696\r\n 114: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query::{{closure}}\r\n             at ./src/librustc/ty/query/plumbing.rs:278\r\n 115: rustc::ty::context::tls::with_related_context::{{closure}}\r\n             at ./src/librustc/ty/context.rs:1784\r\n 116: rustc::ty::context::tls::with_context::{{closure}}\r\n             at ./src/librustc/ty/context.rs:1768\r\n 117: rustc::ty::context::tls::with_context_opt\r\n             at ./src/librustc/ty/context.rs:1757\r\n 118: rustc::ty::context::tls::with_context\r\n             at ./src/librustc/ty/context.rs:1768\r\n 119: rustc::ty::context::tls::with_related_context\r\n             at ./src/librustc/ty/context.rs:1781\r\n 120: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query\r\n             at ./src/librustc/ty/query/plumbing.rs:267\r\n 121: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job::{{closure}}\r\n             at ./src/librustc/ty/query/plumbing.rs:547\r\n 122: rustc::ty::query::plumbing::with_diagnostics\r\n             at ./src/librustc/ty/query/plumbing.rs:212\r\n 123: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job\r\n             at ./src/librustc/ty/query/plumbing.rs:546\r\n 124: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n             at ./src/librustc/ty/query/plumbing.rs:380\r\n 125: rustc::ty::query::TyCtxtAt::collect_and_partition_mono_items\r\n             at ./src/librustc/ty/query/plumbing.rs:1057\r\n 126: rustc::ty::query::<impl rustc::ty::context::TyCtxt>::collect_and_partition_mono_items\r\n             at ./src/librustc/ty/query/plumbing.rs:1020\r\n 127: rustc_codegen_ssa::base::codegen_crate\r\n             at ./src/librustc_codegen_ssa/base.rs:534\r\n 128: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n             at src/librustc_codegen_llvm/lib.rs:265\r\n 129: rustc_interface::passes::start_codegen::{{closure}}\r\n             at src/librustc_interface/passes.rs:968\r\n 130: rustc_data_structures::profiling::VerboseTimingGuard::run\r\n             at ./src/librustc_data_structures/profiling.rs:518\r\n 131: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n             at ./src/librustc_session/utils.rs:9\r\n 132: rustc_interface::passes::start_codegen\r\n             at src/librustc_interface/passes.rs:967\r\n 133: rustc_interface::queries::Queries::ongoing_codegen::{{closure}}::{{closure}}\r\n             at src/librustc_interface/queries.rs:280\r\n 134: rustc_interface::passes::QueryContext::enter::{{closure}}\r\n             at src/librustc_interface/passes.rs:701\r\n 135: rustc::ty::context::tls::enter_global::{{closure}}\r\n             at ./src/librustc/ty/context.rs:1719\r\n 136: rustc::ty::context::tls::enter_context::{{closure}}\r\n             at ./src/librustc/ty/context.rs:1696\r\n 137: rustc::ty::context::tls::set_tlv\r\n             at ./src/librustc/ty/context.rs:1681\r\n 138: rustc::ty::context::tls::enter_context\r\n             at ./src/librustc/ty/context.rs:1696\r\n 139: rustc::ty::context::tls::enter_global\r\n             at ./src/librustc/ty/context.rs:1719\r\n 140: rustc_interface::passes::QueryContext::enter\r\n             at src/librustc_interface/passes.rs:701\r\n 141: rustc_interface::queries::Queries::ongoing_codegen::{{closure}}\r\n             at src/librustc_interface/queries.rs:274\r\n 142: rustc_interface::queries::Query<T>::compute\r\n             at src/librustc_interface/queries.rs:33\r\n 143: rustc_interface::queries::Queries::ongoing_codegen\r\n             at src/librustc_interface/queries.rs:272\r\n 144: rustc_driver::run_compiler::{{closure}}::{{closure}}\r\n             at src/librustc_driver/lib.rs:405\r\n 145: rustc_interface::queries::<impl rustc_interface::interface::Compiler>::enter\r\n             at ./src/librustc_interface/queries.rs:336\r\n 146: rustc_driver::run_compiler::{{closure}}\r\n             at src/librustc_driver/lib.rs:295\r\n 147: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n             at ./src/librustc_interface/interface.rs:186\r\n 148: rustc_interface::interface::run_compiler::{{closure}}\r\n             at ./src/librustc_interface/interface.rs:200\r\n 149: rustc_interface::util::spawn_thread_pool::{{closure}}::{{closure}}::{{closure}}\r\n             at ./src/librustc_interface/util.rs:155\r\n 150: scoped_tls::ScopedKey<T>::set\r\n             at /home/wesley/.cargo/registry/src/github.com-1ecc6299db9ec823/scoped-tls-1.0.0/src/lib.rs:137\r\n 151: rustc_interface::util::spawn_thread_pool::{{closure}}::{{closure}}\r\n             at ./src/librustc_interface/util.rs:151\r\n 152: scoped_tls::ScopedKey<T>::set\r\n             at /home/wesley/.cargo/registry/src/github.com-1ecc6299db9ec823/scoped-tls-1.0.0/src/lib.rs:137\r\n 153: syntax::attr::with_globals::{{closure}}\r\n             at ./src/libsyntax/attr/mod.rs:44\r\n 154: scoped_tls::ScopedKey<T>::set\r\n             at /home/wesley/.cargo/registry/src/github.com-1ecc6299db9ec823/scoped-tls-1.0.0/src/lib.rs:137\r\n 155: syntax::attr::with_globals\r\n             at ./src/libsyntax/attr/mod.rs:44\r\n 156: rustc_interface::util::spawn_thread_pool::{{closure}}\r\n             at ./src/librustc_interface/util.rs:150\r\n 157: rustc_interface::util::scoped_thread::{{closure}}\r\n             at ./src/librustc_interface/util.rs:125\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-dev running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -Z mir-opt-level=2 -Z dump-mir=Inline\r\n\r\nquery stack during panic:\r\n#0 [codegen_fulfill_obligation] checking if `std::ops::Fn` fulfills its obligations\r\n#1 [optimized_mir] processing `async_closure`\r\n#2 [collect_and_partition_mono_items] collect_and_partition_mono_items\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\n```\r\n\r\n</details>", "labels": ["A-mir", "C-bug", "F-async_closures", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 1, "created_at": "2020-02-05 02:35:50", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560088643": {"author_username": "ehuss", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68839, "title": "dep-info rmeta path is wrong", "body": "The path to the rmeta file in the dep-info file is wrong.  It is missing the `lib` prefix.\r\n\r\n`rustc --emit=dep-info,metadata --crate-type lib foo.rs`\r\n\r\n`foo.d` will contain `foo.rmeta: foo.rs`, but I think it should be `libfoo.rmeta: foo.rs` because the filename is `libfoo.rmeta`.\r\n\r\nThe crate type doesn't matter.  A \"bin\" type will also emit `foo.rmeta`, but bin types (confusingly) also use `libfoo.rmeta`.\r\n\r\n(This doesn't really affect Cargo, as it ignores these filenames.)\r\n", "labels": ["C-bug", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-05 01:38:23", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560074540": {"author_username": "joshtriplett", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68838, "title": "Support for fatal compile_error that suppresses subsequent errors", "body": "If a crate includes something like:\r\n\r\n```rust\r\n#[cfg(not(target_os = \"linux\"))]\r\ncompile_error!(\"This crate only runs on Linux\")\r\n```\r\n\r\nthen it isn't helpful for rustc to report that error but then go on to emit many more cascading errors about failed `use` statements and types that don't exist and similar.\r\n\r\nIt's especially unhelpful when those additional errors scroll the initial error off the screen.", "labels": ["A-diagnostics", "C-feature-request", "T-compiler"], "number_of_comments": 8, "created_at": "2020-02-05 00:48:40", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "560054435": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68836, "title": "MBE (macro_rules!) pattern-matching is unnecessarily O(n) even in simple cases.", "body": "There are some crates which do something like this (e.g. [`string_cache_codegen`](https://github.com/servo/string-cache/blob/af2c7707e797768660b3db90066b80218dbca6f7/string-cache-codegen/lib.rs#L271-L275)):\r\n```rust\r\nmacro_rules! foo {\r\n    (\"a\") => (A);\r\n    (\"b\") => (B);\r\n    (\"c\") => (C);\r\n    // ... etc. (maybe hundreds more)\r\n}\r\n```\r\n(@nnethercote came across this when profiling `html5ever`'s compilation)\r\n\r\nAlso, prefixing patterns with `@foo` to create \"internal rules\" is common.\r\n\r\nBut the current implementation (AFAICT) has to check each of the patterns in turn.\r\n\r\nInstead, we could build something like a decision tree ahead of time, from the constant (i.e. `$`-less) prefix of all arms, using maps for operators/idents/literals, to make the pattern-matching of the prefix amortize to being linear in the number of input tokens.\r\n\r\nWe could keep it simple by limiting the constant prefix to leaf tokens (no `(...)`, `[...]` or `{...}`).\r\n\r\nFor the example above, we'd pre-compute something like this:\r\n```rust\r\nDecisionTree::Match {\r\n    op: {},\r\n    ident: {},\r\n    literal: {\r\n        \"a\": DecisionTree::Done([0]),\r\n        \"b\": DecisionTree::Done([1]),\r\n        \"c\": DecisionTree::Done([2]),\r\n        // ...\r\n    },\r\n}\r\n```\r\n\r\nWhereas for something using `@foo` rules it could be:\r\n```rust\r\nDecisionTree::Match {\r\n    op: {\r\n        '@': DecisionTree::Match {\r\n            op: {},\r\n            ident: {\r\n                \"foo\": DecisionTree::Done([0, 1]),\r\n                \"bar\": DecisionTree::Done([2, 3, 4]),\r\n                \"baz\": DecisionTree::Done([5]),\r\n            },\r\n            literal: {},\r\n        }\r\n    },\r\n    ident: {},\r\n    literal: {},\r\n}\r\n```\r\n(where `DecisionTree::Done` indicates the arms to continue with)\r\n\r\ncc @rust-lang/compiler (this might need a design meeting?) ", "labels": ["A-macros", "C-enhancement", "I-compiletime", "T-compiler"], "number_of_comments": 12, "created_at": "2020-02-05 00:01:02", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559978736": {"author_username": "JohnTitor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68833, "title": "Tracking issue for `std::io::{BufReader, BufWriter}::capacity`", "body": "#68558 adds `capacity` methods to `BufReader` and `BufWriter`.\r\n\r\nUnresolved questions:\r\n", "labels": ["B-unstable", "C-tracking-issue", "T-libs"], "number_of_comments": 0, "created_at": "2020-02-04 21:06:12", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559931199": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68830, "title": "Spurious 'conflicting implementations' error when specializing a type with a compilation error", "body": "The following code:\r\n\r\n```rust\r\n#![feature(specialization)]\r\n\r\nstruct BadStruct {\r\n    err: MissingType\r\n}\r\n\r\ntrait MyTrait<T> {\r\n    fn foo();\r\n}\r\n\r\nimpl<T, D> MyTrait<T> for D {\r\n    default fn foo() {}\r\n}\r\n\r\nimpl<T> MyTrait<T> for BadStruct {\r\n    fn foo() {}\r\n}\r\n```\r\n\r\ngives the following errors:\r\n\r\n```rust\r\nerror[E0412]: cannot find type `MissingType` in this scope\r\n --> src/lib.rs:4:10\r\n  |\r\n4 |     err: MissingType\r\n  |          ^^^^^^^^^^^ not found in this scope\r\n\r\nerror[E0119]: conflicting implementations of trait `MyTrait<_>` for type `BadStruct`:\r\n  --> src/lib.rs:15:1\r\n   |\r\n11 | impl<T, D> MyTrait<T> for D {\r\n   | --------------------------- first implementation here\r\n...\r\n15 | impl<T> MyTrait<T> for BadStruct {\r\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `BadStruct`\r\n\r\nerror: aborting due to 2 previous errors\r\n```\r\n\r\nFor some reason, the fact that the definition of `BadStruct` has an error (`MissingType` is not defining) causes a 'conflicting implementations' error to be emitted when `BadStruct` has a specialized impl. If `MissingType` is changed to a type which actually exists (e.g. `()`), the 'conflicting implementations' error disappears.\r\n\r\nI found this when working on `rustc` - a missing `use` statement caused 30 spurious specialization-related errors to be emiited, which all disappeared when I added the missing import.", "labels": ["A-diagnostics", "A-specialization", "C-bug", "D-verbose", "F-specialization", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-04 19:30:27", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559879141": {"author_username": "oli-obk", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68828, "title": "Prevent query cycles in the MIR inliner", "body": "r? @eddyb @wesleywiser \r\n\r\ncc @rust-lang/wg-mir-opt \r\n\r\nThe general design is that we have a new query that is run on the `validated_mir` instead of on the `optimized_mir`. That query is forced before going into the optimization pipeline, so as to not try to read from a stolen MIR.\r\n\r\nThe query should not be cached cross crate, as you should never call it for items from other crates. By its very design calls into other crates can never cause query cycles.\r\n\r\nThis is a pessimistic approach to inlining, since we strictly have more calls in the `validated_mir` than we have in `optimized_mir`, but that's not a problem imo.", "labels": ["S-waiting-on-review"], "number_of_comments": 13, "created_at": "2020-02-04 17:46:19", "reactions": {"total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "heart": 3, "hooray": 0}}, "559863525": {"author_username": "ssomers", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68827, "title": "BTreeMap navigation done safer & faster", "body": "It turns out that there was a faster way to do the tree navigation code bundled in #67073, by moving from edge to KV and from KV to next edge separately. It extracts most of the code as safe functions, and contains the duplication of handles within the short wrapper functions.\r\n\r\nThis somehow hits a sweet spot in the compiler because it reports boosts all over the board:\r\n```\r\n>cargo benchcmp pre3.txt posz4.txt --threshold 5\r\n name                                           pre3.txt ns/iter  posz4.txt ns/iter  diff ns/iter   diff %  speedup\r\n btree::map::first_and_last_0                   40                37                           -3   -7.50%   x 1.08\r\n btree::map::first_and_last_100                 58                44                          -14  -24.14%   x 1.32\r\n btree::map::iter_1000                          8,920             3,419                    -5,501  -61.67%   x 2.61\r\n btree::map::iter_100000                        1,069,290         411,615                -657,675  -61.51%   x 2.60\r\n btree::map::iter_20                            169               58                         -111  -65.68%   x 2.91\r\n btree::map::iter_mut_1000                      8,701             3,303                    -5,398  -62.04%   x 2.63\r\n btree::map::iter_mut_100000                    1,034,560         405,975                -628,585  -60.76%   x 2.55\r\n btree::map::iter_mut_20                        165               58                         -107  -64.85%   x 2.84\r\n btree::set::clone_100                          1,831             1,562                      -269  -14.69%   x 1.17\r\n btree::set::clone_100_and_clear                1,831             1,565                      -266  -14.53%   x 1.17\r\n btree::set::clone_100_and_into_iter            1,917             1,541                      -376  -19.61%   x 1.24\r\n btree::set::clone_100_and_pop_all              2,609             2,441                      -168   -6.44%   x 1.07\r\n btree::set::clone_100_and_remove_all           4,598             3,927                      -671  -14.59%   x 1.17\r\n btree::set::clone_100_and_remove_half          2,765             2,551                      -214   -7.74%   x 1.08\r\n btree::set::clone_10k                          191,610           164,616                 -26,994  -14.09%   x 1.16\r\n btree::set::clone_10k_and_clear                192,003           164,616                 -27,387  -14.26%   x 1.17\r\n btree::set::clone_10k_and_into_iter            200,037           163,010                 -37,027  -18.51%   x 1.23\r\n btree::set::clone_10k_and_pop_all              267,023           250,913                 -16,110   -6.03%   x 1.06\r\n btree::set::clone_10k_and_remove_all           536,230           464,100                 -72,130  -13.45%   x 1.16\r\n btree::set::clone_10k_and_remove_half          453,350           430,545                 -22,805   -5.03%   x 1.05\r\n btree::set::difference_random_100_vs_100       1,787             801                        -986  -55.18%   x 2.23\r\n btree::set::difference_random_100_vs_10k       2,978             2,696                      -282   -9.47%   x 1.10\r\n btree::set::difference_random_10k_vs_100       111,075           54,734                  -56,341  -50.72%   x 2.03\r\n btree::set::difference_random_10k_vs_10k       246,380           175,980                 -70,400  -28.57%   x 1.40\r\n btree::set::difference_staggered_100_vs_100    1,789             951                        -838  -46.84%   x 1.88\r\n btree::set::difference_staggered_100_vs_10k    2,798             2,606                      -192   -6.86%   x 1.07\r\n btree::set::difference_staggered_10k_vs_10k    176,452           97,401                  -79,051  -44.80%   x 1.81\r\n btree::set::intersection_100_neg_vs_10k_pos    34                32                           -2   -5.88%   x 1.06\r\n btree::set::intersection_100_pos_vs_100_neg    30                27                           -3  -10.00%   x 1.11\r\n btree::set::intersection_random_100_vs_100     1,537             613                        -924  -60.12%   x 2.51\r\n btree::set::intersection_random_100_vs_10k     2,793             2,649                      -144   -5.16%   x 1.05\r\n btree::set::intersection_random_10k_vs_10k     222,127           147,166                 -74,961  -33.75%   x 1.51\r\n btree::set::intersection_staggered_100_vs_100  1,447             622                        -825  -57.01%   x 2.33\r\n btree::set::intersection_staggered_100_vs_10k  2,606             2,382                      -224   -8.60%   x 1.09\r\n btree::set::intersection_staggered_10k_vs_10k  143,620           58,790                  -84,830  -59.07%   x 2.44\r\n btree::set::is_subset_100_vs_100               1,349             488                        -861  -63.83%   x 2.76\r\n btree::set::is_subset_100_vs_10k               1,720             1,428                      -292  -16.98%   x 1.20\r\n btree::set::is_subset_10k_vs_10k               135,984           48,527                  -87,457  -64.31%   x 2.80\r\n```\r\nThe `first_and_last` ones are noise (they don't do iteration), the others seem genuine.\r\nAs always, approved by Miri.\r\n\r\nAlso, a separate commit with some more benchmarks of mutable behaviour (which also benefit). \r\n\r\nr? @cuviper", "labels": ["S-waiting-on-review"], "number_of_comments": 1, "created_at": "2020-02-04 17:17:29", "reactions": {"total_count": 5, "+1": 0, "-1": 0, "laugh": 0, "heart": 2, "hooray": 0}}, "559860697": {"author_username": "jplatte", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68826, "title": "Trait method has higher precedence than inherent method if autoref is required for the inherent method", "body": "I was very surprised when I found the following outputs \"trait method\" ([playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=03ba2cc9209dd4da459865a7e4b66cc4)):\r\n\r\n```rust\r\nstruct Struct;\r\n\r\nimpl Struct {\r\n    fn foo(&self) {\r\n        println!(\"inherent method\")\r\n    }\r\n}\r\n\r\npub trait Foo {\r\n    fn foo(self);\r\n}\r\n\r\nimpl Foo for Struct {\r\n    fn foo(self) {\r\n        println!(\"trait method\")\r\n    }\r\n}\r\n\r\nfn main() {\r\n    Struct.foo();\r\n}\r\n```\r\n\r\nUp until now I always thought that an inherent method always takes precedence over a trait method of the same name. Is that not true in this case / is this behaviour intended?\r\n\r\nThis came up in [yew](https://github.com/yewstack/yew), which defined an inherent `try_into` (now renamed) with a type parameter that would start producing errors about unexpected type parameters when `TryInto` (or `stdweb::unstable::TryInto`) was brought into scope.", "labels": ["A-traits", "T-compiler", "T-lang"], "number_of_comments": 0, "created_at": "2020-02-04 17:12:33", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559699002": {"author_username": "evnu", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68822, "title": "rustc generates a lot of LLVM IR when using a match in struct field initialization", "body": "In https://github.com/rusterlium/rustler/issues/299, we detected compile time to increase non-linearly when using a rather simple proc-macro. In https://github.com/rusterlium/rustler/issues/299#issuecomment-579213528, we found that our decoder function results in a lot of IR. We were able to fix the issue in https://github.com/rusterlium/rustler/pull/300 by making a simple transformation for generated struct initialization.\r\n\r\n## Transformation\r\n\r\nThe change to our proc-macro resulted in the following transformation of the resulting code.\r\n\r\nBefore:\r\n\r\n```rust\r\nOk(SomeStruct {\r\n  field1: match Decoder::decode(term[1usize])? { ... }\r\n// .. more fields\r\n})\r\n```\r\n\r\nAfter:\r\n\r\n```rust\r\nlet field1 = match Decoder::decode(term[1usize]) { ... };\r\n// .. more bindings\r\nOk(SomeStruct {\r\n  field1,\r\n// .. more fields\r\n})\r\n```\r\n\r\n## Simplification\r\n\r\nI simplified our case in https://github.com/evnu/rust-slow-compilation. I haven't been able to simplify this further: when I tried to get rid of the rustler-specific `Decoder`, or when using `map_err()`, compilation became very fast. The [README](https://github.com/evnu/rust-slow-compilation#run-the-benchmark) of the repository indicates compilation times on my machine for specific revisions of the repository.\r\n\r\n## Meta\r\n\r\n```\r\n$ rustc --version --verbose\r\nrustc 1.40.0 (73528e339 2019-12-16)\r\nbinary: rustc\r\ncommit-hash: 73528e339aae0f17a15ffa49a8ac608f50c6cf14\r\ncommit-date: 2019-12-16\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.40.0\r\nLLVM version: 9.0\r\n```", "labels": ["A-codegen", "C-enhancement", "I-compiletime", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-04 12:50:32", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559583674": {"author_username": "iago-lito", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68821, "title": "Misleading error when incorrectly using crate as a module.", "body": "I had a source file used as a module in my binary crate. At some point, I have decided to turn this file into a second binary crate instead. But I forgot to remove the corresponding `mod` statement in the first crate. It took me a while to figure it out because the error message was very misleading.\r\n\r\nHere is the situation boiled down:\r\n\r\n`Cargo.toml`\r\n```toml\r\n[package]\r\nname = \"rust_test\"\r\nversion = \"0.1.0\"\r\nauthors = [\"Iago-lito\"]\r\nedition = \"2018\"\r\ndefault-run = \"first_bin\"\r\n\r\n[[bin]]\r\nname = \"first_bin\"\r\npath = \"src/first_bin.rs\"\r\n\r\n[[bin]]\r\nname = \"second_bin\"\r\npath = \"src/second_bin.rs\"\r\n```\r\n\r\n`src/first_bin.rs`\r\n```rust\r\nmod common_module;\r\nmod second_bin; // That is very wrong..\r\n\r\nfn main() {\r\n    common_module::common_function();\r\n} \r\n```\r\n`src/second_bin.rs`\r\n```rust\r\nmod common_module; // .. but the error blames this line.\r\n\r\nfn main() {\r\n    common_module::common_function();\r\n} \r\n```\r\n\r\n`src/common_module.rs`\r\n```rust\r\npub fn common_function() {}\r\n```\r\n\r\nI'd expect getting something like:\r\n```\r\nerror[EXXX]: binary crate root file cannot be used as a module.\r\n--> src/first_bin:2:5\r\n  |\r\n2 | mod second_bin;\r\n  |     ^^^^^^^^^^\r\n  |\r\n  = help: remove this statement or consider not declaring `src/second_bin.rs` as the root of a binary crate in `Cargo.toml`\r\n```\r\n\r\nBut the actual error is:\r\n```\r\nerror[E0583]: file not found for module `common_module`\r\n --> src/second_bin.rs:1:5\r\n  |\r\n1 | mod common_module;\r\n  |     ^^^^^^^^^^^^^\r\n  |\r\n  = help: name the file either second_bin/common_module.rs or second_bin/common_module/mod.rs inside the directory \"src\"\r\n```\r\n\r\nBecause of this, I had to dig the whole way through [Chapter 7 of the Book](https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html) again before I figured out that there was nothing wrong with the location of `src/common_module.rs`. Then I had to scroll the other files line by line to eventually spot the mistake.\r\n\r\nWould this be considered a bug? Is it the correct place to report it?", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-04 09:16:07", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559578855": {"author_username": "WaffleLapkin", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68820, "title": "Remove `finished` flag from `MapWhile`", "body": "This PR removes  `finished` flag from `MapWhile` as been proposed in https://github.com/rust-lang/rust/pull/66577#discussion_r370958025.\r\n\r\nThis also resolves open questions of the tracking issue (#68537):\r\n- `MapWhile` can't implement both\r\n  + `DoubleEndedIterator` (discussed in https://github.com/rust-lang/rust/pull/66577#discussion_r370947990 and following comments)\r\n  + `FusedIterator` (this pr removes `finished` flag, so `MapWhile` isn't fused anymore)\r\n- Debug output (this pr removes `finished` flag, so there is no question in including it in debug output)\r\n\r\nr? @Mark-Simulacrum ", "labels": ["S-waiting-on-review"], "number_of_comments": 24, "created_at": "2020-02-04 09:07:06", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "heart": 2, "hooray": 0}}, "559428473": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68817, "title": "llvm.dbg.value should be used instead of llvm.dbg.declare wherever possible.", "body": "*(I'm opening this issue because I can't find a pre-existing one)*\r\n\r\n`llvm.dbg.declare` describes the location in memory of a debuginfo variable, whereas `llvm.dbg.value` describes the value itself directly. Today we only use the former, which means that in debug mode, all named variables are placed on the stack, even if they're simple scalars (e.g. integers).\r\n\r\nIdeally, we'd use `llvm.dbg.value` in the same situations where we skip creating a stack slot (e.g. LLVM `alloca`), i.e. for scalars, vectors and pairs of scalars.\r\n\r\n<hr/>\r\n\r\nHowever, this is much harder than I expected, mostly due to LLVM being too eager to throw away `llvm.dbg.value` if computing the value can be avoided (i.e. it's not used by anything else).\r\n\r\nI think `llvm.dbg.declare` *only* fares better because at `opt-level=0`, the lack of SROA means `alloca`s are kept around pretty much completely intact.\r\n\r\n`FastISel` (used at `opt-level=0`) [throws away any non-trivial `llvm.dbg.value`](https://github.com/llvm/llvm-project/blob/30a8865142abe309bb9aceede2708c171a2904ea/llvm/lib/CodeGen/SelectionDAG/FastISel.cpp#L1445-L1446), but disabling it with `-C llvm-args=-fast-isel=0` only helps some simple cases (such as a reference to another stack variable - IMO `FastISel` should be improved to handle those, I don't see why it couldn't).\r\n\r\nIn general, it looks like Instruction Selection (\"`ISel`\") in LLVM ignores `llvm.dbg.value`s while building all of the machine instructions for a BB, and only *afterwards* does it come back to the `llvm.dbg.value`s and lower them to `DBG_VALUE`, using the value *only* if it already exists (i.e. something else needs that same value, at runtime), and otherwise it leads to `<optimized out>` vars.\r\n\r\nMaybe the upcoming `GlobalISel` approach handles `llvm.dbg.value` better, but I would need to target `AArch64` to even try it out, from what I hear (I might still do it out of curiosity).\r\n\r\n<hr/>\r\n\r\nWhile investigating this I also came across https://github.com/rust-lang/rust/pull/8855#discussion_r374392128 - but setting `AlwaysPreserve` to `true` only keeps the debuginfo variable around, it doesn't help at all with keeping any value alive (so you end up with `<optimized out>` in the debugger, instead of the variable missing).\r\n\r\nI haven't seen anything that would make `llvm.dbg.value` keep the value alive so it's guaranteed to be available to the debugger, but if there is such a thing, it's probably the way to go, if we want to avoid relying on the stack so much.\r\n\r\ncc @nikomatsakis @michaelwoerister @hanna-kruppe ", "labels": ["A-LLVM", "A-debuginfo", "C-enhancement", "T-compiler"], "number_of_comments": 4, "created_at": "2020-02-04 01:14:35", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559398015": {"author_username": "TheBlueMatt", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68813, "title": "1.40.0 ICE while reporting ICE", "body": "rustc+cargo 1.40.0 Debian testing packages report the following ICE (which does not go away after a cargo clean):\r\n\r\nIt can be reproduced by trying to build https://github.com/TheBlueMatt/rust-lightning-bitcoinrpc/tree/2020-02-ice-demo against https://github.com/TheBlueMatt/rust-lightning/tree/2020-02-rustc-ice.\r\n\r\n```\r\nthread 'rustc' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.40.0 running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nerror: could not compile `rust-lightning-bitcoinrpc`.\r\n\r\nTo learn more, run the command again with --verbose.\r\nmatt@cdev1:~/Documents/Projects/Bitcoin/rust-lightning-bitcoinrpc$ RUST_BACKTRACE=1 cargo build && RUST_BACKTRACE=1 ./target/debug/rust-lightning-bitcoinrpc __cookie__:f70ead21e4528ac6e74c8e182297a2b5f3041522ee55481175d4413ae552ab56@69.59.18.207:18332 `pwd`/toktest/\r\n   Compiling rust-lightning-bitcoinrpc v0.0.1 (/home/matt/Documents/Projects/Bitcoin/rust-lightning-bitcoinrpc)\r\nthread 'rustc' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:378:21\r\nstack backtrace:\r\n   0: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n   1: core::fmt::write\r\n   2: <unknown>\r\n   3: <unknown>\r\n   4: <unknown>\r\n   5: rustc_driver::report_ice\r\n   6: <alloc::boxed::Box<F> as core::ops::function::Fn<A>>::call\r\n             at /usr/src/rustc-1.40.0/src/liballoc/boxed.rs:956\r\n   7: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}::{{closure}}\r\n             at /usr/src/rustc-1.40.0/src/libproc_macro/bridge/client.rs:305\r\n   8: std::panicking::rust_panic_with_hook\r\n   9: <unknown>\r\n  10: rust_begin_unwind\r\n  11: core::panicking::panic_fmt\r\n  12: core::panicking::panic\r\n  13: <unknown>\r\n  14: <unknown>\r\n  15: <unknown>\r\n  16: <unknown>\r\n  17: <unknown>\r\n  18: <unknown>\r\n  19: <unknown>\r\n  20: <unknown>\r\n  21: <unknown>\r\n  22: rustc::traits::error_reporting::<impl rustc::infer::InferCtxt>::report_selection_error\r\n  23: rustc::traits::error_reporting::<impl rustc::infer::InferCtxt>::report_fulfillment_errors\r\n  24: <unknown>\r\n  25: <unknown>\r\n  26: <unknown>\r\n  27: <unknown>\r\n  28: <unknown>\r\n  29: <unknown>\r\n  30: <unknown>\r\n  31: <unknown>\r\n  32: <unknown>\r\n  33: <unknown>\r\n  34: <unknown>\r\n  35: rustc_typeck::collect::checked_type_of\r\n  36: <unknown>\r\n  37: <unknown>\r\n  38: <unknown>\r\n  39: <unknown>\r\n  40: <unknown>\r\n  41: <unknown>\r\n  42: <unknown>\r\n  43: <unknown>\r\n  44: <unknown>\r\n  45: <rustc_typeck::collect::CollectItemTypesVisitor as rustc::hir::intravisit::Visitor>::visit_item\r\n  46: <unknown>\r\n  47: <unknown>\r\n  48: <unknown>\r\n  49: <unknown>\r\n  50: <unknown>\r\n  51: <unknown>\r\n  52: <unknown>\r\n  53: <unknown>\r\n  54: <unknown>\r\n  55: rustc_typeck::check_crate\r\n  56: <unknown>\r\n  57: <unknown>\r\n  58: <unknown>\r\n  59: <unknown>\r\n  60: <unknown>\r\n  61: <unknown>\r\n  62: <unknown>\r\n  63: <unknown>\r\n  64: <unknown>\r\n  65: <unknown>\r\n  66: <unknown>\r\n  67: <unknown>\r\n  68: __rust_maybe_catch_panic\r\n  69: <unknown>\r\n  70: <unknown>\r\n  71: <unknown>\r\n  72: <unknown>\r\n  73: start_thread\r\n  74: __clone\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.40.0 running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [typeck_tables_of] processing `lightning_net_tokio::Connection::setup_outbound`\r\n#1 [typeck_tables_of] processing `lightning_net_tokio::Connection::setup_outbound::{{closure}}#0`\r\n#2 [typeck_tables_of] processing `main`\r\n#3 [typeck_tables_of] processing `main::{{closure}}#0`\r\n#4 [type_of] processing `main::{{closure}}#0`\r\n#5 [collect_mod_item_types] collecting item types in top-level module\r\n#6 [analysis] running analysis passes on this crate\r\nend of query stack\r\nerror: could not compile `rust-lightning-bitcoinrpc`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```", "labels": ["E-needs-mcve", "I-ICE", "ICEBreaker-Cleanup-Crew", "P-high", "T-compiler"], "number_of_comments": 14, "created_at": "2020-02-03 23:31:47", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559393195": {"author_username": "berkus", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68812, "title": "Incorrect code behavior on aarch64", "body": "\r\nThe following code compiles and works correctly on `x86_64`. However, the same code when compiled for `aarch64` with `opt-level = \"s\"` does not work.\r\n\r\nhttps://github.com/berkus/mre-write_to \r\nThe culprit is the function show() in write_to.rs:44\r\n\r\n(one-page version [here](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=6716bf91b5ec219b3e47ee9845817b2f) -- this however is not enough for reproduction)\r\n\r\nWhen used from the same module it correctly generates a &str from buffer slice. When used from another module the resulting str is \"\" (empty).\r\n\r\nThe original code location, where bug is easily reproducible by running `makers test` is [here](https://github.com/metta-systems/vesper/commit/cf277ca6f95bdcd8e2e4792d465864085780dd0f#diff-0223edd1d1e7828c93f97bf9fe0d955eR66-R72)\r\n\r\n(Disclaimer: [custom target file](), should match LLVM layout for aarch64 however; [custom linker script]() for OS kernel)\r\n\r\nThere, marking the function with `#[inline]` makes it work correctly at call sites other than the same module (for example, from [here](https://github.com/metta-systems/vesper/commit/56d70afdba836232a13a603001b1bc5a9232a751#diff-fc33479aa09afcf480bf5414d24a0517R32-R38)). Removing inline modifier makes it produce \"\" (empty) strs. It still works correctly from within the same module (e.g. local unit tests pass).\r\n\r\nChanging `opt-level` from \"s\" to 2 or 3 also fixes the issue.\r\n\r\nReplacing `from_utf8_unchecked` with `from_utf8().unwrap()` causes different behavior. Now opt-levels 2 and \"s\" produce empty strs while opt-level 3 works as intended.\r\n\r\nIt looks like code generation bug to me.\r\n\r\n$ rustc --version\r\nrustc 1.42.0-nightly (cd1ef390e 2020-01-31)\r\n\r\nReady to provide more information or test possible fixes.", "labels": ["C-bug", "I-unsound \ud83d\udca5", "O-ARM", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-03 23:19:08", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559377566": {"author_username": "tmandry", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68811, "title": "Re-land \"add IntoFuture trait and support for await\"", "body": "Testing the code from #65244 to see if the performance regressions are still there. #68606 and #68672 made perf optimizations that might interact with this change.\r\n\r\nIf this lands, fixes #67982.\r\n\r\ncc @seanmonstar @jonas-schievink \r\nr? @cramertj ", "labels": ["S-waiting-on-author"], "number_of_comments": 7, "created_at": "2020-02-03 22:39:06", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 1}}, "559348074": {"author_username": "Veetaha", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68808, "title": "cargo check --message-format json regression of error span data on empty main.rs file", "body": "**Problem**\r\n`cargo check --message-format json` returns invalid span data, particularly `line_end` and `line_start` are set to 0, though [it is guaranteed to be 1-based](https://github.com/oli-obk/cargo_metadata/blob/master/src/diagnostic.rs#L58-L61).\r\nThis happens with a completly empty `main.rs` file.\r\n\r\nTested on the following cargo version:\r\n`cargo 1.42.0-nightly (9d32b7b01 2020-01-26)`\r\n\r\nWhilst on the stable version the returned span array is empty:\r\n`cargo 1.41.0 (626f0f40e 2019-12-03)`\r\n\r\n**Steps**\r\n1. Clone [this repo](https://github.com/Veetaha/cargo-check-regression-1.42-nightly)\r\n2. Run `rustup default nightly`\r\n3. Run `cargo check --message-format json > check.json`\r\n\r\nNow you can see invalid span in `check.json` file.\r\n\r\nI've already created and formatted `check-1.41.json` and `check-1.42.json` files with the output of different cargo versions.\r\nHere are the crutial differences [1.41](https://github.com/Veetaha/cargo-check-regression-1.42-nightly/blob/861f9913465a8b880aee1e8e0d6ffa906c3fc637/check-1.41.json#L28) and [1.42](https://github.com/Veetaha/cargo-check-regression-1.42-nightly/blob/861f9913465a8b880aee1e8e0d6ffa906c3fc637/check-1.42.json#L28-L46)\r\n\r\n**Context**\r\n[The issue was initially reported at rust-analyzer project repo here.](https://github.com/rust-analyzer/rust-analyzer/issues/2973)", "labels": ["A-diagnostics", "P-high", "T-compiler", "regression-from-stable-to-nightly"], "number_of_comments": 4, "created_at": "2020-02-03 20:57:42", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559230999": {"author_username": "harrisonthorne", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68801, "title": "'index out of bounds: the len is 1 but the index is 1': libcore/slice/mod.rs", "body": "```\r\nthread 'rustc' panicked at 'index out of bounds: the len is 1 but the index is 1', /rustc/cd1ef390e73\r\n1ed77b90b11b1f77e2c5ca641b261/src/libcore/slice/mod.rs:2791:10\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n```\r\n\r\nEdit: Clippy version:\r\n\r\n```\r\nclippy 0.0.212 (c0f39cf 2020-01-29)\r\n```", "labels": ["A-borrow-checker", "A-mir", "C-bug", "I-ICE", "ICEBreaker-Cleanup-Crew", "P-high", "T-compiler"], "number_of_comments": 29, "created_at": "2020-02-01 06:48:19", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559158789": {"author_username": "emilio", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68799, "title": "librustc_driver: Make --print file-names do a minor accounting of --emit", "body": "Otherwise we print bogus output which prevents using `cargo check` with sccache,\r\nsee https://bugzilla.mozilla.org/show_bug.cgi?id=1612855#c2 for a reduced\r\ntest-case.\r\n\r\nIdeally --print file-names will emit only the files emitted by the session, but\r\nthat seems a bit hard to do in a general way, so this is a best effort thing\r\nwhich fixes the cargo check use-case.", "labels": ["S-waiting-on-review"], "number_of_comments": 5, "created_at": "2020-02-03 15:32:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "559087268": {"author_username": "Farkal", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68796, "title": "Large compile times with repetitive trait bound", "body": "I am using wundergraph that generate lot of macro code and it seems rustc have hard time resolving code [here](https://github.com/weiznich/wundergraph/blob/8bc544f278e97dcd94ac87b755fe2b60100de18e/wundergraph/src/macros/query.rs#L212-L273) and [here](https://github.com/weiznich/wundergraph/blob/8bc544f278e97dcd94ac87b755fe2b60100de18e/wundergraph/src/macros/mutation.rs#L494-L531) \r\n\r\nI tried this code:\r\nhttps://github.com/Farkal/test-wundergraph\r\n\r\nI expected to see this happen: \r\nLess than 40sc of compilation on each change\r\n\r\nInstead, this happened:\r\n40sc or more of compilation\r\n\r\n## Meta\r\n\r\n`rustc --version --verbose`:\r\nrustc 1.41.0 (5e1a79984 2020-01-27)\r\nbinary: rustc\r\ncommit-hash: 5e1a799842ba6ed4a57e91f7ab9435947482f7d8\r\ncommit-date: 2020-01-27\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.41.0\r\nLLVM version: 9.0", "labels": ["A-traits", "C-enhancement", "E-needs-mcve", "I-compiletime", "T-compiler"], "number_of_comments": 3, "created_at": "2020-02-03 13:34:25", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558966796": {"author_username": "ajpaverd", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68793, "title": "Tracking issue for `-Z control_flow_guard`", "body": "This is a tracking issue for the flag to enable Windows Control Flow Guard, added in #68180. ", "labels": ["B-unstable", "C-tracking-issue", "O-windows-msvc", "T-compiler"], "number_of_comments": 1, "created_at": "2020-02-03 09:52:22", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558772018": {"author_username": "lf-", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68786, "title": "Diagnostic for E0596 points at the wrong borrow?", "body": "I was writing the following function but forgot to put `.as_mut_slice()` rather than `.as_slice()`:\r\n\r\n```rust\r\nfn find_closest(input: &str, options: &Vec<&str>) {\r\n    let mut distances: Vec<_> = options\r\n        .iter()\r\n        .map(|_| (\"a\", 1.)) // actual code removed but types are the same\r\n        .collect();\r\n    distances\r\n        .as_slice()\r\n        .sort_unstable_by(|a, b| a.1.partial_cmp(&b.1).unwrap());\r\n}\r\n```\r\n\r\nThis produced a `E0596`, with a message that I had trouble with as someone new to Rust:\r\n\r\n```\r\nerror[E0596]: cannot borrow data in a `&` reference as mutable\r\n  --> src\\app.rs:18:5\r\n   |\r\n18 | /     distances\r\n19 | |         .as_slice()\r\n   | |___________________^ cannot borrow as mutable\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\nWhen trying to figure out what the compiler was taking issue with, I thought that it meant that it wanted the elements in the Vec to be themselves mutable, which didn't make any sense to me.\r\n\r\nI think the diagnostic is referring to the borrow done by the `.sort_unstable_by(F)`, but it is not pointing at it and the current message can be misread as meaning that the `.as_slice()` is borrowing something improperly itself, which it is not.\r\n\r\nThe diagnostic would be more helpful if it was something like this:\r\n\r\n```\r\nerror[E0596]: cannot borrow data in a `&` reference as mutable\r\n  --> src\\app.rs:18:5\r\n   |\r\n18 | /     distances\r\n19 | |         .as_slice()\r\n20 | |         .sort_unstable_by(|a, b| a.1.partial_cmp(&b.1).unwrap());\r\n   | |_____________^ sort_unstable_by cannot borrow &self as mutable\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\n```\r\nrustc --version\r\nrustc 1.42.0-nightly (212b2c7da 2020-01-30)\r\n```", "labels": ["A-borrow-checker", "A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 2, "created_at": "2020-02-02 22:56:07", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558755586": {"author_username": "bjorn3", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68780, "title": "Optimize SpecializedDecoder<Span> and SpecializedEncoder<Span> for CacheDecoder", "body": "https://github.com/rust-lang/rust/blob/175631311716d7dfeceec40d2587cde7142ffa8c/src/librustc/ty/query/on_disk_cache.rs#L567\r\n\r\nhttps://github.com/rust-lang/rust/blob/175631311716d7dfeceec40d2587cde7142ffa8c/src/librustc/ty/query/on_disk_cache.rs#L780\r\n\r\nThey each account for about 2.5% of a clean incremental build of libcore.\r\n\r\nI don't know how hard it would be to optimize them, but because they are hot, I think it is worth giving it a try.", "labels": ["A-incr-comp", "C-enhancement", "I-compiletime", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-02 20:49:01", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558754812": {"author_username": "bjorn3", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68779, "title": "Why does rustc_serialize use uleb128 to encode all integers?", "body": "Especially for small integers like u16, the memory save is likely very small, while the extra instructions likely result in a slowdown.\r\n\r\nhttps://github.com/rust-lang/rust/blob/212b2c7da87f3086af535b33a9ca6b5242f2d5a7/src/libserialize/opaque.rs#L73-L75", "labels": ["C-enhancement", "I-compiletime", "T-compiler"], "number_of_comments": 0, "created_at": "2020-02-02 20:43:25", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558732132": {"author_username": "wdanilo", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68776, "title": "Specialization of associated types do not compile, while it should.", "body": "Hi, consider the following code:\r\n\r\n```rust\r\n#![feature(specialization)]\r\n\r\nuse core::ops::Deref;\r\nuse std::rc::Rc;\r\n\r\npub trait HasContent {\r\n    type Content : ?Sized;\r\n}\r\n\r\npub type Content<T> = <T as HasContent>::Content;\r\n\r\npub trait Unwrap : HasContent {\r\n    fn unwrap(&self) -> &Self::Content;\r\n}\r\n\r\ndefault impl<T:Deref> HasContent for T {\r\n    type Content = <Self as Deref>::Target;\r\n}\r\n\r\ndefault impl<T> Unwrap for T\r\nwhere T:Deref<Target=Content<T>> {\r\n    fn unwrap (&self) -> &Self::Content {\r\n        self.deref()\r\n    }\r\n}\r\n\r\nimpl<T:?Sized> Unwrap     for Rc<T> {}\r\nimpl<T:?Sized> HasContent for Rc<T> { type Content = T; }\r\n```\r\n\r\nIt compiles fine. However, if we change the last line to:\r\n\r\n```rust\r\nimpl<T:?Sized> HasContent for Rc<T> {}\r\n```\r\n\r\nIt does not anymore:\r\n```\r\nconflicting implementations of trait `Unwrap` for type `std::rc::Rc<_>`\r\n```\r\n\r\nPlayground: https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=588c3a6580482515580e65e977f5b778\r\n\r\nI believe it should compile as the default impl should resolve to the same thing as the original code.", "labels": ["A-associated-items", "A-specialization", "C-bug", "F-specialization", "T-compiler", "T-lang", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-02-02 17:57:56", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558693450": {"author_username": "ssomers", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68770, "title": "BTreeMap/BTreeSet: implement drain_filter ", "body": "Provide an implementation of drain_filter for BTreeMap and BTreeSet. Should be optimal when the predicate picks only elements in leaf nodes with at least MIN_LEN remaining elements, which is a common case, at least when draining only a fraction of the map/set, and also elements stored in internal nodes where the right subtree can easily let go of a replacement element.\r\n\r\nThe first commit adds benchmarks with an external, naive implementation and benchmarks of `remove` itself.", "labels": ["S-waiting-on-author"], "number_of_comments": 8, "created_at": "2020-02-02 13:01:31", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558657211": {"author_username": "Riey", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68761, "title": "Impl From between Option<NonZeroInt> <-> Int", "body": "Those types have same memory layout and often converted each other\r\nbut conversion is little verbose\r\n\r\n```rust\r\n\r\nlet a: Option<NonZeroU32> = NonZeroU32::new(0);\r\nlet b: u32 = 0;\r\n\r\n// Before\r\nfn foo(n: Option<NonZeroU32>);\r\nfn bar(n: u32);\r\n\r\nfoo(a);\r\nfoo(NonZeroU32::new(b));\r\nbar(a.map_or(0, |a| a.get()));\r\nbar(b);\r\n\r\n// After\r\nfn foo(n: impl Into<Option<NonZeroU32>>);\r\nfn bar(n: impl Into<u32>);\r\n\r\nfoo(a);\r\nfoo(b);\r\nbar(a);\r\nbar(b);\r\n```", "labels": ["S-waiting-on-review", "T-libs", "relnotes"], "number_of_comments": 7, "created_at": "2020-02-02 07:40:39", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558643699": {"author_username": "95th", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68759, "title": "Async await mulitple lifetimes issue with `Box`", "body": "Following code is not accepted ATM ([play](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=d7c4f1f4abd479080634d6b5e3bf08af)):\r\n\r\n```rust\r\npub trait A {}\r\n\r\npub struct B {\r\n    a: Box<dyn A>,\r\n}\r\n\r\nimpl B {\r\n    pub async fn new(a: Box<dyn A>, x: &(), y: &()) -> B {\r\n        B { a }\r\n    }\r\n}\r\n```\r\nError:\r\n\r\n```rust\r\nerror[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\r\n  --> src/main.rs:10:56\r\n   |\r\n10 |     pub async fn new(a: Box<dyn A>, x: &(), y: &()) -> B {\r\n   |                                                        ^\r\n   |\r\nnote: hidden type `impl std::future::Future` captures the scope of call-site for function at 10:58\r\n  --> src/main.rs:10:58\r\n   |\r\n10 |       pub async fn new(a: Box<dyn A>, x: &(), y: &()) -> B {\r\n   |  __________________________________________________________^\r\n11 | |         B { a }\r\n12 | |     }\r\n   | |_____^\r\n\r\n```\r\n\r\nHowever, the following code is accepted:\r\n\r\n```rust\r\npub trait A {}\r\n\r\npub struct B<A> {\r\n    a: A,\r\n}\r\n\r\nimpl<X: A> B<X> {\r\n    pub async fn new(a: X, x: &(), y: &()) -> B<X> {\r\n        B { a }\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\nI know one can workaround this by using `impl trait` with explicit lifetimes, but this is an ergonomics issue.", "labels": ["A-async-await", "AsyncAwait-OnDeck", "AsyncAwait-Triaged", "C-feature-request", "T-lang"], "number_of_comments": 1, "created_at": "2020-02-02 05:03:09", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558607974": {"author_username": "Diggsey", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68748, "title": "Recursive type error is over-eager", "body": "Example code:\r\n```rust\r\nuse std::marker::PhantomData;\r\n\r\ntrait Request {\r\n    type Downgraded: Request;\r\n}\r\n\r\nenum Test<R: Request> {\r\n    A(PhantomData<dyn FnOnce() -> R>),\r\n    B(Test<R::Downgraded>),\r\n}\r\n```\r\n\r\nThis code will error with `error[E0072]: recursive type `Test` has infinite size`, but it doesn't necessarily *have* infinite size, it depends how the chain of \"request downgrades\" is terminated.\r\n\r\nFor example, if I terminate the downgrade chain by defining a request that downgrades to itself, and is uninhabited, then the enum makes perfect sense.", "labels": ["C-feature-request", "T-doc", "T-lang"], "number_of_comments": 9, "created_at": "2020-02-01 22:27:01", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558602800": {"author_username": "matthewjasper", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68746, "title": "Make macro metavars respect (non-)hygiene", "body": "Opening to see whether this breaks things, in with case it can be limited to macros 2.0.\r\n\r\nr? @ghost", "labels": ["S-waiting-on-review"], "number_of_comments": 12, "created_at": "2020-02-01 21:46:51", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558601040": {"author_username": "ecstatic-morse", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68743, "title": "Initializers of stable constants can call const unstable functions", "body": "Crates using `staged_api` are forbidden from calling const unstable functions from stable const functions. However, this restriction [does not extend](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=53d0049a668c92684fd26fc76eafad21) to the initializers of consts or statics. Although unlikely, this could allow for \"backdoor stabilization\" of various const-eval features. For example, the following would lock in the current implementation of `const_if_match`.\r\n\r\n```rust\r\n#![stable(feature = \"bar\", since = \"1.34\")]\r\n\r\n#![feature(staged_api)]\r\n#![feature(const_if_match)]\r\n#![feature(foo)]\r\n\r\n#[rustc_const_unstable(feature = \"foo\", issue = \"0\")]\r\nconst fn foo() -> i32 {\r\n    if true { 0 } else { 1 }\r\n}\r\n\r\n#[stable(feature = \"bar\", since = \"1.34\")]\r\npub const BAR: i32 = foo();\r\n```\r\n\r\nIf `BAR` were a `const fn` instead of a `const`, that example would be rejected.\r\n\r\n```rust\r\n#[rustc_const_stable(feature = \"bar\", since = \"1.34\")]\r\npub const fn bar() -> i32 {\r\n    foo()\r\n}\r\n```\r\n\r\ncc @rust-lang/wg-const-eval ", "labels": ["A-const-eval", "A-stability", "C-bug", "T-compiler"], "number_of_comments": 4, "created_at": "2020-02-01 21:32:18", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558572321": {"author_username": "GuillaumeGomez", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68734, "title": "Rustdoc copy local img", "body": "Fixes #32104.\r\n\r\nr? @kinnison ", "labels": ["S-waiting-on-author"], "number_of_comments": 7, "created_at": "2020-02-01 17:42:01", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558546080": {"author_username": "yaa110", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68729, "title": "Unable to compile syntex_syntax using Rust 1.41", "body": "Unfortunately, syntex_syntax is not maintained and is not compiled using rust 1.41:\r\n\r\n```rust\r\n   Compiling syntex_syntax v0.58.1\r\nerror[E0423]: expected function, tuple struct or tuple variant, found struct `ast::Name`\r\n   --> /root/.cargo/registry/src/github.com-1ecc6299db9ec823/syntex_syntax-0.58.1/src/symbol.rs:146:27\r\n    |\r\n146 |                       name: ast::Name($index),\r\n    |                             ^^^^^^^^^\r\n...\r\n165 | / declare_keywords! {\r\n166 | |     // Invalid identifier\r\n167 | |     (0,  Invalid,        \"\")\r\n168 | |\r\n...   |\r\n231 | |     (56, CrateRoot, \"{{root}}\")\r\n232 | | }\r\n    | |_- in this macro invocation\r\n\r\n   Compiling clap v2.33.0\r\n   Compiling nom v3.2.1\r\n   Compiling parking_lot v0.10.0\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0423`.\r\nerror: could not compile `syntex_syntax`.\r\nwarning: build failed, waiting for other jobs to finish...\r\nerror: build failed\r\nmake[1]: *** [objs/Makefile:1314: cargo] Error 101\r\n```\r\n\r\n```\r\n# rustc --version\r\nrustc 1.41.0 (5e1a79984 2020-01-27)\r\n\r\n# uname -a\r\nLinux 6b52ecd4014b 5.3.18-1-MANJARO #1 SMP PREEMPT Wed Dec 18 18:34:35 UTC 2019 x86_64 GNU/Linux\r\n```", "labels": ["I-nominated", "P-low", "T-compiler", "regression-from-stable-to-stable"], "number_of_comments": 4, "created_at": "2020-02-01 14:12:03", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558447467": {"author_username": "Arnavion", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68721, "title": "static mut bindings don't raise unused_mut diagnostic", "body": "```rust\r\n#[deny(unused_mut)]\r\npub unsafe fn foo() {\r\n    static mut X: std::sync::Once = std::sync::Once::new();\r\n    X.call_once(|| { /**/ });\r\n}\r\n```\r\n\r\n... [compiles fine.](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=eb6b3a8bd59dee6e53161934988de3e7) Using `let mut X` does fail as expected.\r\n\r\nI can imagine it would be hard to do this for module-scoped `static`s since the mutable access could occur in any scope the value is visible to, but could it be done for function-scoped ones at least?\r\n\r\n---\r\n\r\nI discovered this in a crate with a bunch of function-scoped `Once`s, and just happened to notice some of them had been created with `static mut` and others with just `static`, indicating the `mut` was unnecessary even though the compiler didn't complain.", "labels": ["A-lint", "C-enhancement", "T-lang"], "number_of_comments": 1, "created_at": "2020-02-01 00:46:07", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558409210": {"author_username": "petrochenkov", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68717, "title": "Stabilize fn-like proc macros in expression, pattern and statement positions", "body": "I.e. all the positions in which stable `macro_rules` macros are supported.\r\n\r\nDepends on https://github.com/rust-lang/rust/pull/68716 (\"Stabilize `Span::mixed_site`\").\r\n\r\ncc https://github.com/rust-lang/rust/issues/54727\r\ncc https://github.com/rust-lang/rust/issues/54727#issuecomment-580647446\r\n\r\nTODO: Write a stabilization report.", "labels": ["S-blocked", "T-lang", "relnotes"], "number_of_comments": 3, "created_at": "2020-01-31 22:33:33", "reactions": {"total_count": 24, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 24}}, "558408264": {"author_username": "petrochenkov", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68716, "title": "Stabilize `Span::mixed_site`", "body": "Closes https://github.com/rust-lang/rust/issues/65049.\r\ncc https://github.com/rust-lang/rust/issues/54727#issuecomment-580647446\r\n\r\nPre-requisite for https://github.com/rust-lang/rust/pull/68717 (\"Stabilize fn-like proc macros in expression, pattern and statement positions\").\r\n\r\nStabilization report: https://github.com/rust-lang/rust/pull/68716#issuecomment-581076337.", "labels": ["A-macros", "S-waiting-on-review", "T-lang", "T-libs", "needs-fcp", "relnotes"], "number_of_comments": 33, "created_at": "2020-01-31 22:31:02", "reactions": {"total_count": 9, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 9}}, "558386189": {"author_username": "petrochenkov", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68715, "title": "rustbuild: LLVM is not partially rebuilt anymore", "body": "Even tiny changes like https://github.com/rust-lang/rust/pull/68570 cause a full rebuild.\r\n\r\nThis is a regression from the few recent months (?).\r\nBefore that partial rebuilds worked, I remember it because I implemented them back in 2017 (https://github.com/rust-lang/rust/pull/40329).\r\n\r\nI didn't yet investigate what happens exactly.", "labels": ["A-LLVM", "A-rustbuild"], "number_of_comments": 2, "created_at": "2020-01-31 21:38:33", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558381338": {"author_username": "cuviper", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68714, "title": "tools cannot find `-lLLVM` in a non-standard link path", "body": "In my build of Rust 1.41 on EPEL7, I see link failures first for `clippy` and `rls`, which are allowed by rustbuild, and then a hard failure on `rustdoc`.\r\n\r\n```\r\n   Compiling rustdoc-tool v0.0.0 (/builddir/build/BUILD/rustc-1.41.0-src/src/tools/rustdoc)\r\nerror: linking with `cc` failed: exit code: 1\r\n  |\r\n  = note: \"cc\" \"-Wl,--as-needed\" [...] \"-L\" \"/builddir/build/BUILD/rustc-1.41.0-src/build/x86_64-unknown-linux-gnu/stage1/lib/rustlib/x86_64-unknown-linux-gnu/lib\" \"-Wl,-Bdynamic\" \"-lrustc_driver-8eceda5ae2b7dbad\" [...] \"-lLLVM-7\" [...]\r\n  = note: /usr/bin/ld: cannot find -lLLVM-7\r\n          collect2: error: ld returned 1 exit status\r\n```\r\n\r\nThis seems to be a recurrence of https://github.com/rust-lang/rust/issues/40717#issuecomment-289605284, where the `-l` link library for LLVM is passed on to dependent crates, but the `-L` library path is not, so it fails to actually link the tools.\r\n\r\nI called out `librustc_driver` in the excerpted link line above, because in a normal build with dynamic LLVM, that's the only thing that actually uses LLVM symbols. The `rustdoc` binary does not usually end up with a direct dependency on LLVM, so it doesn't _really_ need that `-lLLVM` at all.\r\n\r\nThe problem in #40717 went away once we started loading codegen dynamically in #47671. However, #67077 started linking LLVM directly again, and this just reached stable 1.41.\r\n\r\nMy former workaround of setting `LIBRARY_PATH=$(llvm-config --libdir)` still works. This is specifically the compile-time link path, not the runtime `LD_LIBRARY_PATH`. Maybe we could kludge that into rustbuild somehow?", "labels": [], "number_of_comments": 1, "created_at": "2020-01-31 21:26:53", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558347147": {"author_username": "HeroicKatora", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68712, "title": "Add methods to 'leak' RefCell borrows as references with the lifetime of the original reference", "body": "Usually, references to the interior are only created by the `Deref` and\r\n`DerefMut` impl of the guards `Ref` and `RefMut`. Note that `RefCell`\r\nalready has to cope with leaks of such guards which, when it occurs,\r\neffectively makes it impossible to ever acquire a mutable guard or any\r\nguard for `Ref` and `RefMut` respectively. It is already safe to use\r\nthis to create a reference to the inner of the ref cell that lives as\r\nlong as the reference to the `RefCell` itself, e.g.\r\n\r\n```rust\r\nfn leak(r: &RefCell<usize>) -> Option<&usize> {\r\n    let guard = r.try_borrow().ok()?;\r\n    let leaked = Box::leak(Box::new(guard));\r\n    Some(&*leaked)\r\n}\r\n```\r\n\r\nThe newly added methods allow the same reference conversion without an\r\nindirection over a leaked allocation. It's placed on the `Ref`/`RefMut` to \r\ncompose with both borrow and try_borrow directly.", "labels": ["S-waiting-on-review"], "number_of_comments": 4, "created_at": "2020-01-31 20:09:37", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558307260": {"author_username": "mgattozzi", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68709, "title": "Breaking Change in Vec::truncate drop order between 1.40 -> 1.41", "body": "Context:\r\n[The commit that introduced the change.](https://github.com/rust-lang/rust/commit/9e8c4e6fb1c952048fb823e59f4c9c6487bf9a58)\r\n[The PR for the commit](https://github.com/rust-lang/rust/pull/64432)\r\n\r\nMinimal repro can be found in the commit and the PR. At work we have a private internal crate that depended on this drop ordering. As we had not run the beta train we did not catch it until attempting to upgrade our stable version of rust to 1.41.0. Now while the behavior of the drop order was unspecified it has been stabilized.\r\n\r\nI'm sure we can find a workaround for this at work, but I'm filing this issue as it brings up some interesting questions that I don't know if the libs team has ever taken an official stance on.\r\n\r\nIf the observable behavior changes but isn't specified is this a breaking change?\r\nThe API itself has not changed, but the drop order has changed. I'm of the opinion it is a breaking change even if it brings the API more in line with how slice drop order works, though talking to some friends they are of the opinion it is not a breaking change.\r\n\r\nAnyways I wanted to file this issue to bring attention to this and maybe get a more clear ruling from the libs team on what they consider is and is not breaking change behavior. If more info is needed on why we needed this @estebank and I can probably give more specifics on this, though I don't think this is so much trying to fix a bug as it is determining whether a change should be reverted.\r\n\r\nThanks! \ud83d\ude04 ", "labels": ["A-collections", "I-nominated", "T-libs", "regression-from-stable-to-stable"], "number_of_comments": 7, "created_at": "2020-01-31 18:46:12", "reactions": {"total_count": 5, "+1": 4, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558256777": {"author_username": "Lokathor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68707, "title": "Format string can't contain \"<{var:}>\"", "body": "https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=7ce4bc1f30fade52a6c0b177d8b7e2da\r\n\r\n```rust\r\nfn main() {\r\n    let c = \"hello\";\r\n    println!(\"{ch:}\", ch = c);\r\n    println!(\"<{ch}>\", ch = c);\r\n    println!(\"<{ch:}>\", ch = c);\r\n}\r\n```\r\n\r\nThis gives a formatting error on the 3rd line for unclear reasons. The playground link is for Nightly but this also appears to be a bug with Stable.", "labels": ["A-diagnostics", "A-macros"], "number_of_comments": 9, "created_at": "2020-01-31 17:12:38", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558198257": {"author_username": "Nokel81", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68703, "title": "Oddity in what lines count towards coverage", "body": "I asked this over on `mozilla/grcov` but then realized that it is better suited to here.\r\n\r\nWhile using the following `RUSTFLAGS` to generate coverage reports I have found some odditites with what is considers to be covered/not-covered/not-needed to be covered.\r\n\r\n```\r\n-Zprofile -Ccodegen-units=1 -Cinline-threshold=0 -Clink-dead-code -Coverflow-checks=off -Zno-landing-pads\r\n```\r\n\r\n1. Test functions (all of `mod tests`) are counted towards coverage\r\n2. Some comments (including doc comments) are counted towards coverage (and sometimes not covered even though the \"line\" was passed through)\r\n3. struct/enum definitions (even if that variant/type is used or created)\r\n4. trait definitions (even if a type which implements that trait is used through a trait typed variable)\r\n5. Close braces (even if both branches are taken)\r\n6. use statements\r\n\r\nWould it be possible to either add a flag to ignore these, or to just ignore them all the time?\r\n", "labels": ["A-debuginfo", "T-compiler"], "number_of_comments": 2, "created_at": "2020-01-31 15:27:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "558136486": {"author_username": "withoutboats", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68700, "title": "Add Wake trait for safe construction of Wakers.", "body": "Currently, constructing a waker requires calling the unsafe `Waker::from_raw` API. This API requires the user to manually construct a vtable for the waker themself - which is both cumbersome and very error prone. This API would provide an ergonomic, straightforward and guaranteed memory-safe way of constructing a waker.\r\n\r\nIt has been our longstanding intention that the `Waker` type essentially function as an `Arc<dyn Wake>`, with a `Wake` trait as defined here. Two considerations prevented the original API from being shipped as simply an `Arc<dyn Wake>`:\r\n\r\n- We want to support futures on embedded systems, which may not have an allocator, and in optimized executors for which this API may not be best-suited. Therefore, we have always explicitly supported the maximally-flexible (but also memory-unsafe) `RawWaker` API, and `Waker` has always lived in libcore.\r\n- Because `Waker` lives in libcore and `Arc` lives in liballoc, it has not been feasible to provide a constructor for `Waker` from `Arc<dyn Wake>`.\r\n\r\nTherefore, the Wake trait was left out of the initial version of the task waker API.\r\n\r\nHowever, as Rust 1.41, it is possible under the more flexible orphan rules to implement `From<Arc<W>> for Waker where W: Wake` in liballoc. Therefore, we can now define this constructor even though `Waker` lives in libcore.\r\n\r\nThis PR adds these APIs:\r\n\r\n- A `Wake` trait, which contains two methods\r\n    - A required method `wake`, which is called by `Waker::wake`\r\n    - A provided method `wake_by_ref`, which is called by `Waker::wake_by_ref` and which implementors can override if they can optimize this use case.\r\n- An implementation of `From<Arc<W>> for Waker where W: Wake + Send + Sync + 'static`\r\n- A similar implementation of `From<Arc<W>> for RawWaker`.", "labels": ["A-async-await", "S-waiting-on-review", "T-libs", "disposition-merge", "finished-final-comment-period"], "number_of_comments": 19, "created_at": "2020-01-31 13:36:35", "reactions": {"total_count": 18, "+1": 0, "-1": 0, "laugh": 0, "heart": 8, "hooray": 9}}, "558130628": {"author_username": "GuillaumeGomez", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68699, "title": "Keep code coloring in search results short text", "body": "Fixes #32040.\r\n\r\n![Screenshot from 2020-01-31 14-11-32](https://user-images.githubusercontent.com/3050060/73542288-a2e31280-4434-11ea-8142-e6dab3247986.png)\r\n\r\nr? @kinnison ", "labels": ["S-waiting-on-author"], "number_of_comments": 13, "created_at": "2020-01-31 13:25:24", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 1, "hooray": 0}}, "558029517": {"author_username": "Centril", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68697, "title": "Suggest removing `&mut x` when `x: &mut T` and `&mut T` is expected type", "body": "An example:\r\n```rust\r\nstruct A;\r\n\r\nfn bar(x: &mut A) {}\r\n\r\nfn foo(x: &mut A) {\r\n    bar(&mut x);\r\n}\r\n```\r\nresults in:\r\n```rust\r\nerror[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\r\n --> src/lib.rs:6:9\r\n  |\r\n5 | fn foo(x: &mut A) {\r\n  |        - help: consider changing this to be mutable: `mut x`\r\n6 |     bar(&mut x);\r\n  |         ^^^^^^ cannot borrow as mutable\r\n```\r\nbut we could say:\r\n```rust\r\nerror[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\r\n --> src/lib.rs:6:9\r\n  |\r\n5 | fn foo(x: &mut A) {\r\n6 |     bar(&mut x);\r\n  |         ^^^^^^ cannot borrow as mutable\r\n  |         ---- help: remove the unnecessary `&mut` here\r\n```\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\n\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":null}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "labels": ["A-borrow-checker", "A-diagnostics", "A-typesystem", "C-enhancement", "D-incorrect", "T-compiler"], "number_of_comments": 4, "created_at": "2020-01-31 09:59:12", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557923927": {"author_username": "jyn514", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68692, "title": "impl From<[T; N]> for Vec<T>", "body": "Closes https://github.com/rust-lang/rust/issues/67963", "labels": ["S-waiting-on-review", "T-libs", "needs-fcp", "relnotes"], "number_of_comments": 11, "created_at": "2020-01-31 05:32:32", "reactions": {"total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "heart": 3, "hooray": 0}}, "557846210": {"author_username": "Zoxc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68687, "title": "Only assign dep node indices in non-incremental mode if self profiling is active", "body": "r? @michaelwoerister ", "labels": ["S-waiting-on-author"], "number_of_comments": 10, "created_at": "2020-01-31 00:52:29", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557843361": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68686, "title": "Span hygiene data should be serialized to crate metadata", "body": "When we serialize a `Span` to crate metadata, we currently throw away the `SyntaxContext`: https://github.com/rust-lang/rust/blob/34700c15c7a49d400951da385b2eacab6fb6fe86/src/librustc_span/lib.rs#L631-L650\r\n\r\nThis is because the backing `HygieneData` is stored in a thread-local in `rustc_span`, and not serialized into crate metadata.\r\n\r\nThe result is that spans deserialized from crate metadata may have less information available than spans from the current crate. If the MIR inlining pass decides to inline a function from another crate, we may end up with suboptimal messages when we invoke `span.ctxt()` (e.g. when emitting debuginfo, and when evaluating the `caller_location` intrinsic).\r\n\r\nIt would be useful if we were to serialize `HygieneData` into crate metadata, and deserialize spans with the proper `SyntaxContext`. This will also ensure that parallel compilation works properly, since storing `HygieneData` in a thread local will cause problems if a `Span` is used on multiple threads.\r\n\r\nI'm not really sure how best to go about doing this. `ExpnId`s are currently unique per-crate, since they are never serialized. We need some way of making `ExpnIds` globally unique.\r\n", "labels": ["A-macros", "A-metadata", "C-enhancement", "T-compiler"], "number_of_comments": 3, "created_at": "2020-01-31 00:43:11", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557814549": {"author_username": "LeSeulArtichaut", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68682, "title": "Add documentation to compiler intrinsics", "body": "This adds documentation to the compiler intrinsics having stable standard implementations.\r\n\r\nRelates to #34338 (cc @bstrie)\r\n\r\nr? @steveklabnik (for reassignment?)", "labels": ["S-waiting-on-author", "T-doc"], "number_of_comments": 6, "created_at": "2020-01-30 23:16:35", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557698725": {"author_username": "lilyball", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68676, "title": "rust/RELEASES.md doesn't list the Box<T> FFI change for 1.41.0", "body": "The [announcement post](https://blog.rust-lang.org/2020/01/30/Rust-1.41.0.html) for Rust 1.41.0 talks about `Box<T>` now being ABI-compatible with C's `T*` type, but I can't find any mention of that in the [detailed release notes](https://github.com/rust-lang/rust/blob/master/RELEASES.md#version-1410-2020-01-30).", "labels": ["C-bug", "T-release"], "number_of_comments": 1, "created_at": "2020-01-30 19:21:21", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557597115": {"author_username": "roy-work", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68674, "title": "RUST_BACKTRACE=1 incorrectly reports _main as the name of the symbol before _main in the binary", "body": "The last / earliest frame in a `RUST_BACKTRACE=1` output is named incorrectly; it appears the correct name should be `_main` or `main`, but the symbol I get is always whatever symbol precedes `_main` in the actual binary.\r\n\r\nNote that I'm referring to the low-level entrypoint of the binary, not the `fn main()` that the user writes. That `fn main()` also appears in the trace, in the correct place and named correctly, but it is not the last frame, as several other frames precede it, which is the Rust runtime setting itself up. \r\n\r\nFor example, if I run my current project with `RUST_BACKTRACE=1`, it panics.\r\n\r\n(the actual cause of the panic is my fault; this bug is only about the output that `RUST_BACKTRACE` emits after that crash)\r\n\r\nWe get<sup>1</sup>:\r\n```\r\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: NamedSubprocessError { subprocess_name: \"ssh\", error: Failed(1) }', src/libcore/result.rs:1165:5\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:61\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1028\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1412\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:65\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:50\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:188\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:205\r\n  10: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:464\r\n  11: std::panicking::continue_panic_fmt\r\n             at src/libstd/panicking.rs:373\r\n  12: rust_begin_unwind\r\n             at src/libstd/panicking.rs:302\r\n  13: core::panicking::panic_fmt\r\n             at src/libcore/panicking.rs:139\r\n  14: core::result::unwrap_failed\r\n             at src/libcore/result.rs:1165\r\n  15: core::result::Result<T,E>::unwrap\r\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libcore/result.rs:933\r\n  16: project_name::main\r\n             at [snip]/src/main.rs:139\r\n  17: std::rt::lang_start::{{closure}}\r\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/rt.rs:61\r\n  18: std::rt::lang_start_internal::{{closure}}\r\n             at src/libstd/rt.rs:48\r\n  19: std::panicking::try::do_call\r\n             at src/libstd/panicking.rs:287\r\n  20: __rust_maybe_catch_panic\r\n             at src/libpanic_unwind/lib.rs:78\r\n  21: std::panicking::try\r\n             at src/libstd/panicking.rs:265\r\n  22: std::panic::catch_unwind\r\n             at src/libstd/panic.rs:396\r\n  23: std::rt::lang_start_internal\r\n             at src/libstd/rt.rs:47\r\n  24: std::rt::lang_start\r\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/rt.rs:61\r\n  25: <project_name::_IMPL_DESERIALIZE_FOR_NameOfAStructThatImpsDeserialize::<impl serde::de::Deserialize for project_name::NameOfAStructThatImpsDeserialize>::deserialize::__Visitor as serde::de::Visitor>::expecting\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n```\r\n\r\nNote these frames in particular:\r\n```\r\n  16: project_name::main\r\n             at [snip]/src/main.rs:139\r\n  17: std::rt::lang_start::{{closure}}\r\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/rt.rs:61\r\n  24: std::rt::lang_start\r\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/rt.rs:61\r\n  25: <project_name::_IMPL_DESERIALIZE_FOR_NameOfAStructThatImpsDeserialize::<impl serde::de::Deserialize for project_name::NameOfAStructThatImpsDeserialize>::deserialize::__Visitor as serde::de::Visitor>::expecting\r\n```\r\nThat is, my `fn main()` is being called by `lang_start`; that's expected. `lang_start` is being called by \u2026 a serde derive? That's not expected.\r\n\r\nIf I run this in `lldb`, and put a breakpoint: `(lldb) b core::panicking::panic_fmt`, and then it pauses. `lldb` does not appear confused about where we are, and shows this frame as:\r\n```\r\n(lldb) up\r\nframe #12: 0x000000010000cb02 project-name`std::rt::lang_start::he84252c74d1ae0a2(main=(project-name`project_name::main::hf1a57fdc1eddf2ac at main.rs:53), argc=13, argv=0x00007ffeefbff078) at rt.rs:61:4\r\n(lldb) up\r\nframe #13: 0x000000010000a832 project-name`main + 34\r\n```\r\n\r\nSo, LLDB seems to think that frame is `main` (and that's a C name, not a Rust name). Reasonable if it is the entrypoint to the binary.\r\n\r\nAnd if we do some disassesmbly:\r\n```\r\n(lldb) disassemble --frame\r\nproject-name`main:\r\n    0x10000a810 <+0>:  pushq  %rbp\r\n    0x10000a811 <+1>:  movq   %rsp, %rbp\r\n    0x10000a814 <+4>:  subq   $0x10, %rsp\r\n    0x10000a818 <+8>:  movslq %edi, %rax\r\n    0x10000a81b <+11>: leaq   -0x6112(%rip), %rdi       ; project_name::main::hf1a57fdc1eddf2ac at main.rs:53\r\n    0x10000a822 <+18>: movq   %rsi, -0x8(%rbp)\r\n    0x10000a826 <+22>: movq   %rax, %rsi\r\n    0x10000a829 <+25>: movq   -0x8(%rbp), %rdx\r\n    0x10000a82d <+29>: callq  0x10000cac0               ; std::rt::lang_start::he84252c74d1ae0a2 at rt.rs:58\r\n->  0x10000a832 <+34>: addq   $0x10, %rsp\r\n    0x10000a836 <+38>: popq   %rbp\r\n    0x10000a837 <+39>: retq\r\n```\r\nThis is sort of what I expect for an entrypoint: we load the address of my `fn main`, and call into `lang_start`; this is definitely a binary entrypoint.\r\n\r\nHere, we're suspecting that `RUST_BACKTRACE=1` is just choosing some other symbol name for the frame. If we disassemble more of the binary:\r\n\r\n```\r\n__ZN207_$LT$project_name.._IMPL_DESERIALIZE_FOR_NameOfAStructThatImpsDeserialize..$LT$impl$u20$serde..de..Deserialize$u20$for$u20$project_name..NameOfAStructThatImpsDeserialize$GT$..deserialize..__Visitor$u20$as$u20$serde..de..Visitor$GT$9expecting17he4cce3311b14248cE:\r\n000000010000a7d0        pushq   %rbp\r\n000000010000a7d1        movq    %rsp, %rbp\r\n000000010000a7d4        subq    $0x20, %rsp\r\n000000010000a7d8        leaq    0x47555f(%rip), %rax\r\n000000010000a7df        movq    %rdi, -0x10(%rbp)\r\n000000010000a7e3        movq    %rsi, -0x8(%rbp)\r\n000000010000a7e7        movq    -0x8(%rbp), %rdi\r\n000000010000a7eb        movq    %rax, %rsi\r\n000000010000a7ee        movl    $0x19, %edx\r\n000000010000a7f3        callq   __ZN57_$LT$core..fmt..Formatter$u20$as$u20$core..fmt..Write$GT$9write_str17h68360bed214ad6ccE ## _$LT$core..fmt..Formatter$u20$as$u20$core..fmt..Write$GT$::write_str::h68360bed214ad6cc\r\n000000010000a7f8        movb    %al, -0x11(%rbp)\r\n000000010000a7fb        movb    -0x11(%rbp), %al\r\n000000010000a7fe        andb    $0x1, %al\r\n000000010000a800        movzbl  %al, %eax\r\n000000010000a803        addq    $0x20, %rsp\r\n000000010000a807        popq    %rbp\r\n000000010000a808        retq\r\n000000010000a809        nopl    (%rax)\r\n_main:\r\n000000010000a810        pushq   %rbp\r\n000000010000a811        movq    %rsp, %rbp\r\n000000010000a814        subq    $0x10, %rsp\r\n000000010000a818        movslq  %edi, %rax\r\n000000010000a81b        leaq    __ZN14project_name4main17hf1a57fdc1eddf2acE(%rip), %rdi ## project_name::main::hf1a57fdc1eddf2ac\r\n000000010000a822        movq    %rsi, -0x8(%rbp)\r\n000000010000a826        movq    %rax, %rsi\r\n000000010000a829        movq    -0x8(%rbp), %rdx\r\n000000010000a82d        callq   __ZN3std2rt10lang_start17he84252c74d1ae0a2E ## std::rt::lang_start::he84252c74d1ae0a2\r\n000000010000a832        addq    $0x10, %rsp\r\n000000010000a836        popq    %rbp\r\n000000010000a837        retq\r\n000000010000a838        nop\r\n000000010000a839        nop\r\n000000010000a83a        nop\r\n000000010000a83b        nop\r\n000000010000a83c        nop\r\n```\r\n\r\nHere, we can see that the weird symbol that `RUST_BACKTRACE=1` outputs does sort of correlate with the entrypoint: it's the symbol immediately before `_main` (`main` in LLDB). So, if `RUST_BACKTRACE=1` is ignoring non-Rust symbols when it figures out what to print\u2026 then that would explain why that frame is wrong.\r\n\r\nA minimal example suffices as well:\r\n```rust\r\nuse std::io;\r\n\r\nfn main() {\r\n    Err(io::Error::new(io::ErrorKind::InvalidData, \"error\")).unwrap()\r\n}\r\n```\r\n\r\nAnd a minimal `Cargo.toml`:\r\n```toml\r\n[package]\r\nname = \"the_crate_name\"\r\nversion = \"0.0.1\"\r\nedition = \"2018\"\r\n```\r\n\r\n```\r\n\u00bb RUST_BACKTRACE=1 cargo run\r\n   Compiling the_crate_name v0.0.1 (/Users/roy/code/random/bt2)\r\n    Finished dev [unoptimized + debuginfo] target(s) in 1.19s\r\n     Running `target/debug/the_crate_name`\r\nthread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Custom { kind: InvalidData, error: \"error\" }', src/libcore/result.rs:1165:5\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:61\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1028\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1412\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:65\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:50\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:188\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:205\r\n  10: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:464\r\n  11: std::panicking::continue_panic_fmt\r\n             at src/libstd/panicking.rs:373\r\n  12: rust_begin_unwind\r\n             at src/libstd/panicking.rs:302\r\n  13: core::panicking::panic_fmt\r\n             at src/libcore/panicking.rs:139\r\n  14: core::result::unwrap_failed\r\n             at src/libcore/result.rs:1165\r\n  15: core::result::Result<T,E>::unwrap\r\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libcore/result.rs:933\r\n  16: the_crate_name::main\r\n             at src/main.rs:4\r\n  17: std::rt::lang_start::{{closure}}\r\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/rt.rs:61\r\n  18: std::rt::lang_start_internal::{{closure}}\r\n             at src/libstd/rt.rs:48\r\n  19: std::panicking::try::do_call\r\n             at src/libstd/panicking.rs:287\r\n  20: __rust_maybe_catch_panic\r\n             at src/libpanic_unwind/lib.rs:78\r\n  21: std::panicking::try\r\n             at src/libstd/panicking.rs:265\r\n  22: std::panic::catch_unwind\r\n             at src/libstd/panic.rs:396\r\n  23: std::rt::lang_start_internal\r\n             at src/libstd/rt.rs:47\r\n  24: std::rt::lang_start\r\n             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/rt.rs:61\r\n  25: the_crate_name::main\r\n```\r\n\r\nAgain, `the_crate_name::main` in the last frame (frame 21) should perhaps read `main` or `_main`: it's not `the_crate_name::main` that's running there; `the_crate_name::main` is really frame 12. In a minimal example, we have very few symbols to choose from.\r\n\r\nAgain, the disassembly shows that `_main` is preceded by the symbol being output, here, `the_crate_name::main`:\r\n\r\n<details>\r\n  <summary>Click to expand disassembly</summary>\r\n<pre><code>__ZN14the_crate_name4main17h445f977752289da6E:\r\n0000000100001cb0        pushq   %rbp\r\n0000000100001cb1        movq    %rsp, %rbp\r\n0000000100001cb4        subq    $0x30, %rsp\r\n0000000100001cb8        leaq    0x1f55c(%rip), %rax\r\n0000000100001cbf        movb    $0xc, -0x1(%rbp)\r\n0000000100001cc3        leaq    -0x18(%rbp), %rdi\r\n0000000100001cc7        movzbl  -0x1(%rbp), %esi\r\n0000000100001ccb        movq    %rax, %rdx\r\n0000000100001cce        movl    $0x5, %ecx\r\n0000000100001cd3        callq   __ZN3std2io5error5Error3new17h7ad5cd9b8a04b0efE ## std::io::error::Error::new:\r\n:h7ad5cd9b8a04b0ef\r\n0000000100001cd8        movq    -0x18(%rbp), %rax\r\n0000000100001cdc        movq    %rax, -0x28(%rbp)\r\n0000000100001ce0        movq    -0x10(%rbp), %rax\r\n0000000100001ce4        movq    %rax, -0x20(%rbp)\r\n0000000100001ce8        leaq    -0x28(%rbp), %rdi\r\n0000000100001cec        callq   __ZN4core6result19Result$LT$T$C$E$GT$6unwrap17h9094cf16ad18ae1eE ## core::resu\r\nlt::Result$LT$T$C$E$GT$::unwrap::h9094cf16ad18ae1e\r\n0000000100001cf1        addq    $0x30, %rsp\r\n0000000100001cf5        popq    %rbp\r\n0000000100001cf6        retq\r\n0000000100001cf7        nopw    (%rax,%rax)\r\n_main:\r\n0000000100001d00        pushq   %rbp\r\n0000000100001d01        movq    %rsp, %rbp\r\n0000000100001d04        subq    $0x10, %rsp\r\n0000000100001d08        movslq  %edi, %rax\r\n0000000100001d0b        leaq    __ZN14the_crate_name4main17h445f977752289da6E(%rip), %rdi ## the_crate_name::main::h445f977752289da6\r\n0000000100001d12        movq    %rsi, -0x8(%rbp)\r\n0000000100001d16        movq    %rax, %rsi\r\n0000000100001d19        movq    -0x8(%rbp), %rdx\r\n0000000100001d1d        callq   __ZN3std2rt10lang_start17hc62f9e31cf02e7fdE ## std::rt::lang_start::hc62f9e31cf02e7fd\r\n0000000100001d22        addq    $0x10, %rsp\r\n0000000100001d26        popq    %rbp\r\n0000000100001d27        retq\r\n0000000100001d28        nop\r\n0000000100001d29        nop\r\n0000000100001d2a        nop\r\n0000000100001d2b        nop\r\n</code></pre>\r\n</details>\r\n\r\n**OS:** OS X Mojave\r\n**`rustc --version`:** `rustc 1.40.0 (73528e339 2019-12-16)`\r\n\r\n<sub><sup>1</sup>I've changed symbol names to remove the actual name of the project, as it relates to my employment. In the mangled symbol names, I have not updated the character counts, so they're not correct mangle-ings anymore.</sub>", "labels": ["A-runtime", "C-bug", "T-libs"], "number_of_comments": 0, "created_at": "2020-01-30 16:10:59", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557586388": {"author_username": "michaelwoerister", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68673, "title": "[Experiment] Export generic instances from libstd.", "body": "This should resolve issue #64140. However it is unclear if there are detrimental effects. Let's test if there are performance improvements to be had.\r\n\r\nr? @ghost", "labels": ["S-waiting-on-author"], "number_of_comments": 11, "created_at": "2020-01-30 15:55:03", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557517461": {"author_username": "Mark-Simulacrum", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68671, "title": "readonly variable warning on Azure pipelines", "body": "Overwriting readonly task variable 'RUST_CONFIGURE_ARGS'. This behavior will be disabled in the future. See https://github.com/microsoft/azure-pipelines-yaml/blob/master/design/readonly-variables.md for details.", "labels": ["P-high", "T-infra"], "number_of_comments": 1, "created_at": "2020-01-30 14:07:31", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557461475": {"author_username": "Pzixel", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68667, "title": "Rustc fails to optimize a common option usage pattern", "body": "Consider following functions\r\n\r\n```rust\r\npub fn unwrap_combinators(a: Option<i32>, b: i32) -> bool {\r\n    a.map(|t| t >= b)\r\n     .unwrap_or(false)\r\n}\r\n\r\npub fn unwrap_manual(a: Option<i32>, b: i32) -> bool {\r\n    match a {\r\n        Some(t) => t >= b,\r\n        None => false\r\n    }\r\n}\r\n```\r\n\r\nThe first pattern is what we often write and the second one is the most efficient manually unrolled version. Surprisingly rustc fails to optimize the former one into the latter as you can see in [godbolt listing](https://rust.godbolt.org/z/KkCGDu):\r\n\r\n```asm\r\nexample::unwrap_combinators:\r\n        xor     eax, eax\r\n        cmp     edx, esi\r\n        setle   al\r\n        test    edi, edi\r\n        mov     ecx, 2\r\n        cmovne  ecx, eax\r\n        cmp     cl, 2\r\n        setne   al\r\n        and     al, cl\r\n        ret\r\n\r\nexample::unwrap_manual:\r\n        test    edi, edi\r\n        setne   cl\r\n        cmp     esi, edx\r\n        setge   al\r\n        and     al, cl\r\n        ret\r\n```\r\n\r\nP.S. Yes, I'm aware of `map_or`", "labels": ["C-bug", "I-slow", "T-compiler"], "number_of_comments": 2, "created_at": "2020-01-30 12:28:57", "reactions": {"total_count": 9, "+1": 5, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557400291": {"author_username": "Marwes", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68666, "title": "Exponential trait selection when compiling a crate using combine 4", "body": "Originally reported in https://github.com/Marwes/combine/issues/284 . It appears that the changes made between version 3 and 4 in https://github.com/Marwes/combine . Made trait selection exponential in some cases. The main change that I would suspect causing this is that combine-3 had `Input` as an associated type whereas combine-4 uses a type parameter.\r\n\r\nThe following minimized repo reproduces the slowdown, removing a few arguments from the `choice!` macro makes it compile quickly https://github.com/Marwes/combine-slow-compile . The commit before `master` contains a version with combine-3 which compiles instantaneously (after dependencies are compiled). (diff https://github.com/Marwes/combine-slow-compile/commit/21cf38a5429e32a703c2bc2ea02cbcbaf2985b01)\r\n\r\n![Screenshot from 2020-01-30 10-51-55](https://user-images.githubusercontent.com/957312/73438941-24607500-434f-11ea-8077-a336fbc90e24.png)", "labels": ["A-traits", "C-bug", "I-compiletime", "T-compiler"], "number_of_comments": 10, "created_at": "2020-01-30 10:28:28", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557276889": {"author_username": "joshtriplett", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68662, "title": "ExitCodeExt: Please provide an extension method for the \"raw\" exit code", "body": "On Unix platforms, `ExitCode` wraps the exit code received from the system, and provides helper functions to distinguish \"exited normally with exit code\" from \"exited with signal number\". However, some command-line tools (those that execute another program) want to exit with the same exit status as the program they run. Please consider providing a function to obtain the \"raw\" exit status, suitable to pass directly to `sys::process::exit`.", "labels": ["C-feature-request", "T-libs"], "number_of_comments": 2, "created_at": "2020-01-30 05:34:42", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557112319": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68656, "title": "GAT ICE: cannot directly store unsized values", "body": "The following ICE's:\r\n```Rust\r\n#![feature(generic_associated_types)]\r\n\r\ntrait UnsafeCopy<T: Copy>  {\r\n    type Item<'a>: std::ops::Deref<Target = T>;\r\n    \r\n    fn bug<'a>(item: &Self::Item<'a>) -> () {\r\n        let x: T = **item;\r\n    }\r\n}\r\n\r\nimpl <T: Copy> UnsafeCopy<T> for T {\r\n    type Item<'a> = T;\r\n}\r\n\r\nfn main() {\r\n    <&'static str>::bug(&\"\");\r\n}\r\n```\r\n\r\n<details>\r\n<summary>Backtrace:</summary>\r\n\r\n```\r\nerror: internal compiler error: src/librustc_codegen_ssa/mir/operand.rs:305: cannot directly store unsized values\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:883:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc_codegen_ssa::mir::operand::OperandValue<V>::store_with_flags\r\n  21: rustc_codegen_ssa::mir::rvalue::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_rvalue\r\n  22: rustc_codegen_ssa::mir::codegen_mir\r\n  23: <rustc::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt>::define\r\n  24: rustc_codegen_llvm::base::compile_codegen_unit::module_codegen\r\n  25: rustc::dep_graph::graph::DepGraph::with_task\r\n  26: rustc_codegen_llvm::base::compile_codegen_unit\r\n  27: rustc_codegen_ssa::base::codegen_crate\r\n  28: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  29: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  30: rustc_interface::passes::QueryContext::enter\r\n  31: rustc_interface::queries::Queries::ongoing_codegen\r\n  32: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  33: scoped_tls::ScopedKey<T>::set\r\n  34: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (3761dcd34 2020-01-28) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C codegen-units=1 -C debuginfo=2 --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n```\r\n</details>", "labels": ["C-bug", "F-generic_associated_types", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-29 21:00:10", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557063188": {"author_username": "LeSeulArtichaut", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68654, "title": "Canonicalize path when displaying a `FileName::Real`", "body": "Addresses #51349 (?)\r\n\r\nI'm also not sure if failing to canonicalize the path should result in failing to display the `FileName`, or if the original path should be used as a fallback. My current implementation uses the latter, as it seemed the \"wisest\" solution to me.\r\n\r\nr? @estebank", "labels": ["S-waiting-on-review"], "number_of_comments": 12, "created_at": "2020-01-29 19:19:10", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557044386": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68652, "title": "GAT ICE: codegen_argument", "body": "The following ICE's:\r\n```Rust\r\n#![feature(generic_associated_types)]\r\n\r\ntrait Fun {\r\n    type F<'a>: ?Sized;\r\n    \r\n    fn identity<'a>(t: &'a Self::F<'a>) -> &'a Self::F<'a> { t }\r\n}\r\n\r\nimpl <T> Fun for T {\r\n    type F<'a> = Self;\r\n}\r\n\r\nfn bug<'a, T: Fun<F = dyn Sync + Send>>(_: T) -> Box<T::F<'a>> {\r\n    Box::new(T::identity(&()))\r\n}\r\n\r\n\r\nfn main() {\r\n    let x = 10;\r\n    \r\n    bug(x);\r\n}\r\n```\r\n\r\n<details>\r\n<summary>Backtrace:</summary>\r\n\r\n```\r\nerror: internal compiler error: src/librustc_codegen_ssa/mir/block.rs:886: codegen_argument: OperandRef(Immediate((i32*:  %7 = invoke align 4 dereferenceable(4) i32* @_ZN10playground3Fun8identity17h312f2af0fa5c794fE(i32* noalias readonly align 4 dereferenceable(4) %6)\r\n          to label %9 unwind label %13)) @ TyLayout { ty: &i32, details: LayoutDetails { variants: Single { index: 0 }, fields: Union(0), abi: Scalar(Scalar { value: Pointer, valid_range: 1..=18446744073709551615 }), largest_niche: Some(Niche { offset: Size { raw: 0 }, scalar: Scalar { value: Pointer, valid_range: 1..=18446744073709551615 } }), align: AbiAndPrefAlign { abi: Align { pow2: 3 }, pref: Align { pow2: 3 } }, size: Size { raw: 8 } } }) invalid for pair argument\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:883:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc_codegen_ssa::mir::block::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_argument\r\n  21: rustc_codegen_ssa::mir::block::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_terminator\r\n  22: rustc_codegen_ssa::mir::codegen_mir\r\n  23: <rustc::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt>::define\r\n  24: rustc_codegen_llvm::base::compile_codegen_unit::module_codegen\r\n  25: rustc::dep_graph::graph::DepGraph::with_task\r\n  26: rustc_codegen_llvm::base::compile_codegen_unit\r\n  27: rustc_codegen_ssa::base::codegen_crate\r\n  28: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  29: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  30: rustc_interface::passes::QueryContext::enter\r\n  31: rustc_interface::queries::Queries::ongoing_codegen\r\n  32: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  33: scoped_tls::ScopedKey<T>::set\r\n  34: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (3761dcd34 2020-01-28) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C opt-level=3 -C codegen-units=1 --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n```\r\n</details>", "labels": ["C-bug", "F-generic_associated_types", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-29 18:40:32", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557016915": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68650, "title": "GAT ICE: unsize_thin_ptr: called on bad types", "body": "The following ICE's:\r\n```Rust\r\n#![feature(generic_associated_types)]\r\n\r\ntrait Fun {\r\n    type F<'a>;\r\n    \r\n    fn identity<'a>(t: Self::F<'a>) -> Self::F<'a> { t }\r\n}\r\n\r\nimpl <T> Fun for T {\r\n    type F<'a> = Self;\r\n}\r\n\r\nfn bug<'a, T: Fun<F = &'a dyn Send>>(t: T) -> T::F<'a> {\r\n    T::identity(&())\r\n}\r\n\r\n\r\nfn main() {\r\n    let x = 10;\r\n    \r\n    bug(x);\r\n}\r\n```\r\n\r\n<details>\r\n<summary>Backtrace:</summary>\r\n\r\n```\r\nerror: internal compiler error: src/librustc_codegen_ssa/base.rs:220: unsize_thin_ptr: called on bad types\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:883:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc_codegen_ssa::base::unsize_thin_ptr\r\n  21: rustc_codegen_ssa::mir::rvalue::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_rvalue_operand\r\n  22: rustc_codegen_ssa::mir::codegen_mir\r\n  23: <rustc::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt>::define\r\n  24: rustc_codegen_llvm::base::compile_codegen_unit::module_codegen\r\n  25: rustc::dep_graph::graph::DepGraph::with_task\r\n  26: rustc_codegen_llvm::base::compile_codegen_unit\r\n  27: rustc_codegen_ssa::base::codegen_crate\r\n  28: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  29: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  30: rustc_interface::passes::QueryContext::enter\r\n  31: rustc_interface::queries::Queries::ongoing_codegen\r\n  32: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  33: scoped_tls::ScopedKey<T>::set\r\n  34: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (3761dcd34 2020-01-28) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C opt-level=3 -C codegen-units=1 --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n```\r\n\r\n</details>", "labels": ["C-bug", "F-generic_associated_types", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-29 17:43:11", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557014674": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68649, "title": "GAT ICE: place local already assigned to", "body": "The following ICE's:\r\n\r\n```Rust\r\n#![feature(generic_associated_types)]\r\n\r\ntrait Fun {\r\n    type F<'a>;\r\n    \r\n    fn identity<'a>(t: Self::F<'a>) -> Self::F<'a> { t }\r\n}\r\n\r\nimpl <T> Fun for T {\r\n    type F<'a> = Self;\r\n}\r\n\r\nfn bug<'a, T: Fun<F = ()>>(t: T) -> T::F<'a> {\r\n    T::identity(())\r\n}\r\n\r\n\r\nfn main() {\r\n    let x = 10;\r\n    \r\n    bug(x);\r\n}\r\n```\r\n\r\n<details>\r\n<summary>Backtrace:</summary>\r\n\r\n```\r\nerror: internal compiler error: src/librustc_codegen_ssa/mir/block.rs:1108: place local already assigned to\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:883:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc_codegen_ssa::mir::block::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_terminator\r\n  21: rustc_codegen_ssa::mir::codegen_mir\r\n  22: <rustc::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt>::define\r\n  23: rustc_codegen_llvm::base::compile_codegen_unit::module_codegen\r\n  24: rustc::dep_graph::graph::DepGraph::with_task\r\n  25: rustc_codegen_llvm::base::compile_codegen_unit\r\n  26: rustc_codegen_ssa::base::codegen_crate\r\n  27: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  28: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  29: rustc_interface::passes::QueryContext::enter\r\n  30: rustc_interface::queries::Queries::ongoing_codegen\r\n  31: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  32: scoped_tls::ScopedKey<T>::set\r\n  33: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (3761dcd34 2020-01-28) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C opt-level=3 -C codegen-units=1 --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n```\r\n</details>\r\n\r\nNotice this is _verry_ simlar code to https://github.com/rust-lang/rust/issues/68648, except here the `identity` function is called with an empty tuple. Also notice that here, the call to `bug` actually isnt allowed, since i32 doesnt implement `Fun` with the associated type as a tuple.", "labels": ["C-bug", "F-generic_associated_types", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-29 17:38:41", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "557011172": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68648, "title": "GAT ICE:  impl item and trait item have different parameter counts", "body": "The following ICE's:\r\n```Rust\r\n#![feature(generic_associated_types)]\r\n\r\ntrait Fun {\r\n    type F<'a>;\r\n    \r\n    fn identity<'a>(t: Self::F<'a>) -> Self::F<'a> { t }\r\n}\r\n\r\nimpl <T> Fun for T {\r\n    type F<'a> = Self;\r\n}\r\n\r\nfn bug<'a, T: Fun<F = T>>(t: T) -> T::F<'a> {\r\n    T::identity(t)\r\n}\r\n\r\n\r\nfn main() {\r\n    let x = 10;\r\n    \r\n    bug(x);\r\n}\r\n```\r\n\r\n<details>\r\n<summary>Backtrace:</summary>\r\n\r\n```\r\nerror: internal compiler error: impl item and trait item have different parameter counts\r\n\r\nthread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:357:17\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  12: std::panicking::begin_panic\r\n  13: <rustc_errors::HandlerInner as core::ops::drop::Drop>::drop\r\n  14: core::ptr::drop_in_place\r\n  15: <alloc::rc::Rc<T> as core::ops::drop::Drop>::drop\r\n  16: core::ptr::drop_in_place\r\n  17: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  18: scoped_tls::ScopedKey<T>::set\r\n  19: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (3761dcd34 2020-01-28) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C opt-level=3 -C codegen-units=1 --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\nend of query stack\r\nerror: could not compile `playground`.\r\n```\r\n</details>", "labels": ["C-bug", "F-generic_associated_types", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-29 17:31:45", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556991190": {"author_username": "Zoxc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68647, "title": "Linking libtest with lld-link results in undefined symbols", "body": "Not sure if this is a LLD or rustc bug.\r\n\r\nError output:\r\n```\r\nerror: linking with `F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0\\lib\\rustlib\\x86_64-pc-windows-msvc\\bin\\rust-lld` failed: exit code: 1\r\n  |\r\n  = note: \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0\\\\lib\\\\rustlib\\\\x86_64-pc-windows-msvc\\\\bin\\\\rust-lld\" \"-flavor\" \"link\" \"/LIBPATH:F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-sysroot\\\\lib\\\\rustlib\\\\x86_64-pc-windows-msvc\\\\lib\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.0.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.1.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.11.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.12.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.13.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.14.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.15.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.16.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.17.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.18.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.19.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.2.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.20.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.21.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.22.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.23.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.24.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.25.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.26.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.27.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.28.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.29.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.3.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.30.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.31.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.4.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.5.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.6.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.8.rcgu.o\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.9.rcgu.o\" \"/OUT:F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.dll\" \"/DEF:C:\\\\Users\\\\John\\\\AppData\\\\Local\\\\Temp\\\\rustccCOdq4\\\\lib.def\" \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.5yai0brzr211np4.rcgu.o\" \"/OPT:REF,ICF\" \"/DEBUG\" \"/LIBPATH:F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\" \"/LIBPATH:F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\release\\\\deps\" \"/LIBPATH:F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\build\\\\compiler_builtins-44214af0d2365ef5\\\\out\" \"/LIBPATH:F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-sysroot\\\\lib\\\\rustlib\\\\x86_64-pc-windows-msvc\\\\lib\" \"C:\\\\Users\\\\John\\\\AppData\\\\Local\\\\Temp\\\\rustccCOdq4\\\\libterm-6cfbd4c1589fa116.rlib\" \"C:\\\\Users\\\\John\\\\AppData\\\\Local\\\\Temp\\\\rustccCOdq4\\\\libgetopts-b1f28f4def7ae8a6.rlib\" \"C:\\\\Users\\\\John\\\\AppData\\\\Local\\\\Temp\\\\rustccCOdq4\\\\libunicode_width-e7889bd28dfba242.rlib\" \"C:\\\\Users\\\\John\\\\AppData\\\\Local\\\\Temp\\\\rustccCOdq4\\\\librustc_std_workspace_std-c2dd7b0881cfef4e.rlib\" \"/LIBPATH:F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\" \"std-c2f4da12d5907bd6.dll.lib\" \"C:\\\\Users\\\\John\\\\AppData\\\\Local\\\\Temp\\\\rustccCOdq4\\\\libcompiler_builtins-c95709d8d9af9cff.rlib\" \"kernel32.lib\" \"advapi32.lib\" \"ws2_32.lib\" \"userenv.lib\" \"libcmt.lib\" \"/DLL\" \"/IMPLIB:F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0-std\\\\x86_64-pc-windows-msvc\\\\release\\\\deps\\\\test-08b31b6e3b792056.dll.lib\"\r\n  = note: rust-lld: error: undefined symbol: _ZN57_$LT$std..io..stdio..Stdout$u20$as$u20$std..io..Write$GT$5write17hbd65a0f1fbe667c0E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\io\\mod.rs:1354\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN3std2io5Write9write_all17hc57fcfc82d35e7bfE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\io\\mod.rs:1292\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.3.rcgu.o):(_ZN3std2io5Write14write_vectored17had78528bfd4cfb96E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\io\\mod.rs:1354\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.3.rcgu.o):(_ZN3std2io5Write9write_all17hb2fe52f879a86becE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libterm\\terminfo\\mod.rs:240\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.3.rcgu.o):(_ZN76_$LT$term..terminfo..TerminfoTerminal$LT$T$GT$$u20$as$u20$std..io..Write$GT$5write17h054e87e6072a8a23E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\io\\mod.rs:1292\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.7.rcgu.o):(_ZN3std2io5Write14write_vectored17he432d4dae6f33724E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\io\\mod.rs:1354\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.7.rcgu.o):(_ZN3std2io5Write9write_all17h24b9f983f507eb04E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libterm\\win.rs:148\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.7.rcgu.o):(_ZN65_$LT$term..win..WinConsole$LT$T$GT$$u20$as$u20$std..io..Write$GT$5write17hb36400ba3410fed5E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\io\\mod.rs:424\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.6.rcgu.o):(_ZN3std2io22default_write_vectored17hea04ec47e1df1efbE)\r\n\r\n          rust-lld: error: undefined symbol: _ZN75_$LT$std..sys..windows..handle..Handle$u20$as$u20$core..ops..drop..Drop$GT$4drop17h9d4cbc594f7ddd03E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\ptr\\mod.rs:174\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN4core3ptr13drop_in_place17h10c86f64ec3fbe82E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\thread\\mod.rs:386\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.31.rcgu.o:(_ZN3std6thread7Builder5spawn17h1dfac31957576ee6E)\r\n          >>> referenced by F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.31.rcgu.o:(_ZN4core3ptr13drop_in_place17hd44aed8a67551d1bE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\ptr\\mod.rs:174\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.5.rcgu.o:(_ZN4core3ptr13drop_in_place17h9a6a8680eb1c3cbdE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\ptr\\mod.rs:174\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.5.rcgu.o:(_ZN4core3ptr13drop_in_place17h9a6a8680eb1c3cbdE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\ptr\\mod.rs:174\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.5.rcgu.o:(_ZN4core3ptr13drop_in_place17h9a6a8680eb1c3cbdE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\ptr\\mod.rs:174\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.5.rcgu.o:(_ZN4core3ptr13drop_in_place17h9d0e65faf2221092E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\ptr\\mod.rs:174\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.5.rcgu.o:(_ZN4core3ptr13drop_in_place17hc5ca69be49ef12bcE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\ptr\\mod.rs:174\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.3.rcgu.o):(_ZN4core3ptr13drop_in_place17h4fcacb682c942e1cE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libterm\\terminfo\\mod.rs:99\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.3.rcgu.o):(_ZN4term8terminfo8TermInfo10_from_path17h4356dd4e91d92a31E)\r\n          >>> referenced 1 more times\r\n\r\n          rust-lld: error: undefined symbol: _ZN42_$LT$str$u20$as$u20$core..fmt..Display$GT$3fmt17h88e4b43699a75114E\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\string.rs:1914\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN60_$LT$alloc..string..String$u20$as$u20$core..fmt..Display$GT$3fmt17h5bcd62f1b4993ca7E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\string.rs:1914\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.17.rcgu.o:(_ZN60_$LT$alloc..string..String$u20$as$u20$core..fmt..Display$GT$3fmt17h5bcd62f1b4993ca7E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\string.rs:1914\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.19.rcgu.o:(_ZN60_$LT$alloc..string..String$u20$as$u20$core..fmt..Display$GT$3fmt17h5bcd62f1b4993ca7E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\string.rs:1914\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.21.rcgu.o:(_ZN60_$LT$alloc..string..String$u20$as$u20$core..fmt..Display$GT$3fmt17h5bcd62f1b4993ca7E.llvm.815056061026961744)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.22.rcgu.o:(_ZN44_$LT$$RF$T$u20$as$u20$core..fmt..Display$GT$3fmt17he1974b7d847ff08bE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.22.rcgu.o:(_ZN44_$LT$$RF$T$u20$as$u20$core..fmt..Display$GT$3fmt17he1974b7d847ff08bE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\types.rs:73\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.22.rcgu.o:(_ZN60_$LT$test..types..TestName$u20$as$u20$core..fmt..Display$GT$3fmt17h7e47fd605c7cb8caE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\types.rs:73\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.22.rcgu.o:(_ZN60_$LT$test..types..TestName$u20$as$u20$core..fmt..Display$GT$3fmt17h7e47fd605c7cb8caE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.25.rcgu.o:(_ZN44_$LT$$RF$T$u20$as$u20$core..fmt..Display$GT$3fmt17h7c65517032b4dca1E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.25.rcgu.o:(_ZN44_$LT$$RF$T$u20$as$u20$core..fmt..Display$GT$3fmt17h8e0ecf5328ef8bf9E)\r\n          >>> referenced 10 more times\r\n\r\n          rust-lld: error: undefined symbol: _ZN57_$LT$std..io..stdio..Stdout$u20$as$u20$std..io..Write$GT$5flush17hf0feb76a6d2e94a5E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\console.rs:40\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN73_$LT$test..console..OutputLocation$LT$T$GT$$u20$as$u20$std..io..Write$GT$5flush17h48246d88c4661c06E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\terse.rs:75\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(_ZN4test10formatters5terse23TerseFormatter$LT$T$GT$18write_short_result17he25bfd3d3e0dc0b8E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\terse.rs:96\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(_ZN4test10formatters5terse23TerseFormatter$LT$T$GT$12write_pretty17h78043e5d54e58cf0E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\terse.rs:161\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(_ZN4test10formatters5terse23TerseFormatter$LT$T$GT$15write_test_name17hba7c0f113354e930E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\terse.rs:171\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(_ZN102_$LT$test..formatters..terse..TerseFormatter$LT$T$GT$$u20$as$u20$test..formatters..OutputFormatter$GT$15write_run_start17h0029d6bb43e29174E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\terse.rs:206\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(_ZN102_$LT$test..formatters..terse..TerseFormatter$LT$T$GT$$u20$as$u20$test..formatters..OutputFormatter$GT$12write_result17h3e2ab4131cf54c4bE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\terse.rs:212\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(_ZN102_$LT$test..formatters..terse..TerseFormatter$LT$T$GT$$u20$as$u20$test..formatters..OutputFormatter$GT$13write_timeout17ha9ff0ccec19ad78aE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\terse.rs:221\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(_ZN102_$LT$test..formatters..terse..TerseFormatter$LT$T$GT$$u20$as$u20$test..formatters..OutputFormatter$GT$16write_run_finish17h8da3733db12e7cb3E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\terse.rs:221\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(_ZN102_$LT$test..formatters..terse..TerseFormatter$LT$T$GT$$u20$as$u20$test..formatters..OutputFormatter$GT$16write_run_finish17h8da3733db12e7cb3E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\terse.rs:221\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(_ZN102_$LT$test..formatters..terse..TerseFormatter$LT$T$GT$$u20$as$u20$test..formatters..OutputFormatter$GT$16write_run_finish17h8da3733db12e7cb3E)\r\n          >>> referenced 26 more times\r\n\r\n          rust-lld: error: undefined symbol: _ZN79_$LT$std..path..Path$u20$as$u20$core..convert..AsRef$LT$std..path..Path$GT$$GT$6as_ref17h59c9d46a758a5f64E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\console.rs:64\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN4test7console16ConsoleTestState3new17h3d759a1c195c1dc7E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\fs.rs:399\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.21.rcgu.o:(_ZN3std2fs4File6create17h8f4dc7c919d646b5E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libterm\\terminfo\\mod.rs:83\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.3.rcgu.o):(_ZN4term8terminfo8TermInfo9from_name17h0911df633b1b8d1bE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libterm\\terminfo\\mod.rs:96\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.3.rcgu.o):(_ZN4term8terminfo8TermInfo10_from_path17h4356dd4e91d92a31E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libterm\\terminfo\\mod.rs:96\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.3.rcgu.o):(_ZN4term8terminfo8TermInfo10_from_path17h4356dd4e91d92a31E)\r\n\r\n          rust-lld: error: undefined symbol: _ZN4core3fmt3num3imp52_$LT$impl$u20$core..fmt..Display$u20$for$u20$i32$GT$3fmt17h349d87bebbbc3d0aE\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\console.rs:177\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN4test7console18list_tests_console17h6532b99e448f68eaE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\console.rs:177\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN4test7console18list_tests_console17h6532b99e448f68eaE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\test_result.rs:99\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.17.rcgu.o:(_ZN4test11test_result25get_result_from_exit_code17h2897dec9f27c18ffE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libterm\\terminfo\\parm.rs:500\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.1.rcgu.o):(_ZN4term8terminfo4parm6format17h881ca09f38c08643E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libterm\\terminfo\\parm.rs:505\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.1.rcgu.o):(_ZN4term8terminfo4parm6format17h881ca09f38c08643E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libterm\\terminfo\\parm.rs:503\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.1.rcgu.o):(_ZN4term8terminfo4parm6format17h881ca09f38c08643E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libterm\\terminfo\\parm.rs:507\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.1.rcgu.o):(_ZN4term8terminfo4parm6format17h881ca09f38c08643E)\r\n\r\n          rust-lld: error: undefined symbol: _ZN4core3fmt3num3imp52_$LT$impl$u20$core..fmt..Display$u20$for$u20$u32$GT$3fmt17h6ab8423d5480caf0E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\console.rs:177\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN4test7console18list_tests_console17h6532b99e448f68eaE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\console.rs:177\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN4test7console18list_tests_console17h6532b99e448f68eaE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.16.rcgu.o):(_ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17hc2e52cb3d92982e7E)\r\n\r\n          rust-lld: error: undefined symbol: _ZN60_$LT$alloc..string..String$u20$as$u20$core..clone..Clone$GT$5clone17hcff66481f9e15336E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\console.rs:226\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN4test7console13on_test_event17he33006036fa6d8edE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\console.rs:226\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN4test7console13on_test_event17he33006036fa6d8edE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\console.rs:226\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN4test7console13on_test_event17he33006036fa6d8edE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\console.rs:226\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.10.rcgu.o:(_ZN4test7console13on_test_event17he33006036fa6d8edE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\types.rs:64\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.22.rcgu.o:(_ZN4test5types8TestName12with_padding17ha7b9c60d78c181cdE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\option.rs:959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.29.rcgu.o:(_ZN4core6option19Option$LT$$RF$T$GT$6cloned17he58b2e34c64df414E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\iter\\adapters\\mod.rs:331\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.31.rcgu.o:(_ZN96_$LT$core..iter..adapters..Cloned$LT$I$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h7e008dc87d88f18fE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\iter\\adapters\\mod.rs:812\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.31.rcgu.o:(_ZN97_$LT$core..iter..adapters..Map$LT$I$C$F$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h1bd3f87ed184ab99E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\cli.rs:206\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.4.rcgu.o:(_ZN4test3cli10parse_opts17h32a8683d3313fe8dE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\ops\\function.rs:274\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.5.rcgu.o:(_ZN4core3ops8function5impls79_$LT$impl$u20$core..ops..function..FnMut$LT$A$GT$$u20$for$u20$$RF$mut$u20$F$GT$8call_mut17h02de41c3d932d472E)\r\n          >>> referenced 27 more times\r\n\r\n          rust-lld: error: undefined symbol: _ZN107_$LT$std..sync..mpsc..RecvTimeoutError$u20$as$u20$core..convert..From$LT$std..sync..mpsc..RecvError$GT$$GT$4from17hb69f0c3bf67d41a6E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\sync\\mpsc\\mod.rs:1288\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.12.rcgu.o:(_ZN3std4sync4mpsc17Receiver$LT$T$GT$12recv_timeout17h57b40ffff32c22c5E)\r\n\r\n          rust-lld: error: undefined symbol: _ZN40_$LT$str$u20$as$u20$core..fmt..Debug$GT$3fmt17h3099fb3f88f892ebE\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\sync\\mpsc\\mod.rs:1540\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.12.rcgu.o:(_ZN72_$LT$std..sync..mpsc..SendError$LT$T$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17hd40867e3e8108901E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.25.rcgu.o:(_ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17h1f218226c179698eE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.25.rcgu.o:(_ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17hb44421a8e1e924cbE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.25.rcgu.o:(_ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17hc74aa123b38842c2E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\sys_common\\poison.rs:138\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.26.rcgu.o:(_ZN82_$LT$std..sys_common..poison..PoisonError$LT$T$GT$$u20$as$u20$core..fmt..Debug$GT$3fmt17h8f4d69f8ea34858dE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.31.rcgu.o:(_ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17h1b2e483bb3c1d72cE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               libgetopts-b1f28f4def7ae8a6.rlib(getopts-b1f28f4def7ae8a6.getopts.5palysce-cgu.0.rcgu.o):(_ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17he450f958f24cf18bE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.22.rcgu.o):(_ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17hb5b2e1d3d12e8c73E)\r\n\r\n          rust-lld: error: undefined symbol: _ZN4core3fmt3num3imp54_$LT$impl$u20$core..fmt..Display$u20$for$u20$usize$GT$3fmt17h92876b3d8c7fe544E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\macros.rs:23\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.13.rcgu.o:(_ZN3std4sync4mpsc6shared15Packet$LT$T$GT$9drop_chan17h70710ca56a3cfd7fE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\bench.rs:72\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.19.rcgu.o:(_ZN4test5bench17fmt_bench_samples17h042c770e1d2f0929E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\bench.rs:86\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.19.rcgu.o:(_ZN4test5bench17fmt_thousands_sep17h80883fe1ecfdb1b4E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\bench.rs:88\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.19.rcgu.o:(_ZN4test5bench17fmt_thousands_sep17h80883fe1ecfdb1b4E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.25.rcgu.o:(_ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17ha9de42ef17e78163E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\json.rs:61\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.6.rcgu.o:(_ZN100_$LT$test..formatters..json..JsonFormatter$LT$T$GT$$u20$as$u20$test..formatters..OutputFormatter$GT$15write_run_start17h2196ba29f028d64dE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\json.rs:135\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.6.rcgu.o:(_ZN100_$LT$test..formatters..json..JsonFormatter$LT$T$GT$$u20$as$u20$test..formatters..OutputFormatter$GT$12write_result17h9be8b1bae120fc65E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\json.rs:138\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.6.rcgu.o:(_ZN100_$LT$test..formatters..json..JsonFormatter$LT$T$GT$$u20$as$u20$test..formatters..OutputFormatter$GT$12write_result17h9be8b1bae120fc65E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\json.rs:159\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.6.rcgu.o:(_ZN100_$LT$test..formatters..json..JsonFormatter$LT$T$GT$$u20$as$u20$test..formatters..OutputFormatter$GT$16write_run_finish17h6bf7c757d17b74d2E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\formatters\\terse.rs:74\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(_ZN4test10formatters5terse23TerseFormatter$LT$T$GT$18write_short_result17he25bfd3d3e0dc0b8E)\r\n          >>> referenced 8 more times\r\n\r\n          rust-lld: error: undefined symbol: _ZN4core3fmt5float52_$LT$impl$u20$core..fmt..Display$u20$for$u20$f64$GT$3fmt17h189b136135402b9eE\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.17.rcgu.o:(_ZN44_$LT$$RF$T$u20$as$u20$core..fmt..Display$GT$3fmt17h6d99a020930638eaE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\time.rs:69\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.17.rcgu.o:(_ZN63_$LT$test..time..TestExecTime$u20$as$u20$core..fmt..Display$GT$3fmt17h37687ecc4b6966cbE)\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\vec.rs:2007\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.2.rcgu.o:(_ZN80_$LT$alloc..vec..Vec$LT$T$GT$$u20$as$u20$alloc..vec..SpecExtend$LT$T$C$I$GT$$GT$9from_iter17h9aaff847c7a08091E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\vec.rs:2019\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.2.rcgu.o:(_ZN80_$LT$alloc..vec..Vec$LT$T$GT$$u20$as$u20$alloc..vec..SpecExtend$LT$T$C$I$GT$$GT$9from_iter17h9aaff847c7a08091E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\vec.rs:2019\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.2.rcgu.o:(_ZN80_$LT$alloc..vec..Vec$LT$T$GT$$u20$as$u20$alloc..vec..SpecExtend$LT$T$C$I$GT$$GT$9from_iter17h9aaff847c7a08091E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\ops\\function.rs:285\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.21.rcgu.o:(_ZN4core3ops8function5impls80_$LT$impl$u20$core..ops..function..FnOnce$LT$A$GT$$u20$for$u20$$RF$mut$u20$F$GT$9call_once17hcd3bddeec5fd4180E)\r\n\r\n          rust-lld: error: undefined symbol: _ZN4core3num52_$LT$impl$u20$core..str..FromStr$u20$for$u20$u64$GT$8from_str17hcf1d7caa913b041cE\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\iter\\adapters\\mod.rs:791\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.17.rcgu.o:(_ZN97_$LT$core..iter..adapters..Map$LT$I$C$F$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hefeeb8cdeb76c86aE)\r\n\r\n          rust-lld: error: undefined symbol: _ZN54_$LT$core..any..TypeId$u20$as$u20$core..fmt..Debug$GT$3fmt17h4acf93e863d041d5E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\test_result.rs:57\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.17.rcgu.o:(_ZN4test11test_result11calc_result17h578d2295b2aff976E)\r\n\r\n          rust-lld: error: undefined symbol: _ZN88_$LT$std..time..Instant$u20$as$u20$core..ops..arith..Add$LT$core..time..Duration$GT$$GT$3add17h547da9327098516eE\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\time.rs:60\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.17.rcgu.o:(_ZN4test4time24get_default_test_timeout17h0e82631fa0b0c141E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\libtest\\lib.rs:296\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.5.rcgu.o:(_ZN4test9run_tests17had54d3605a3f920dE)\r\n\r\n          rust-lld: error: undefined symbol: _ZN53_$LT$core..fmt..Error$u20$as$u20$core..fmt..Debug$GT$3fmt17h44e19c88cc9c88a5E\r\n          >>> referenced by F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.19.rcgu.o:(anon.e4d4364cd92e2c9867e8e6e4bcbcea34.3)\r\n          >>> referenced by F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.4.rcgu.o:(anon.a8992f771d7cebb48de2f01bdce6ac0d.5)\r\n          >>> referenced by F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.7.rcgu.o:(anon.46c5e78587de7248bbd21783e47c14b4.5)\r\n          >>> referenced by F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.8.rcgu.o:(anon.810636724a72e72083165abd11ec6984.5)\r\n          >>> referenced by libgetopts-b1f28f4def7ae8a6.rlib(getopts-b1f28f4def7ae8a6.getopts.5palysce-cgu.14.rcgu.o):(anon.1cf900d2eafb2dcd1312552eb099fe06.5)\r\n          >>> referenced by libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.5.rcgu.o):(anon.9a1b1af1903ff770925bb87d0fca2c64.6)\r\n          >>> referenced by libterm-6cfbd4c1589fa116.rlib(term-6cfbd4c1589fa116.term.cvtlv8xb-cgu.11.rcgu.o):(anon.b2b52a5a62deeaf091d02115f0e921d7.5)\r\n\r\n          rust-lld: error: undefined symbol: _ZN73_$LT$std..env..Args$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h76d2e0121a5a7450E\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\vec.rs:2007\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.2.rcgu.o:(_ZN80_$LT$alloc..vec..Vec$LT$T$GT$$u20$as$u20$alloc..vec..SpecExtend$LT$T$C$I$GT$$GT$9from_iter17h91faedf2173edcf3E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\vec.rs:2019\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.2.rcgu.o:(_ZN80_$LT$alloc..vec..Vec$LT$T$GT$$u20$as$u20$alloc..vec..SpecExtend$LT$T$C$I$GT$$GT$9from_iter17h91faedf2173edcf3E)\r\n\r\n          rust-lld: error: undefined symbol: _ZN73_$LT$std..env..Args$u20$as$u20$core..iter..traits..iterator..Iterator$GT$9size_hint17h8a29deca6154f599E\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\vec.rs:2010\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.2.rcgu.o:(_ZN80_$LT$alloc..vec..Vec$LT$T$GT$$u20$as$u20$alloc..vec..SpecExtend$LT$T$C$I$GT$$GT$9from_iter17h91faedf2173edcf3E)\r\n          >>> referenced by F:\\Rust\\rust\\src\\liballoc\\vec.rs:2019\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.2.rcgu.o:(_ZN80_$LT$alloc..vec..Vec$LT$T$GT$$u20$as$u20$alloc..vec..SpecExtend$LT$T$C$I$GT$$GT$9from_iter17h91faedf2173edcf3E)\r\n\r\n          rust-lld: error: undefined symbol: _ZN48_$LT$std..fs..File$u20$as$u20$std..io..Write$GT$5write17h88eedd89f1c8a942E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libstd\\io\\mod.rs:1354\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.21.rcgu.o:(_ZN3std2io5Write9write_all17h180604707e4abef7E)\r\n\r\n          rust-lld: error: undefined symbol: _ZN55_$LT$std..path..PathBuf$u20$as$u20$core..fmt..Debug$GT$3fmt17h01a79564a1f3d451E\r\n          >>> referenced by F:\\Rust\\rust\\src\\libcore\\fmt\\mod.rs:1959\r\n          >>>               F:\\Rust\\rust\\build\\x86_64-pc-windows-msvc\\stage0-std\\x86_64-pc-windows-msvc\\release\\deps\\test-08b31b6e3b792056.test.cdf7p9m0-cgu.21.rcgu.o:(_ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17hd2d63f726e4f4e25E)\r\n\r\n          rust-lld: error: too many errors emitted, stopping now (use /errorlimit:0 to see all errors)\r\n\r\n\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `test`.\r\n\r\nTo learn more, run the command again with --verbose.\r\ncommand did not execute successfully: \"F:\\\\Rust\\\\rust\\\\build\\\\x86_64-pc-windows-msvc\\\\stage0\\\\bin\\\\cargo.exe\" \"build\" \"-Zconfig-profile\" \"--target\" \"x86_64-pc-windows-msvc\" \"-Zbinary-dep-depinfo\" \"-j\" \"16\" \"--release\" \"--features\" \"panic-unwind backtrace compiler-builtins-c\" \"--manifest-path\" \"F:\\\\Rust\\\\rust\\\\src/libtest/Cargo.toml\" \"--message-format\" \"json-render-diagnostics\"\r\nexpected success, got: exit code: 101\r\n```", "labels": ["A-libtest", "A-linkage", "C-bug", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-29 16:55:38", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556966149": {"author_username": "Zoxc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68646, "title": "Add linker arguments from i686-pc-windows-msvc to LLD too", "body": "cc @ollie27\r\n\r\nr? @alexcrichton ", "labels": ["S-waiting-on-author"], "number_of_comments": 4, "created_at": "2020-01-29 16:14:11", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556962552": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68645, "title": "GAT ICE: FulfillmentError", "body": "The following code ICE's:\r\n```Rust\r\n#![feature(generic_associated_types)]\r\n\r\ntrait Fun {\r\n    type F<'a>: Fn() -> u32;\r\n    \r\n    fn callme<'a>(f: Self::F<'a>) -> u32 {\r\n        f()\r\n    }\r\n}\r\n\r\nimpl <T> Fun for T {\r\n    type F<'a> = Self;\r\n}\r\n\r\nfn main() {\r\n    <&dyn Iterator<Item = u8>>::callme(&std::iter::once(1));\r\n}\r\n```\r\n\r\n<details>\r\n<summary>Backtrace:</summary>\r\n\r\n```\r\nerror: internal compiler error: src/librustc/traits/codegen/mod.rs:104: Encountered errors `[FulfillmentError(Obligation(predicate=Binder(TraitPredicate(<dyn std::iter::Iterator<Item = u8> as std::ops::Fn<()>>)), depth=1),Unimplemented)]` resolving bounds after type-checking\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:883:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc::traits::codegen::<impl rustc::infer::InferCtxt>::drain_fulfillment_cx_or_panic\r\n  21: rustc::ty::context::GlobalCtxt::enter_local\r\n  22: rustc::traits::codegen::codegen_fulfill_obligation\r\n  23: rustc::ty::query::__query_compute::codegen_fulfill_obligation\r\n  24: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::codegen_fulfill_obligation>::compute\r\n  25: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  26: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  27: rustc::ty::instance::Instance::resolve\r\n  28: <rustc_mir::monomorphize::collector::MirNeighborCollector as rustc::mir::visit::Visitor>::visit_terminator_kind\r\n  29: rustc_mir::monomorphize::collector::collect_items_rec\r\n  30: rustc_mir::monomorphize::collector::collect_items_rec\r\n  31: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  32: rustc_mir::monomorphize::collector::collect_crate_mono_items\r\n  33: rustc_mir::monomorphize::partitioning::collect_and_partition_mono_items\r\n  34: rustc::ty::query::__query_compute::collect_and_partition_mono_items\r\n  35: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  36: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  37: rustc_codegen_ssa::base::codegen_crate\r\n  38: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  39: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  40: rustc_interface::passes::QueryContext::enter\r\n  41: rustc_interface::queries::Queries::ongoing_codegen\r\n  42: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  43: scoped_tls::ScopedKey<T>::set\r\n  44: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (3761dcd34 2020-01-28) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C codegen-units=1 -C debuginfo=2 --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [codegen_fulfill_obligation] checking if `std::ops::Fn` fulfills its obligations\r\n#1 [collect_and_partition_mono_items] collect_and_partition_mono_items\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n</details>", "labels": ["C-bug", "F-generic_associated_types", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-29 16:08:20", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556960371": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68644, "title": "GAT ICE: Encountered error `Unimplemented` selecting `Binder", "body": "The following code causes an ICE:\r\n```Rust\r\n#![feature(generic_associated_types)]\r\n\r\ntrait Fun {\r\n    type F<'a>: Fn() -> u32;\r\n    \r\n    fn callme<'a>(f: Self::F<'a>) -> u32 {\r\n        f()\r\n    }\r\n}\r\n\r\nimpl <T> Fun for T {\r\n    type F<'a> = Self;\r\n}\r\n\r\nfn main() {\r\n    <u8>::callme(0);\r\n}\r\n```\r\n\r\n<details>\r\n<summary>Backtrace:</summary>\r\n\r\n```\r\nerror: internal compiler error: src/librustc/traits/codegen/mod.rs:57: Encountered error `Unimplemented` selecting `Binder(<u8 as std::ops::Fn<()>>)` during codegen\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:883:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc::ty::context::GlobalCtxt::enter_local\r\n  21: rustc::traits::codegen::codegen_fulfill_obligation\r\n  22: rustc::ty::query::__query_compute::codegen_fulfill_obligation\r\n  23: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::codegen_fulfill_obligation>::compute\r\n  24: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  25: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  26: rustc::ty::instance::Instance::resolve\r\n  27: <rustc_mir::monomorphize::collector::MirNeighborCollector as rustc::mir::visit::Visitor>::visit_terminator_kind\r\n  28: rustc_mir::monomorphize::collector::collect_items_rec\r\n  29: rustc_mir::monomorphize::collector::collect_items_rec\r\n  30: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  31: rustc_mir::monomorphize::collector::collect_crate_mono_items\r\n  32: rustc_mir::monomorphize::partitioning::collect_and_partition_mono_items\r\n  33: rustc::ty::query::__query_compute::collect_and_partition_mono_items\r\n  34: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  35: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  36: rustc_codegen_ssa::base::codegen_crate\r\n  37: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  38: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  39: rustc_interface::passes::QueryContext::enter\r\n  40: rustc_interface::queries::Queries::ongoing_codegen\r\n  41: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  42: scoped_tls::ScopedKey<T>::set\r\n  43: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (3761dcd34 2020-01-28) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C codegen-units=1 -C debuginfo=2 --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [codegen_fulfill_obligation] checking if `std::ops::Fn` fulfills its obligations\r\n#1 [collect_and_partition_mono_items] collect_and_partition_mono_items\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n</details>", "labels": ["C-bug", "F-generic_associated_types", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-29 16:04:48", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556960304": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68643, "title": "GAT ICE: use of PlaceRef { local: _0, projection: [] } before def", "body": "The following code produces an ICE:\r\n```Rust\r\n#![feature(generic_associated_types)]\r\n\r\ntrait Fun {\r\n    type F<'a>: Fn() -> u32;\r\n    \r\n    fn callme<'a>(f: Self::F<'a>) -> u32 {\r\n        f()\r\n    }\r\n}\r\n\r\nimpl <T> Fun for T {\r\n    type F<'a> = Self;\r\n}\r\n\r\nfn main() {\r\n    <fn()>::callme(|| {});\r\n}\r\n```\r\n\r\n<details>\r\n<summary>Backtrace:</summary>\r\n\r\n```\r\n\r\n Compiling playground v0.0.1 (/playground)\r\nwarning: the feature `generic_associated_types` is incomplete and may cause the compiler to crash\r\n --> src/main.rs:1:12\r\n  |\r\n1 | #![feature(generic_associated_types)]\r\n  |            ^^^^^^^^^^^^^^^^^^^^^^^^\r\n  |\r\n  = note: `#[warn(incomplete_features)]` on by default\r\n\r\nerror: internal compiler error: src/librustc_codegen_ssa/mir/operand.rs:403: use of PlaceRef { local: _0, projection: [] } before def\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:883:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc_codegen_ssa::mir::operand::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_consume\r\n  21: rustc_codegen_ssa::mir::block::<impl rustc_codegen_ssa::mir::FunctionCx<Bx>>::codegen_terminator\r\n  22: rustc_codegen_ssa::mir::codegen_mir\r\n  23: <rustc::mir::mono::MonoItem as rustc_codegen_ssa::mono_item::MonoItemExt>::define\r\n  24: rustc_codegen_llvm::base::compile_codegen_unit::module_codegen\r\n  25: rustc::dep_graph::graph::DepGraph::with_task\r\n  26: rustc_codegen_llvm::base::compile_codegen_unit\r\n  27: rustc_codegen_ssa::base::codegen_crate\r\n  28: <rustc_codegen_llvm::LlvmCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  29: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  30: rustc_interface::passes::QueryContext::enter\r\n  31: rustc_interface::queries::Queries::ongoing_codegen\r\n  32: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  33: scoped_tls::ScopedKey<T>::set\r\n  34: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (3761dcd34 2020-01-28) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C codegen-units=1 -C debuginfo=2 --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n</details>\r\n\r\n", "labels": ["C-bug", "F-generic_associated_types", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-29 16:04:43", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556960237": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68642, "title": "GAT's and broken LLVM", "body": "I know GAT's are far from complete, but I've played around with them for a bit, and found some fun ICE's and LLVM errors.\r\n\r\nThe following code produces wrong LLVM output:\r\n```Rust\r\n#![feature(generic_associated_types)]\r\n\r\ntrait Fun {\r\n    type F<'a>: Fn() -> u32;\r\n    \r\n    fn callme<'a>(f: Self::F<'a>) -> u32 {\r\n        f()\r\n    }\r\n}\r\n\r\nimpl <T> Fun for T {\r\n    type F<'a> = Self;\r\n}\r\n\r\nfn main() {\r\n    <fn() -> usize>::callme(|| {1});\r\n}\r\n```\r\n\r\nIt produces\r\n```\r\nFunction return type does not match operand type of return inst!\r\n  ret i64 %4, !dbg !155\r\n i32in function _ZN10playground3Fun6callme17h68e94299655f2c3eE\r\nLLVM ERROR: Broken function found, compilation aborted!\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n", "labels": ["A-codegen", "C-bug", "F-generic_associated_types", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-29 16:04:37", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556937359": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68641, "title": "GAT's arent typechecked, and can cause UB", "body": "It looks like Generic Associated Types aren't validated on whether the specified type on the impl-side indeed implements the traits as written down in the definition of the associated type.\r\n\r\nThe following program shows a use-after-free of a String:\r\n\r\n```Rust\r\n#![feature(generic_associated_types)]\r\ntrait UnsafeCopy {\r\n    type Item<'a>: Copy;\r\n    \r\n    fn copy<'a>(item: &Self::Item<'a>) -> Self::Item<'a> {\r\n        *item\r\n    }\r\n}\r\n\r\nimpl <T> UnsafeCopy for T {\r\n    type Item<'a> = T;\r\n}\r\n\r\nfn main() {\r\n    let mut s = String::from(\"Hello world!\");\r\n    \r\n    let copy = String::copy(&s);\r\n    \r\n    // Do we indeed point to the samme memory?\r\n    assert!(s.as_ptr() == copy.as_ptr());\r\n    \r\n    // Any use of `copy` is certeinly UB after this\r\n    drop(s);\r\n    \r\n    // UB UB UB UB UB!!\r\n    println!(\"{}\", copy);\r\n}\r\n```", "labels": ["C-bug", "F-generic_associated_types", "I-unsound \ud83d\udca5", "T-compiler", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-29 15:28:48", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556836904": {"author_username": "GuillaumeGomez", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68639, "title": "Add error codes duplicates check", "body": "As asked in #67086.\r\n\r\nr? @Mark-Simulacrum ", "labels": ["S-waiting-on-team"], "number_of_comments": 10, "created_at": "2020-01-29 12:41:25", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556820231": {"author_username": "georgeroman", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68637, "title": "'Referencing function in another module` error when compiling for target wasm32-unknown-emscripten (debug mode)", "body": "I'm trying to compile a Rust project that depends on the [`byte-slice-cast`](https://crates.io/crates/byte-slice-cast) crate, but I'm encountering a strange error. The same error pops up if having [`block-padding`](https://crates.io/crates/block-padding) as a dependency. You can find all the details in this issue: https://github.com/sdroege/byte-slice-cast/issues/13. As mentioned there, this only happens when compiling in debug mode, while release builds succeed.\r\n\r\nSome info about the environment:\r\n`rustc 1.40.0 (73528e339 2019-12-16)`\r\n`emcc (Emscripten gcc/clang-like replacement) 1.39.1 ((unknown revision))`", "labels": ["A-LLVM", "C-bug", "O-wasm", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-29 12:07:04", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556777028": {"author_username": "kdy1", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68636, "title": "false positive E037", "body": "While investigating #68564, I found a real bug.\r\n\r\n\r\nhttps://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=c959b9e4ee176c4430586425307787ec\r\n\r\n```rust\r\npub trait Fold<T: ?Sized> {\r\n    fn fold(&mut self, node: T) -> T;\r\n}\r\n\r\nstruct A;\r\nstruct B;\r\n\r\nimpl Fold<A> for dyn Fold<B> {}\r\n```\r\nIt results in an error even on stable.\r\n\r\n`Fold<A>` and `Fold<B>` is treated as a separate trait (#68564) while resolving, but treated as a same trait while verifying impl blocks.\r\n\r\n\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nerror[E0371]: the object type `(dyn Fold<B> + 'static)` automatically implements the trait `Fold`\r\n  --> src/lib.rs:11:1\r\n   |\r\n11 | impl Fold<A> for dyn Fold<B> {}\r\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `(dyn Fold<B> + 'static)` automatically implements trait `Fold`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0371`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```", "labels": ["C-bug", "T-compiler"], "number_of_comments": 1, "created_at": "2020-01-29 10:40:56", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556715335": {"author_username": "idkravitz", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68632, "title": "Strange perforamnce drops with const literals in closures", "body": "I asked about it on [user.rust-lang.org](https://users.rust-lang.org/t/seems-that-optimizer-has-issues-with-closures/37598) and one user suggested that it may be a bug in optimizer indeed. So I should state that the things below are reproducable both in nightly and stable latest rust on x86_64-pc-windows-msvc triplet and x86_64-unknown-linux-gnu (tested inside WSL).\r\n\r\nSo our test subject would be the following snippet, that solves Max subarray problem\r\n```rust\r\npub fn max_subarray_bad(arr: &[i32]) -> (usize, usize, i32)\r\n{\r\n    let prefixes = arr\r\n        .iter()\r\n        .enumerate()\r\n        .scan((0, 0), |s, (i, v)| {\r\n            if s.1 > 0 {\r\n                s.1 = s.1 + *v;\r\n            } else {\r\n                *s = (i, *v);\r\n            }\r\n            Some(*s)\r\n        });\r\n    let (right_idx, (left_idx, sum)) = prefixes\r\n        .enumerate()\r\n        .max_by_key(|&(_, (_, sum))| sum)\r\n        .unwrap();\r\n    \r\n    (left_idx, right_idx + 1, sum)\r\n}\r\n```\r\n\r\nIf we benchmark it with **criterion** crate with this benchmark code:\r\n```rust\r\nuse criterion::{black_box, criterion_group, criterion_main, Criterion};\r\n\r\nfn benchmark_linear(c: &mut Criterion) {\r\n    const N: usize = 1000000;\r\n    c.bench_function(&format!(\"max_subarray([..]) N = {}\", N), |b| {\r\n        b.iter(|| max_subarray::max_subarray_bad(black_box(&vec![0; N])))\r\n    });\r\n}\r\n\r\ncriterion_group!(benches, benchmark_linear);\r\ncriterion_main!(benches);\r\n```\r\nThen the output of `cargo bench` on my machine would be\r\n\r\n    Benchmarking max_subarray([..]) N = 1000000: Warming up for 3.0000 s\r\n    Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 16.6s or reduce sample count to 30.\r\n    max_subarray([..]) N = 1000000\r\n                            time:   [3.2324 ms 3.2700 ms 3.3141 ms]\r\n    Found 10 outliers among 100 measurements (10.00%)\r\n      6 (6.00%) high mild\r\n      4 (4.00%) high severe\r\n\r\n         Running target\\release\\deps\\scratch-b68a42551ab01289.exe\r\n\r\nBut with the slight change of moving out 0 in expression `s.1 > 0` in let binding outside of the closure can make a great difference. So the function is now this:\r\n```rust\r\npub fn max_subarray_bad(arr: &[i32]) -> (usize, usize, i32)\r\n{\r\n    let zro = 0;\r\n    let prefixes = arr\r\n        .iter()\r\n        .enumerate()\r\n        .scan((0, 0), |s, (i, v)| {\r\n            if s.1 > zro {\r\n                s.1 = s.1 + *v;\r\n            } else {\r\n                *s = (i, *v);\r\n            }\r\n            Some(*s)\r\n        });\r\n    let (right_idx, (left_idx, sum)) = prefixes\r\n        .enumerate()\r\n        .max_by_key(|&(_, (_, sum))| sum)\r\n        .unwrap();\r\n    \r\n    (left_idx, right_idx + 1, sum)\r\n}\r\n```\r\nBut `cargo bench` output indicates almost 20% performance gain!\r\n\r\n    Benchmarking max_subarray([..]) N = 1000000: Warming up for 3.0000 s\r\n    Warning: Unable to complete 100 samples in 5.0s. You may wish to increase target time to 12.9s or reduce sample count to 40.\r\n    max_subarray([..]) N = 1000000\r\n                            time:   [2.5705 ms 2.5806 ms 2.5913 ms]\r\n                            change: [-20.260% -19.668% -19.124%] (p = 0.00 < 0.05)\r\n                            Performance has improved.\r\n    Found 4 outliers among 100 measurements (4.00%)\r\n      3 (3.00%) high mild\r\n      1 (1.00%) high severe\r\n\r\n         Running target\\release\\deps\\scratch-b68a42551ab01289.exe\r\n\r\nYou can check that changing function back and forth with replacing 0 and zro in that expression indeed results in 20% performance change.\r\n\r\nBy the way, if we change `let zro = 0` into `const zro: i32 = 0` it results in performance drop too.\r\n\r\nIt looks like a bug in optimizer for me. Could someone verify it?", "labels": ["C-bug", "I-slow", "T-compiler"], "number_of_comments": 24, "created_at": "2020-01-29 08:41:29", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556604841": {"author_username": "bachue", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68628, "title": "Wrong prompt when failed to pattern match boxed enum type", "body": "For example:\r\n\r\n```rust\r\n#[allow(dead_code)]\r\nenum A {\r\n    V1(u8),\r\n    V2(u32),\r\n}\r\n\r\nfn main() {\r\n    let a = Some(Box::new(A::V1(1u8)));\r\n    \r\n    if let Some(b) = a.as_ref() {\r\n        if let A::V1(v) = b {\r\n            println!(\"{:?}\", v);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\nThe rust 1.40 compiler will failed to compile this code and tell me:\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n  --> src/main.rs:11:16\r\n   |\r\n11 |         if let A::V1(v) = b {\r\n   |                ^^^^^^^^   -\r\n   |                |          |\r\n   |                |          this match expression has type `std::boxed::Box<A>`\r\n   |                |          help: consider dereferencing the boxed value: `*b`\r\n   |                expected struct `std::boxed::Box`, found enum `A`\r\n   |\r\n   = note: expected type `std::boxed::Box<A>`\r\n              found type `A`\r\n```\r\n\r\nBut unfortunately it's wrong. If I replace `b` by `*b`, it will failed again and tell me:\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n  --> src/main.rs:11:16\r\n   |\r\n11 |         if let A::V1(v) = *b {\r\n   |                ^^^^^^^^   --\r\n   |                |          |\r\n   |                |          this match expression has type `std::boxed::Box<A>`\r\n   |                |          help: consider dereferencing the boxed value: `**b`\r\n   |                expected struct `std::boxed::Box`, found enum `A`\r\n   |\r\n   = note: expected type `std::boxed::Box<A>`\r\n              found type `A`\r\n``` \r\n\r\nAlthough the second prompt is correct and it works. But I think using `b.as_ref()` is the better idea.", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-29 02:47:35", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556536384": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68622, "title": "StorageLive (and even StorageDead) may be unnecessary in MIR.", "body": "A while back I was discussing `Storage{Live,Dead}` and dominators, with @tmandry (in the context of generator layout optimizations), and came to the conclusion that `StorageLive` pretty much *has to* dominate all uses (I doubt we ever added a check that it does so, though).\r\n\r\nMore recently, I was trying to figure out what the simplest \"`StorageLive` sinking\" (i.e. moving the statement \"later\" in the CFG) optimization we could do was.\r\n\r\nThe conclusion I came to was that we might not need `StorageLive` at all, because there might be a deterministic \"best placement\" we could compute (assuming we need *exactly* one `llvm.lifetime.start` per `alloca`).\r\n\r\n<hr/>\r\n\r\nThat best placement would be the *least (common) dominator* of all mentions of a MIR local.\r\nEven indirect accesses require a direct borrow beforehand, so this should cover everything.\r\n\r\n(Assuming that, given CFG points `x`, `y`, `z`, \"`x` is a common dominator of `y` and `z`\" means \"`x` dominates both `y` and `z`\", i.e. \"to reach either `y` or `z` you must go through `x` first\", and the \"least\" such `x` is the one not dominating other common dominators of `y` and `z`, i.e. it's \"the closest to `y` and `z`\")\r\n\r\nThis could be:\r\n* just before the single assignment of that local\r\n  * `let x = x + y;`\r\n* at the end of a block branching into paths which all assign that local\r\n  * `let x = if c { a } else { b };`\r\n  * `let x; if c { x = a; } else { x = b; }` (roughly equivalent)\r\n\r\nI am not sure about interactions with loops, though.\r\n\r\nBut this doesn't have to remain theoretical, we could compute this \"ideal `StorageLive` position\" and then compare it with the existing one (presumably one would dominate the other? not sure this would catch any loop issues though).\r\n\r\n<hr/>\r\n\r\n`StorageDead` could also be similar (\"least (common) post-dominator\"?).\r\n\r\nHowever, it also has the effect of invalidating borrows, so we would need to keep an `InvalidateBorrows(x)` statement around, and consider it one of the mentions of `x`.\r\n\r\nThen \"`Storage{Live,Dead}` range shrinking\" would simply boil down to hoisting `InvalidateBorrows(x)` up past statements which couldn't indirectly access `x`.\r\n\r\n<hr/>\r\n\r\ncc @nikomatsakis @ecstatic-morse @rust-lang/wg-mir-opt", "labels": ["A-mir", "C-cleanup", "T-compiler"], "number_of_comments": 8, "created_at": "2020-01-28 23:01:14", "reactions": {"total_count": 3, "+1": 3, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556490438": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68618, "title": "Allow `#[attr] if` to be passed to proc macros", "body": "The following code:\r\n\r\n```rust\r\nfn main() {\r\n    #[attr] if let Some(_) = Ok(true) {}\r\n}\r\n```\r\n\r\nproduces this error:\r\n\r\n```\r\nerror: attributes are not yet allowed on `if` expressions\r\n --> src/main.rs:2:5\r\n  |\r\n2 |     #[attr] if let Some(_) = Ok(true) {}\r\n  |     ^^^^^^^\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\nProc macros like [`pin-project`](https://github.com/taiki-e/pin-project) currently use a trick to work around attributes on expressions being unstable: The entire function is annotated with a 'wrapper' attribute, which goes through and manually parses expression attributes. For example:\r\n\r\n```rust\r\n#[my_attr]\r\nfn foo() {\r\n    #[my_attr] let a = 25;\r\n}\r\n```\r\n\r\nIn the example above, the `#[my_attr] let a = 25;` will be processed by the outer `#[my_attr] fn foo()` implementation, which will strip away the expression-based `#[my_attr]` before emitting the final `TokenStream`.\r\n\r\nUnfortunately, the current 'attributes are not yet allowed on `if` expressions' check is done during parsing:\r\n\r\nhttps://github.com/rust-lang/rust/blob/ac2f3fa41ac5ae8425b959f955bb7433b7c57aea/src/librustc_parse/parser/expr.rs#L679\r\n\r\nWhile the proc-macro itself can parse the attribute on the `if let` without any errors, compilation will still fail due to the parsing error that was emitted *before* any proc-macros were run.\r\n\r\nIt would be extremely useful if this check were to be moved until **after** parsing, so that proc macros had a chance to remove attributes from `if` expressions.", "labels": ["A-attributes", "A-frontend", "A-parser", "C-feature-request", "T-compiler", "T-lang"], "number_of_comments": 5, "created_at": "2020-01-28 21:49:07", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556475404": {"author_username": "joshtriplett", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68617, "title": "UdpSocket: please support vectored send", "body": "The `UdpSocket` type provides `send` and `send_to` methods, but does not provide a vectored send operation. Such an operation is particularly helpful for datagrams, where separate send operations result in separate datagrams; a vectored send allows sending data from multiple buffers in a single datagram.\r\n\r\nThis would require calling `sendmsg`, which supports supplying an iovec. (This should work on Windows as well.)", "labels": ["C-feature-request", "T-libs"], "number_of_comments": 0, "created_at": "2020-01-28 21:20:33", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556458794": {"author_username": "jplatte", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68615, "title": "Instantiating a type that's const-generic over a custom type doesn't work", "body": "Code ([Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=cacbacd3b806815e765094cc69842bcd)):\r\n\r\n```rust\r\n#![feature(const_generics)]\r\n\r\n#[derive(PartialEq, Eq)]\r\nstruct MyType;\r\nstruct Const<const V: MyType> {}\r\ntype MyConst = Const<{ MyType }>;\r\n\r\nfn main() {\r\n    let _x = Const::<{ MyType }> {};\r\n    let _y = MyConst {};\r\n}\r\n```\r\n\r\nError message:\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n --> src/main.rs:9:14\r\n  |\r\n9 |     let _x = Const::<{ MyType }> {};\r\n  |              ^^^^^^^^^^^^^^^^^^^^^^ expected `ByRef { alloc: Allocation { bytes: [], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [], len: Size { raw: 0 } }, size: Size { raw: 0 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }: MyType`, found `ByRef { alloc: Allocation { bytes: [], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [], len: Size { raw: 0 } }, size: Size { raw: 0 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }: MyType`\r\n  |\r\n  = note: expected type `_`\r\n           found struct `Const<ByRef { alloc: Allocation { bytes: [], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [], len: Size { raw: 0 } }, size: Size { raw: 0 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }: MyType>`\r\n\r\nerror[E0308]: mismatched types\r\n  --> src/main.rs:10:14\r\n   |\r\n10 |     let _y = MyConst {};\r\n   |              ^^^^^^^^^^ expected `ByRef { alloc: Allocation { bytes: [], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [], len: Size { raw: 0 } }, size: Size { raw: 0 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }: MyType`, found `ByRef { alloc: Allocation { bytes: [], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [], len: Size { raw: 0 } }, size: Size { raw: 0 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }: MyType`\r\n   |\r\n   = note: expected type `_`\r\n            found struct `Const<ByRef { alloc: Allocation { bytes: [], relocations: Relocations(SortedMap { data: [] }), undef_mask: UndefMask { blocks: [], len: Size { raw: 0 } }, size: Size { raw: 0 }, align: Align { pow2: 0 }, mutability: Not, extra: () }, offset: Size { raw: 0 } }: MyType>`\r\n```", "labels": ["A-const-generics", "C-bug", "F-const_generics", "T-compiler", "requires-nightly"], "number_of_comments": 1, "created_at": "2020-01-28 20:46:08", "reactions": {"total_count": 2, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556421488": {"author_username": "joshtriplett", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68612, "title": "UnixDatagram: please support vectored send", "body": "The `UnixDatagram` type provides `send` and `send_to` methods, but does not provide a vectored send operation. Such an operation is particularly helpful for datagrams, where separate send operations result in separate datagrams; a vectored send allows sending data from multiple buffers in a single datagram.\r\n\r\nGiven that `UnixDatagram` only runs on UNIX, where `writev` works just fine on a socket, such an operation could use `writev`; alternatively, this could use `sendmsg`, which supports supplying an iovec. `sendmsg` would also allow a vectored `send_to` operation.", "labels": ["C-feature-request", "T-libs"], "number_of_comments": 2, "created_at": "2020-01-28 19:34:19", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556386982": {"author_username": "jgalenson", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68608, "title": "Occasional non-reproducibility when building librls and libcargo", "body": "Occasionally (perhaps 1/3 of the time, so it's not that rare) when doing multiple builds with `extended = true` (and hence building tools including rls and cargo), I get different libcargo.rlib and librls.rlib files.\r\n\r\nDuring a normal build, libcargo gets built once (reproducibly for me), but on these bad builds it gets built twice.  The command line is slightly different the second time, as it has `,artifacts` appended to its `--json` argument (due to [this code](https://github.com/rust-lang/cargo/blob/rust-1.42.0/src/cargo/core/compiler/mod.rs#L684)).  This difference gets propagated to librls, which depends on libcargo.\r\n\r\nI believe this is due to rustc's bootstrap compiler invoking cargo separately for each tool.  If the cargo build finishes early enough, the rls build can use its result.  But if it does not, the rls build seems to fire off its own compile, which causes the above issue.\r\n\r\nNote that this is a part of #34902.", "labels": ["A-reproducibility", "C-bug", "T-compiler"], "number_of_comments": 1, "created_at": "2020-01-28 18:24:35", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556312439": {"author_username": "Nokel81", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68604, "title": "E0700 does not point to where the captured lifetime is", "body": "The error message \r\n\r\n```rust\r\nerror[E0700]: hidden type for `impl Trait` captures lifetime that does not appear in bounds\r\n```\r\n\r\ndoes not point to where in the block the captured lifetime is (which makes debugging it difficult).\r\n\r\nIt does, however, point to the scope:\r\n\r\n```rust\r\nnote: hidden type `impl futures::Future` captures the scope of call-site for function at 48:40\r\n  --> rs/agent-updater/src/fetcher.rs:48:40\r\n   |\r\n48 |       ) -> Result<PathBuf, FetcherError> {\r\n   |  ________________________________________^\r\n49 | |         let checksum = m.get_valid_checksum()?;\r\n51 | |\r\n...  |\r\n72 | |         Ok(folder)\r\n73 | |     }\r\n   | |_____^\r\n```", "labels": ["A-async-await", "A-diagnostics", "AsyncAwait-Triaged", "C-enhancement", "D-papercut", "T-compiler"], "number_of_comments": 5, "created_at": "2020-01-28 16:09:14", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556194458": {"author_username": "aristarh2704", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68599, "title": "Cross-platform conflict while linking", "body": "Now I try use nightly rustc on cygwin. While compiling libbacktrase-sys, mingw-gcc uses cygwin headers, for example, it take errno value as \"__errno()\", and after compiling, symbol dumping shows that library has undefined reference to \"___errno\" (with 3 underscores). While libmsvcrt adds this function named __errno (with 2 underscores). This makes it impossible to compile on the cygwin platform. I think the mingw compiler shipped with rustc must have its own headers.\r\n```\r\n$ rustc -vV\r\nrustc 1.42.0-nightly (8a79d08fa 2020-01-27)\r\nbinary: rustc\r\ncommit-hash: 8a79d08fa57e1c257d647c9848e35defcb379c07\r\ncommit-date: 2020-01-27\r\nhost: i686-pc-windows-gnu\r\nrelease: 1.42.0-nightly\r\nLLVM version: 9.0\r\n```\r\nI can use the hack with editing errno.h, but it's not good solution.", "labels": [], "number_of_comments": 4, "created_at": "2020-01-28 13:01:17", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556126383": {"author_username": "qwerty19106", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68596, "title": "Const generics ICE (\"unexpected const parent in type_of_def_id\") on const param of method", "body": "The code:\r\n```\r\n#![feature(const_generics)]\r\n#![feature(const_fn)]\r\n\r\npub struct S(u8);\r\n\r\nimpl S {\r\n    pub fn get<const A: u8>(&self) -> &u8 {\r\n        &self.0\r\n    }\r\n}\r\n\r\nfn main() {\r\n    const A: u8 = 5;\r\n    let s = S(0);\r\n    \r\n    s.get::<A>();\r\n}\r\n```\r\ncause ICE:\r\n```\r\nerror: internal compiler error: unexpected const parent in type_of_def_id(): Expr(expr(HirId { owner: DefIndex(9), local_id: 15 }: s.get::<>()))\r\n\r\nerror: internal compiler error: mir_const_qualif: MIR had errors\r\n  --> a.rs:16:13\r\n   |\r\n16 |     s.get::<A>();\r\n   |             ^\r\n\r\nerror: internal compiler error: PromoteTemps: MIR had errors\r\n  --> a.rs:16:13\r\n   |\r\n16 |     s.get::<A>();\r\n   |             ^\r\n\r\nerror: internal compiler error: broken MIR in DefId(0:11 ~ a[317d]::main[0]::{{constant}}[0]) (\"return type\"): bad type [type error]\r\n  --> a.rs:16:13\r\n   |\r\n16 |     s.get::<A>();\r\n   |             ^\r\n\r\nerror: internal compiler error: broken MIR in DefId(0:11 ~ a[317d]::main[0]::{{constant}}[0]) (LocalDecl { mutability: Mut, local_info: Other, internal: false, is_block_tail: None, ty: [type error], user_ty: UserTypeProjections { contents: [] }, source_info: SourceInfo { span: a.rs:16:13: 16:14, scope: scope[0] } }): bad type [type error]\r\n  --> a.rs:16:13\r\n   |\r\n16 |     s.get::<A>();\r\n   |             ^\r\n\r\nthread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:357:17\r\n```\r\n\r\nAnd this code variant also gives ICE:\r\n```\r\ns.get::<A>();\r\n\r\nerror: internal compiler error: broken MIR in DefId(0:9 ~ a[317d]::main[0]) (const S::get::<Scalar(<ZST>): [type error]>): bad type for<'r> fn(&'r S) -> &'r u8 {S::get::<Scalar(<ZST>): [type error]>}\r\n  --> a.rs:16:7\r\n   |\r\n16 |     s.get();\r\n   |       ^^^\r\n\r\nthread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:357:17\r\n```\r\n\r\nComplied by:\r\n```\r\nnote: rustc 1.42.0-nightly (8a79d08fa 2020-01-27) running on x86_64-unknown-linux-gnu\r\n```\r\n\r\n[playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=835a096f22c2b20f0c8037254711f34b)", "labels": ["A-const-generics", "C-bug", "F-const_generics", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 1, "created_at": "2020-01-28 10:47:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "556024048": {"author_username": "aticu", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68593, "title": "`Vec` and `Box` documentation do not state maximum allocation size guarantee", "body": "In the documentation for [`pointer::add`](https://doc.rust-lang.org/nightly/std/primitive.pointer.html#method.add), it is mentioned that\r\n\r\n> `Vec` and `Box` ensure they never allocate more than `isize::MAX` bytes\r\n\r\nhowever, this is not stated in [documentation of `Vec`](https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html), the [module documentation of `vec`](https://doc.rust-lang.org/nightly/alloc/vec/index.html), the [documentation of `Box`](https://doc.rust-lang.org/nightly/alloc/boxed/struct.Box.html) or the [module documentation of `boxed`](https://doc.rust-lang.org/nightly/alloc/boxed/index.html).\r\n\r\nThis can cause doubt, whether this statement actually holds true, since the places where one would expect such guarantees to be made (especially the \"Guarantees\" section of the `Vec` documentation) does not mention these guarantees.", "labels": ["A-collections", "C-enhancement", "T-doc", "T-libs"], "number_of_comments": 2, "created_at": "2020-01-28 07:10:09", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555970890": {"author_username": "programmerjake", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68590, "title": "rustc loosing track of DerefMut impl on nested type", "body": "The following code should compile but doesn't. With only 9 nesting levels, I wouldn't expect to be running into deref-limits yet.\r\n\r\n```rust\r\nuse std::ops::{Deref, DerefMut};\r\n\r\ntrait DynTrait {\r\n    fn f(&mut self);\r\n}\r\n\r\nstruct Base<'a> {\r\n    dyn_trait: &'a mut dyn DynTrait,\r\n}\r\n\r\nmacro_rules! impl_type {\r\n    ($derived:ident, $base:ident) => {\r\n        struct $derived<'a> {\r\n            base: $base<'a>,\r\n        }\r\n        \r\n        impl<'a> Deref for $derived<'a> {\r\n            type Target = $base<'a>;\r\n            fn deref(&self) -> &$base<'a> {\r\n                &self.base\r\n            }\r\n        }\r\n        \r\n        impl<'a> DerefMut for $derived<'a> {\r\n            fn deref_mut(&mut self) -> &mut $base<'a> {\r\n                &mut self.base\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nimpl_type!(Level1, Base);\r\nimpl_type!(Level2, Level1);\r\nimpl_type!(Level3, Level2);\r\nimpl_type!(Level4, Level3);\r\nimpl_type!(Level5, Level4);\r\nimpl_type!(Level6, Level5);\r\nimpl_type!(Level7, Level6);\r\nimpl_type!(Level8, Level7);\r\nimpl_type!(Level9, Level8);\r\n\r\nfn take_dyn_trait(dyn_trait: &mut dyn DynTrait) {}\r\n\r\nfn f<'a>(value: &mut Level9<'a>) {\r\n    // uncomment following line to make compile\r\n    //let value: &mut Base = value;\r\n    take_dyn_trait(value.dyn_trait);\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=9b028c992c41bf07271254ab2a3cc1c6))\r\n\r\nErrors:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nwarning: unused variable: `dyn_trait`\r\n  --> src/lib.rs:42:19\r\n   |\r\n42 | fn take_dyn_trait(dyn_trait: &mut dyn DynTrait) {}\r\n   |                   ^^^^^^^^^ help: consider prefixing with an underscore: `_dyn_trait`\r\n   |\r\n   = note: `#[warn(unused_variables)]` on by default\r\n\r\nerror[E0596]: cannot borrow data in a dereference of `Level1<'_>` as mutable\r\n  --> src/lib.rs:47:20\r\n   |\r\n47 |     take_dyn_trait(value.dyn_trait);\r\n   |                    ^^^^^^^^^^^^^^^ cannot borrow as mutable\r\n   |\r\n   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `Level1<'_>`\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0596`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 2, "created_at": "2020-01-28 04:11:30", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555964661": {"author_username": "programmerjake", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68589, "title": "casting trait methods to FnOnce(&mut dyn Trait) is not ergonomic", "body": "In the following code, I'm trying to cast `Trait::f` to `FnOnce(&mut dyn Trait)` which should be possible, but the obvious method doesn't work. None of the combinations I tried got it to work (I could just use a lambda that called `f`, but that defeats the purpose).\r\n\r\n```rust\r\ntrait Trait {\r\n    fn f(&mut self);\r\n}\r\n\r\nfn g<F: FnOnce(&mut dyn Trait)>(f: F) {}\r\n\r\nfn f() {\r\n    g(Trait::f)\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=def622e8ed38388cb543e450467bdc00))\r\n\r\nErrors:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nerror[E0631]: type mismatch in function arguments\r\n --> src/lib.rs:8:7\r\n  |\r\n2 |     fn f(&mut self);\r\n  |     ---------------- found signature of `for<'r> fn(&'r mut _) -> _`\r\n...\r\n5 | fn g<F: FnOnce(&mut dyn Trait)>(f: F) {}\r\n  |    -    ---------------------- required by this bound in `g`\r\n...\r\n8 |     g(Trait::f)\r\n  |       ^^^^^^^^ expected signature of `for<'r> fn(&'r mut (dyn Trait + 'r)) -> _`\r\n\r\nerror[E0271]: type mismatch resolving `for<'r> <for<'s> fn(&'s mut _) {<_ as Trait>::f} as std::ops::FnOnce<(&'r mut (dyn Trait + 'r),)>>::Output == ()`\r\n --> src/lib.rs:8:5\r\n  |\r\n5 | fn g<F: FnOnce(&mut dyn Trait)>(f: F) {}\r\n  |    -    ---------------------- required by this bound in `g`\r\n...\r\n8 |     g(Trait::f)\r\n  |     ^ expected bound lifetime parameter, found concrete lifetime\r\n\r\nerror: aborting due to 2 previous errors\r\n\r\nFor more information about this error, try `rustc --explain E0271`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 4, "created_at": "2020-01-28 03:43:17", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555889926": {"author_username": "Centril", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68585, "title": "Tracking issue for conflicting `repr(...)` hints future compatibility", "body": "This is the **summary issue** for a bug fix related to `repr(...)` hints. The goal of this page is describe why this change was made and how you can fix code that is affected by it. It also provides a place to ask questions or register a complaint if you feel the change should not be made. For more information on the policy around future-compatibility warnings, see our [breaking change policy guidelines][guidelines].\r\n\r\n[guidelines]: https://forge.rust-lang.org/rustc-bug-fix-procedure.html\r\n\r\n### What is the warning for?\r\n\r\nThe compiler incorrectly accepts `#[repr(...)]` hints on data types where the hints are incompatible and have conflicts. Examples of this includes:\r\n\r\n```rust\r\n// from `src/test/ui/conflicting-repr-hints.rs\r\n\r\n#[repr(u32, u64)] //~ ERROR conflicting representation hints\r\nenum D {\r\n    D,\r\n}\r\n```\r\n\r\nWe are presently issuing a deny-by-default lint when conflicting representation hints are used together but we expect to transition the lint to hard **errors** in the future.\r\n\r\n### How can you fix your code?\r\n\r\nGenerally speaking, the conflict should be fixed by more clearly expressing your intent so that the conflict is resolved.", "labels": ["A-lint", "C-future-compatibility"], "number_of_comments": 1, "created_at": "2020-01-27 23:13:51", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 1, "hooray": 0}}, "555750803": {"author_username": "Centril", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68577, "title": "[WIP] [let_chains, 4/N] Introduce `hir::ExprKind::Let`", "body": "Introduces `hir::ExprKind::Let(&Pat<'_>, &Expr<'_>)`. That is, this introduces `let pat = expr` expressions.\r\n\r\nFor now, this is very much WIP and probably depends on https://github.com/rust-lang/rust/pull/67668 to remove the hacks in HAIR / region / generator_interior, but I thought it would be useful to have this open for discussion purposes and so that I can check perf.\r\n\r\ncc https://github.com/rust-lang/rust/issues/53667.\r\n\r\nr? @matthewjasper cc @oli-obk ", "labels": ["F-let_chains", "S-waiting-on-author"], "number_of_comments": 7, "created_at": "2020-01-27 18:23:03", "reactions": {"total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555713304": {"author_username": "RReverser", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68574, "title": "Expose WASI symlink helper", "body": "Currently, Unix and Windows expose `std::os::unix::symlink` and `std::os::windows::fs::symlink_file` correspondingly, which both simply accept source and destination by `Path`.\r\n\r\nHowever, the currently exposed WASI method - `std::os::wasi::fs::symlink` is lower-level and requires user to have a file descriptor of the preopened directory in addition to the file paths:\r\n\r\nhttps://github.com/rust-lang/rust/blob/8a79d08fa57e1c257d647c9848e35defcb379c07/src/libstd/sys/wasi/ext/fs.rs#L397-L405\r\n\r\nThis is different from all other `fs` methods and not ideal, because it requires calling even more lower-level methods to find and retrieve that preopened directory by file path first, and libpreopen isn't exposed to users, so they have to do this all manually.\r\n\r\nMoreover, the codebase already contains a higher-level helper for symlinking files by path and hiding these syscall details, it's just not currently exposed to users:\r\n\r\nhttps://github.com/rust-lang/rust/blob/a605441e049f0b6d5f7715b94b8ac4662fd7fcf6/src/libstd/sys/wasi/fs.rs#L538-L541\r\n\r\nIf this is not too late in terms of backwards compatibility, it would be better to remove the currently exposed low-level syscall and expose this helper instead, so that users could work on paths more easily like they do on other platforms.\r\n\r\nAlternatively, it's necessary to at least expose helpers for retrieving the preopen directory from a file path, as otherwise it's not possible to construct symlinks from userland without invoking raw syscalls.", "labels": ["C-feature-request", "O-wasm", "T-libs"], "number_of_comments": 0, "created_at": "2020-01-27 17:10:44", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555528689": {"author_username": "varkor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68567, "title": "`Rvalue::Repeat` should hold a `ty::Const`", "body": "```rust\r\nfn test<const N: usize>() {\r\n    let array = [0; N];\r\n}\r\n```\r\ncurrently fails with `error: array lengths can't depend on generic parameters`, because we can't tell what concrete value `N` should take here. This is an artificial limitation: when producing a `Rvalue::Repeat`, we currently need to provide the length of the array, which is impossible at this stage.\r\ncc https://github.com/rust-lang/rust/issues/43408#issuecomment-578526551", "labels": ["A-const-generics", "A-mir", "C-enhancement", "F-const_generics", "T-compiler"], "number_of_comments": 1, "created_at": "2020-01-27 12:00:11", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555420893": {"author_username": "joshtriplett", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68565, "title": "peek methods for UnixDatagram and UnixStream?", "body": "https://github.com/rust-lang/rust/issues/38980 added `peek` and `peek_from` methods for `UdpSocket`, and added `peek` to `TcpStream`.\r\n\r\nWould it be possible to add the `peek` and `peek_from` methods to `UnixDatagram` as well, and to add the `peek` method to `UnixStream`?\r\n\r\nI would also be interested in having a Linux extension method for `UnixDatagram` that calls recv with `MSG_PEEK | MSG_TRUNC`, to block until the next packet is available and return the length of that packet. Perhaps `next_packet_len()`? (Doing that is possible on some other platforms via different methods, but some platforms can't do it at all without just reading and buffering the pending packet via `MSG_PEEK` with increasingly large buffers.)", "labels": ["C-feature-request", "T-libs"], "number_of_comments": 0, "created_at": "2020-01-27 08:18:48", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555382197": {"author_username": "kdy1", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68564, "title": "specialization: default impl is used, ignoring the vtable of original value", "body": "When I cast a variable to `dyn Trait`, original vtable is ignored, and default implementation is called even if the casted variable has its own implementation.\r\n\r\n\r\n<del> https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=c184c5f2df18c01d91357da3a0053e4a </del>\r\n\r\nI minimized it.\r\n\r\nhttps://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=c2f4879c62e70f03732a365321e67e79\r\n\r\n\r\nCasting as a dyn trait like the code below ignores vtable of the original value.\r\n```rust\r\n<Self as FoldWith<&mut dyn Fold<Self>>>::fold_with(self, &mut (_f as _))\r\n```\r\n\r\nI expected a test to pass.", "labels": ["A-specialization", "C-bug", "F-specialization", "T-compiler", "requires-nightly"], "number_of_comments": 2, "created_at": "2020-01-27 06:31:45", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555350845": {"author_username": "nikomatsakis", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68561, "title": "impl Trait error message expected/found order are confusing", "body": "@jonas-schievink pointed out that the \"expected/found\" ordering for `-> impl trait` return types can be quite confusing:\r\n\r\n```rust\r\ntrait Tr {\r\n    type A;\r\n}\r\n\r\nimpl<A> Tr for A {\r\n    type A = A;\r\n}\r\n\r\nfn f() -> impl Tr<A=u8> {\r\n    ()\r\n}\r\n```\r\n\r\ngives\r\n\r\n```\r\nerror[E0271]: type mismatch resolving `<() as Tr>::A == u8`\r\n --> src/lib.rs:9:11\r\n  |\r\n9 | fn f() -> impl Tr<A=u8> {\r\n  |           ^^^^^^^^^^^^^ expected (), found u8\r\n  |\r\n  = note: expected type `()`\r\n             found type `u8`\r\n  = note: the return type of a function must have a statically known size\r\n```\r\n\r\nAdditionally, the second note is wrong (`()` is `Sized`).\r\n\r\nThis does not happen when changing the code to use a boxed trait instead (expected and found are in the right order).\r\n\r\n_Originally posted by @jonas-schievink in https://github.com/rust-lang/rust/issues/54326#issuecomment-578284507_", "labels": ["A-diagnostics", "A-impl-trait", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-27 04:31:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555300596": {"author_username": "maxburke", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68559, "title": "BufReader::seek -- should this discard the buffer when pos is SeekFrom::Current(0)?", "body": "It looks like the stream_position() convenience function is implemented with `stream.seek(SeekFrom::Current(0))`; when called on a BufReader this causes it to discard the inner buffer.\r\n\r\nIs this expected? Is it possible to have the BufReader in the case of the position being SeekFrom::Current(0) not discard?", "labels": ["T-libs"], "number_of_comments": 0, "created_at": "2020-01-26 22:54:35", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555289439": {"author_username": "djugei", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68555, "title": "Infinite type recursion on unused import.", "body": "ok this one is a bit special.\r\nwhen i have an unused import rustc tells me about an infinite recursion. when i do not have an unused import it compiles without issue. when i have an unused import in two files it also compiles without (further) warnings.\r\n\r\nthis happened in this [code](https://github.com/djugei/optimath/tree/f39d6d378826c345a8136d93c19fbcd087a13d3c), notice the [commit](https://github.com/djugei/optimath/commit/f39d6d378826c345a8136d93c19fbcd087a13d3c).\r\n\r\ni would expect rustc to either give me an error in all three cases, or in none.\r\n\r\nthis specific infinite recursion error has occurred to me multiple times before, but had some kind of reason at least, even though the error message was not related to the error in the code.\r\n\r\nAlso copying only the code from those two files into a different project does not cause the error. so i could not really produce a minimal example (sorry), but its probably related to const generics, recursive types, specialization or all of the above.\r\n\r\nreproducible on both a recent nightly and one from december.\r\n\r\n\r\n\r\n", "labels": [], "number_of_comments": 0, "created_at": "2020-01-26 21:17:55", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555236218": {"author_username": "Marwes", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68551, "title": "perf: Reuse a Vec in mir simplification", "body": "Just moves the vec out of the outer loop so it is reused every iteration", "labels": ["S-waiting-on-review"], "number_of_comments": 28, "created_at": "2020-01-26 14:28:49", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555233155": {"author_username": "lispc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68550, "title": "Rustc bug:cannot convert `ReEmpty` to a region vid", "body": "When compiling my code, I saw cargo/rustc panicked.\r\n\r\nI tried this code:\r\n\r\n```\r\npub struct Data<A> {\r\n    pub a: A,\r\n}\r\n\r\nimpl<A> Data<A>\r\nwhere\r\n    A: 'static,\r\n    &'static A: ,\r\n{\r\n    pub fn run() {\r\n        let mut entries: Vec<A> = Vec::new();\r\n        if !entries.is_empty() {}\r\n    }\r\n}\r\n\r\npub type DataA = Data<i32>;\r\n\r\nfn main() {\r\n    println!(\"Hello, world!\");\r\n}\r\n```\r\n\r\nThe output is\r\n\r\n```\r\n $ cargo build\r\n   Compiling rustc-crash v0.1.0 (/Users/zhangzhuo/repos/personal/rustc-crash)\r\nerror: internal compiler error: src/librustc_mir/borrow_check/universal_regions.rs:729: cannot convert `ReEmpty` to a region vid\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:883:9\r\nnote: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (6d3f4e0aa 2020-01-25) running on x86_64-apple-darwin\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type bin\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `rustc-crash`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n\r\n\r\n## Meta\r\n\r\n`rustc --version --verbose`:\r\n\r\n```\r\nrustc 1.42.0-nightly (6d3f4e0aa 2020-01-25)\r\nbinary: rustc\r\ncommit-hash: 6d3f4e0aab3e36ceb8b83d1e9467514685f6b751\r\ncommit-date: 2020-01-25\r\nhost: x86_64-apple-darwin\r\nrelease: 1.42.0-nightly\r\nLLVM version: 9.0\r\n```\r\n\r\n\r\n", "labels": ["A-borrow-checker", "C-bug", "I-ICE", "P-high", "T-compiler", "glacier"], "number_of_comments": 2, "created_at": "2020-01-26 14:05:59", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555160697": {"author_username": "rodrimati1992", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68549, "title": "miri:error printing the return value of align_to_mut", "body": "Attempting to run this code:\r\n```rust\r\nfn main() {\r\n    dbg!(unsafe { [1u8,2,3,4,5].align_to_mut::<[u8;2]>() });\r\n}\r\n```\r\nin miri 2020-01-15 [in the playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=30a9352b0f4964fa3a7aeee0e24006d6),results in this error:\r\n```\r\n\r\n[src/main.rs:2] unsafe { [1u8, 2, 3, 4, 5].align_to_mut::<[u8; 2]>() } = (\r\n    [],\r\nerror: Miri evaluation error: trying to reborrow for SharedReadOnly, but parent tag <1287> does not have an appropriate item in the borrow stack\r\n    --> /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore/fmt/mod.rs:1963:71\r\n     |\r\n1963 |             fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }\r\n     |                                                                       ^^^^^^^ trying to reborrow for SharedReadOnly, but parent tag <1287> does not have an appropriate item in the borrow stack\r\n     |\r\n     = note: inside call to `<&mut [[u8; 2]] as std::fmt::Debug>::fmt` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore/fmt/mod.rs:1959:81\r\n     = note: inside call to `<&&mut [[u8; 2]] as std::fmt::Debug>::fmt` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore/fmt/builders.rs:342:17\r\n     = note: inside call to closure at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore/result.rs:721:22\r\n     = note: inside call to `std::result::Result::<(), std::fmt::Error>::and_then::<(), [closure@DefId(2:5728 ~ core[279e]::fmt[0]::builders[0]::{{impl}}[4]::field[0]::{{closure}}[0]) 0:&mut &mut std::fmt::DebugTuple, 1:&&dyn std::fmt::Debug]>` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore/fmt/builders.rs:334:23\r\n     = note: inside call to `std::fmt::DebugTuple::field` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore/fmt/mod.rs:2128:21\r\n     = note: inside call to `<&(&mut [u8], &mut [[u8; 2]], &mut [u8]) as std::fmt::Debug>::fmt` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore/fmt/mod.rs:1097:5\r\n     = note: inside call to `core::fmt::run` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libcore/fmt/mod.rs:1061:17\r\n     = note: inside call to `std::fmt::write` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/io/mod.rs:1426:15\r\n     = note: inside call to `<std::io::StderrLock as std::io::Write>::write_fmt` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/io/stdio.rs:706:9\r\n     = note: inside call to `<std::io::Stderr as std::io::Write>::write_fmt` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/io/stdio.rs:800:13\r\n     = note: inside call to closure at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/thread/local.rs:262:16\r\n     = note: inside call to `std::thread::LocalKey::<std::cell::RefCell<std::option::Option<std::boxed::Box<dyn std::io::Write + std::marker::Send>>>>::try_with::<[closure@DefId(1:2778 ~ std[8be3]::io[0]::stdio[0]::print_to[0]::{{closure}}[0]) 0:&std::fmt::Arguments, 1:&fn() -> std::io::Stderr], std::result::Result<(), std::io::Error>>` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/io/stdio.rs:793:18\r\n     = note: inside call to `std::io::stdio::print_to::<std::io::Stderr>` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/io/stdio.rs:828:5\r\nnote: inside call to `std::io::_eprint` at <::std::macros::eprintln macros>:2:4\r\n    --> src/main.rs:2:5\r\n     |\r\n2    |     dbg!(unsafe { [1u8,2,3,4,5].align_to_mut::<[u8;2]>() });\r\n     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n     = note: inside call to `main` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/rt.rs:67:34\r\n     = note: inside call to closure at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/rt.rs:52:73\r\n     = note: inside call to closure at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/sys_common/backtrace.rs:129:5\r\n     = note: inside call to `std::sys_common::backtrace::__rust_begin_short_backtrace::<[closure@DefId(1:6019 ~ std[8be3]::rt[0]::lang_start_internal[0]::{{closure}}[0]::{{closure}}[0]) 0:&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe], i32>` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/rt.rs:52:13\r\n     = note: inside call to closure at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/panicking.rs:305:40\r\n     = note: inside call to `std::panicking::r#try::do_call::<[closure@DefId(1:6018 ~ std[8be3]::rt[0]::lang_start_internal[0]::{{closure}}[0]) 0:&&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe], i32>` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/panicking.rs:281:13\r\n     = note: inside call to `std::panicking::r#try::<i32, [closure@DefId(1:6018 ~ std[8be3]::rt[0]::lang_start_internal[0]::{{closure}}[0]) 0:&&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe]>` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/panic.rs:394:14\r\n     = note: inside call to `std::panic::catch_unwind::<[closure@DefId(1:6018 ~ std[8be3]::rt[0]::lang_start_internal[0]::{{closure}}[0]) 0:&&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe], i32>` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/rt.rs:51:25\r\n     = note: inside call to `std::rt::lang_start_internal` at /playground/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src/libstd/rt.rs:67:5\r\n     = note: inside call to `std::rt::lang_start::<()>`\r\n     = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\r\n\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n\r\n```", "labels": ["A-miri", "C-bug", "T-libs"], "number_of_comments": 3, "created_at": "2020-01-26 00:53:03", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555131544": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68543, "title": "Unsized locals and async ICE", "body": "The following ICE's:\r\n```Rust\r\n#![feature(unsized_locals)]\r\n\r\nuse std::future::Future;\r\n\r\nasync fn bug<T>(mut f: dyn Future<Output = T> + Unpin) -> T {\r\n    (&mut f).await\r\n}\r\n```\r\n\r\n\r\n<details>\r\n<summary>Backtrace:</summary>\r\n\r\n```\r\n  Compiling playground v0.0.1 (/playground)\r\nwarning: function is never used: `bug`\r\n --> src/lib.rs:5:10\r\n  |\r\n5 | async fn bug<T>(mut f: dyn Future<Output = T> + Unpin) -> T {\r\n  |          ^^^\r\n  |\r\n  = note: `#[warn(dead_code)]` on by default\r\n\r\nthread 'rustc' panicked at 'assertion failed: !field.is_unsized()', src/librustc/ty/layout.rs:719:25\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  12: std::panicking::begin_panic\r\n  13: rustc::ty::layout::LayoutCx<rustc::ty::context::TyCtxt>::layout_raw_uncached\r\n  14: rustc::ty::layout::layout_raw\r\n  15: rustc::ty::query::__query_compute::layout_raw\r\n  16: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::layout_raw>::compute\r\n  17: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  18: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  19: <rustc::ty::layout::LayoutCx<rustc::ty::context::TyCtxt> as rustc_target::abi::LayoutOf>::layout_of\r\n  20: <core::iter::adapters::Map<I,F> as core::iter::traits::iterator::Iterator>::try_fold\r\n  21: <core::iter::adapters::chain::Chain<A,B> as core::iter::traits::iterator::Iterator>::try_fold\r\n  22: <alloc::vec::Vec<T> as alloc::vec::SpecExtend<T,I>>::from_iter\r\n  23: rustc::ty::layout::LayoutCx<rustc::ty::context::TyCtxt>::layout_raw_uncached\r\n  24: rustc::ty::layout::layout_raw\r\n  25: rustc::ty::query::__query_compute::layout_raw\r\n  26: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::layout_raw>::compute\r\n  27: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  28: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  29: <rustc::ty::layout::LayoutCx<rustc::ty::context::TyCtxt> as rustc_target::abi::LayoutOf>::layout_of\r\n  30: <core::iter::adapters::ResultShunt<I,E> as core::iter::traits::iterator::Iterator>::next\r\n  31: <alloc::vec::Vec<T> as alloc::vec::SpecExtend<T,I>>::from_iter\r\n  32: <core::iter::adapters::ResultShunt<I,E> as core::iter::traits::iterator::Iterator>::next\r\n  33: <alloc::vec::Vec<T> as alloc::vec::SpecExtend<T,I>>::from_iter\r\n  34: core::iter::adapters::process_results\r\n  35: rustc::ty::layout::LayoutCx<rustc::ty::context::TyCtxt>::layout_raw_uncached\r\n  36: rustc::ty::layout::layout_raw\r\n  37: rustc::ty::query::__query_compute::layout_raw\r\n  38: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::layout_raw>::compute\r\n  39: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  40: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  41: <rustc::ty::layout::LayoutCx<rustc::ty::query::TyCtxtAt> as rustc_target::abi::LayoutOf>::layout_of\r\n  42: <rustc_mir::transform::const_prop::ConstProp as rustc_mir::transform::MirPass>::run_pass\r\n  43: rustc_mir::transform::run_passes\r\n  44: rustc_mir::transform::run_optimization_passes\r\n  45: rustc_mir::transform::optimized_mir\r\n  46: rustc::ty::query::__query_compute::optimized_mir\r\n  47: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::optimized_mir>::compute\r\n  48: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  49: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  50: rustc_metadata::rmeta::encoder::EncodeContext::encode_optimized_mir\r\n  51: <rustc_metadata::rmeta::encoder::EncodeContext as rustc_hir::intravisit::Visitor>::visit_item\r\n  52: rustc_hir::hir::Crate::visit_all_item_likes\r\n  53: rustc_metadata::rmeta::encoder::EncodeContext::encode_crate_root\r\n  54: rustc::ty::context::tls::with_context::{{closure}}\r\n  55: rustc_metadata::rmeta::encoder::encode_metadata\r\n  56: rustc_metadata::rmeta::decoder::cstore_impl::<impl rustc::middle::cstore::CrateStore for rustc_metadata::creader::CStore>::encode_metadata\r\n  57: rustc::ty::context::TyCtxt::encode_metadata\r\n  58: rustc_interface::passes::QueryContext::enter\r\n  59: rustc_interface::queries::Queries::ongoing_codegen\r\n  60: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  61: scoped_tls::ScopedKey<T>::set\r\n  62: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (c2d141df5 2020-01-24) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C opt-level=3 -C codegen-units=1 --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [layout_raw] computing layout of `std::mem::MaybeUninit<dyn std::future::Future<Output = T> + std::marker::Unpin>`\r\n#1 [layout_raw] computing layout of `[static generator@src/lib.rs:5:61: 7:2 __arg0:dyn std::future::Future<Output = T> + std::marker::Unpin for<'r, 's, 't0, 't1, 't2, 't3, 't4> {(dyn std::future::Future<Output = T> + std::marker::Unpin + 'r), (dyn std::future::Future<Output = T> + std::marker::Unpin + 's), (dyn std::future::Future<Output = T> + std::marker::Unpin + 't0), &'t1 mut (dyn std::future::Future<Output = T> + std::marker::Unpin + 't2), &'t3 mut (dyn std::future::Future<Output = T> + std::marker::Unpin + 't4), (), ()}]`\r\n#2 [layout_raw] computing layout of `std::future::GenFuture<[static generator@src/lib.rs:5:61: 7:2 __arg0:dyn std::future::Future<Output = T> + std::marker::Unpin for<'r, 's, 't0, 't1, 't2, 't3, 't4> {(dyn std::future::Future<Output = T> + std::marker::Unpin + 'r), (dyn std::future::Future<Output = T> + std::marker::Unpin + 's), (dyn std::future::Future<Output = T> + std::marker::Unpin + 't0), &'t1 mut (dyn std::future::Future<Output = T> + std::marker::Unpin + 't2), &'t3 mut (dyn std::future::Future<Output = T> + std::marker::Unpin + 't4), (), ()}]>`\r\n#3 [optimized_mir] processing `bug`\r\nend of query stack\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\n</details>\r\n", "labels": ["A-async-await", "AsyncAwait-Triaged", "C-bug", "F-unsized_locals", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 1, "created_at": "2020-01-25 20:04:54", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555096400": {"author_username": "bjorn3", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68538, "title": "internal compiler error: src/librustc_mir/interpret/place.rs:41: expected wide pointer extra data (e.g. slice length or trait object vtable)", "body": "```rust\r\n#![feature(unsized_locals)]\r\n\r\npub fn take_unsized_slice(s: [u8]) {\r\n    s[0];\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=38a3b6d927e68a89166dac80d4bdd941))\r\n\r\nErrors:\r\n\r\n```\r\nerror: internal compiler error: src/librustc_mir/interpret/place.rs:41: expected wide pointer extra data (e.g. slice length or trait object vtable)\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:882:9\r\nstack backtrace:\r\n   0: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n   1: core::fmt::write\r\n   2: std::io::Write::write_fmt\r\n   3: std::panicking::default_hook::{{closure}}\r\n   4: std::panicking::default_hook\r\n   5: rustc_driver::report_ice\r\n   6: std::panicking::rust_panic_with_hook\r\n   7: std::panicking::begin_panic\r\n   8: rustc_errors::HandlerInner::bug\r\n   9: rustc_errors::Handler::bug\r\n  10: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  11: rustc::ty::context::tls::with_opt::{{closure}}\r\n  12: rustc::ty::context::tls::with_opt\r\n  13: rustc::util::bug::opt_span_bug_fmt\r\n  14: rustc::util::bug::bug_fmt\r\n  15: rustc_mir::interpret::eval_context::InterpCx<M>::size_and_align_of\r\n  16: rustc_mir::interpret::place::<impl rustc_mir::interpret::eval_context::InterpCx<M>>::force_allocation_maybe_sized\r\n  17: rustc_mir::interpret::step::<impl rustc_mir::interpret::eval_context::InterpCx<M>>::eval_rvalue_into_place\r\n  18: <rustc_mir::transform::const_prop::ConstPropagator as rustc::mir::visit::MutVisitor>::visit_statement\r\n  19: <rustc_mir::transform::const_prop::ConstProp as rustc_mir::transform::MirPass>::run_pass\r\n  20: rustc_mir::transform::run_passes\r\n  21: rustc_mir::transform::run_optimization_passes\r\n  22: rustc_mir::transform::optimized_mir\r\n  23: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::optimized_mir>::compute\r\n  24: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  25: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  26: rustc::ty::<impl rustc::ty::context::TyCtxt>::instance_mir\r\n  27: rustc_mir::monomorphize::collector::collect_items_rec\r\n  28: rustc_mir::monomorphize::collector::collect_items_rec\r\n  29: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  30: rustc_mir::monomorphize::collector::collect_crate_mono_items\r\n  31: rustc_mir::monomorphize::partitioning::collect_and_partition_mono_items\r\n  32: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::collect_and_partition_mono_items>::compute::{{closure}}\r\n  33: rustc::ty::query::__query_compute::collect_and_partition_mono_items\r\n  34: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::collect_and_partition_mono_items>::compute\r\n  35: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  36: rustc::dep_graph::graph::DepGraph::with_eval_always_task\r\n  37: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job::{{closure}}::{{closure}}\r\n  38: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query::{{closure}}::{{closure}}\r\n  39: rustc::ty::context::tls::enter_context::{{closure}}\r\n  40: rustc::ty::context::tls::set_tlv\r\n  41: rustc::ty::context::tls::enter_context\r\n  42: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::start_query::{{closure}}\r\n  43: rustc::ty::context::tls::with_related_context::{{closure}}\r\n  44: rustc::ty::context::tls::with_context::{{closure}}\r\n  45: rustc::ty::context::tls::with_context_opt\r\n  46: rustc::ty::context::tls::with_context\r\n  47: rustc::ty::context::tls::with_related_context\r\n  48: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::force_query_with_job::{{closure}}\r\n  49: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  50: rustc_codegen_cranelift::driver::codegen_cgus\r\n  51: rustc_codegen_cranelift::driver::run_aot\r\n  52: rustc_codegen_cranelift::driver::codegen_crate\r\n  53: <rustc_codegen_cranelift::CraneliftCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  54: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  55: rustc_interface::passes::QueryContext::enter\r\n  56: rustc_interface::queries::Queries::ongoing_codegen\r\n  57: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  58: scoped_tls::ScopedKey<T>::set\r\n  59: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (c2d141df5 2020-01-24) running on x86_64-apple-darwin\r\n```\r\n\r\n@rustbot modify labels: +A-mir +C-bug +requires-nightly", "labels": ["A-mir", "C-bug", "F-unsized_locals", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-25 15:13:34", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555092537": {"author_username": "Mark-Simulacrum", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68537, "title": "Tracking issue Iterator map_while", "body": "Added in https://github.com/rust-lang/rust/pull/66577.\r\n\r\nOpen questions: \r\n * Implement DoubleEndedIterator, FusedIterator\r\n * Debug output\r\n\r\n", "labels": ["A-iterators", "B-unstable", "C-tracking-issue", "T-libs"], "number_of_comments": 1, "created_at": "2020-01-25 14:37:43", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555067203": {"author_username": "JohnTitor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68536, "title": "`nth_back()` for `Zip` returns wrong values", "body": "Assertions are successful in this code ([playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=ecd909fd9a7fb53290298f2045a07bfd)):\r\n\r\n```rust\r\nlet mut a = Vec::new();\r\nlet mut b = Vec::new();\r\nlet value = [1, 2, 3, 4, 5, 6]\r\n    .iter()\r\n    .cloned()\r\n    .map(|n| {\r\n        a.push(n);\r\n        n * 10\r\n    })\r\n    .zip([2, 3, 4, 5, 6, 7, 8].iter().cloned().map(|n| {\r\n        b.push(n * 100);\r\n        n * 1000\r\n    }))\r\n    .nth_back(3);\r\nassert_eq!(value, Some((30, 4000)));\r\nassert_eq!(a, vec![6, 6, 5, 5, 4, 4, 3]);\r\nassert_eq!(b, vec![800, 700, 700, 600, 600, 500, 500, 400]);\r\n```\r\n\r\nBut later assertions are actually wrong (the second and third ones shouldn't double-count).\r\n@matthewjasper pointed out it's a bug that exists in the current `next_back` implementation.", "labels": ["A-iterators", "C-bug", "I-nominated", "T-libs"], "number_of_comments": 3, "created_at": "2020-01-25 10:05:43", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555046343": {"author_username": "95th", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68532, "title": "ICE: cannot convert `ReEarlyBound(0, 'a)` to a region vid", "body": "I got an internal compiler error at commit https://github.com/95th/btrs/commit/f2eb5338fa5c865bdde110dfa21fba7d06f8de7e . I dont know how to minimize it.\r\n\r\nRelevant code is:\r\n\r\n```rust\r\nimpl<'a> Handshake<'a> {\r\n    const LEN: usize = 68;\r\n\r\n    pub fn new(info_hash: &'a InfoHash, peer_id: &'a str) -> Self {\r\n        Self {\r\n            peer_id,\r\n            info_hash,\r\n            extensions: Default::default(),\r\n        }\r\n    }\r\n\r\n    pub async fn send(&self, peer: &Peer) -> crate::Result<()> {\r\n        let mut tcp = TcpStream::connect(peer.addr()).await?;\r\n        self.write_bytes(&mut tcp).await?;\r\n\r\n        let mut v = [0; Self::LEN];\r\n        tcp.read_exact(&mut v).await?;\r\n\r\n        println!(\"{:?}\", v);\r\n        Ok(())\r\n    }\r\n  ...\r\n```\r\n\r\nIf I remove the const field and directly put the array size like below, the ICE goes away and I get the expected compilation error that [u8; 68] is not `Debug`.\r\n\r\n```rust\r\n       let mut v = [0; 68];\r\n       ...\r\n```\r\n<details>\r\n<summary>Backtrace:</summary>\r\n\r\n```\r\n~/btrs$ RUST_BACKTRACE=1 cargo check\r\n    Checking btrs v0.1.0 (/home/95th/btrs)\r\nerror: internal compiler error: src/librustc_mir/borrow_check/nll/universal_regions.rs:764: cannot convert `ReEarlyBound(0, 'a)` to a region vid\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:931:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:61\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1028\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1412\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:65\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:50\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:188\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:205\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:468\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_context_opt\r\n  18: rustc::ty::context::tls::with_opt\r\n  19: rustc::util::bug::opt_span_bug_fmt\r\n  20: rustc::util::bug::bug_fmt\r\n  21: rustc_mir::borrow_check::nll::universal_regions::UniversalRegionIndices::to_region_vid::{{closure}}\r\n  22: rustc_mir::borrow_check::nll::universal_regions::UniversalRegionIndices::to_region_vid\r\n  23: rustc_mir::borrow_check::nll::type_check::constraint_conversion::ConstraintConversion::convert_all\r\n  24: rustc_mir::borrow_check::nll::type_check::TypeChecker::fully_perform_op\r\n  25: rustc_mir::borrow_check::nll::type_check::type_check\r\n  26: rustc_mir::borrow_check::nll::compute_regions\r\n  27: rustc_mir::borrow_check::do_mir_borrowck\r\n  28: rustc::ty::context::GlobalCtxt::enter_local\r\n  29: rustc_mir::borrow_check::mir_borrowck\r\n  30: rustc::ty::query::__query_compute::mir_borrowck\r\n  31: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::mir_borrowck>::compute\r\n  32: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  33: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  34: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::ensure_query\r\n  35: rustc_mir::transform::optimized_mir\r\n  36: rustc::ty::query::__query_compute::optimized_mir\r\n  37: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::optimized_mir>::compute\r\n  38: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  39: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  40: rustc_mir::interpret::eval_context::InterpCx<M>::load_mir\r\n  41: rustc_mir::const_eval::const_eval_raw_provider\r\n  42: rustc::ty::query::__query_compute::const_eval_raw\r\n  43: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::const_eval_raw>::compute\r\n  44: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  45: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  46: rustc_mir::const_eval::const_eval_provider\r\n  47: rustc::ty::query::__query_compute::const_eval\r\n  48: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::const_eval>::compute\r\n  49: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  50: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  51: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  52: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  53: rustc_typeck::check::FnCtxt::check_decl_initializer\r\n  54: rustc_typeck::check::FnCtxt::check_decl_local\r\n  55: rustc_typeck::check::FnCtxt::check_stmt\r\n  56: rustc_typeck::check::FnCtxt::check_block_with_expected\r\n  57: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  58: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  59: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  60: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  61: rustc_typeck::check::FnCtxt::check_block_with_expected\r\n  62: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  63: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  64: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_return_expr\r\n  65: rustc_typeck::check::check_fn\r\n  66: rustc_typeck::check::closure::<impl rustc_typeck::check::FnCtxt>::check_expr_closure\r\n  67: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  68: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  69: rustc_typeck::check::FnCtxt::check_argument_types\r\n  70: rustc_typeck::check::callee::<impl rustc_typeck::check::FnCtxt>::confirm_builtin_call\r\n  71: rustc_typeck::check::callee::<impl rustc_typeck::check::FnCtxt>::check_call\r\n  72: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  73: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  74: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_return_expr\r\n  75: rustc_typeck::check::check_fn\r\n  76: rustc::ty::context::tls::with_context::{{closure}}\r\n  77: rustc_typeck::check::typeck_tables_of\r\n  78: rustc::ty::query::__query_compute::typeck_tables_of\r\n  79: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::typeck_tables_of>::compute\r\n  80: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  81: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  82: rustc::ty::query::__query_compute::typeck_tables_of\r\n  83: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::typeck_tables_of>::compute\r\n  84: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  85: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  86: rustc_typeck::collect::checked_type_of\r\n  87: rustc_typeck::collect::type_of\r\n  88: rustc::ty::query::__query_compute::type_of\r\n  89: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::type_of>::compute\r\n  90: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  91: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  92: rustc::hir::intravisit::walk_expr\r\n  93: rustc::hir::intravisit::Visitor::visit_fn\r\n  94: rustc::hir::intravisit::walk_impl_item\r\n  95: rustc::hir::map::Map::visit_item_likes_in_module\r\n  96: rustc_typeck::collect::collect_mod_item_types\r\n  97: rustc::ty::query::__query_compute::collect_mod_item_types\r\n  98: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::collect_mod_item_types>::compute\r\n  99: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n 100: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n 101: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::ensure_query\r\n 102: rustc_typeck::check_crate::{{closure}}::{{closure}}\r\n 103: rustc::util::common::time\r\n 104: rustc_typeck::check_crate\r\n 105: rustc_interface::passes::analysis\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.40.0 (73528e339 2019-12-16) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [mir_borrowck] processing `conn::Handshake::<'a>::send::{{closure}}#0::{{constant}}#0`\r\n#1 [optimized_mir] processing `conn::Handshake::<'a>::send::{{closure}}#0::{{constant}}#0`\r\n#2 [const_eval_raw] const-evaluating `conn::Handshake::<'a>::send::{{closure}}#0::{{constant}}#0`\r\n#3 [const_eval] const-evaluating + checking `conn::Handshake::<'a>::send::{{closure}}#0::{{constant}}#0`\r\n#4 [typeck_tables_of] processing `conn::Handshake::<'a>::send`\r\n#5 [typeck_tables_of] processing `conn::Handshake::<'a>::send::{{closure}}#0`\r\n#6 [type_of] processing `conn::Handshake::<'a>::send::{{closure}}#0`\r\n#7 [collect_mod_item_types] collecting item types in module `conn`\r\n#8 [analysis] running analysis passes on this crate\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `btrs`.\r\n```\r\n</details>\r\n\r\n<details>\r\n<summary>Version info</summary>\r\n\r\n```\r\n~/btrs$ rustc --version --verbose\r\nrustc 1.40.0 (73528e339 2019-12-16)\r\nbinary: rustc\r\ncommit-hash: 73528e339aae0f17a15ffa49a8ac608f50c6cf14\r\ncommit-date: 2019-12-16\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.40.0\r\nLLVM version: 9.0\r\n```\r\n</details>\r\n", "labels": ["A-mir", "C-bug", "I-ICE", "P-high", "T-compiler", "glacier"], "number_of_comments": 3, "created_at": "2020-01-25 05:39:50", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "555014903": {"author_username": "ecstatic-morse", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68528, "title": "Mark other variants as uninitialized after switch on discriminant", "body": "During drop elaboration, which builds the drop ladder that handles destruction during stack unwinding, we attempt to remove MIR `Drop` terminators that will never be reached in practice. This reduces the number of basic blocks that are passed to LLVM, which should improve performance. In #66753, a user pointed out that unreachable `Drop` terminators are common in functions like `Option::unwrap`, which move out of an `enum`. While discussing possible remedies for that issue, @eddyb suggested moving const-checking after drop elaboration. This would allow the former, which looks for `Drop` terminators and replicates a small amount of drop elaboration to determine whether a dropped local has been moved out, leverage the work done by the latter.\r\n\r\nHowever, it turns out that drop elaboration is not as precise as it could be when it comes to eliminating useless drop terminators. For example, let's look at the code for `unwrap_or`.\r\n\r\n```rust\r\nfn unwrap_or<T>(opt: Option<T>, default: T) -> T {\r\n    match opt {\r\n        Some(inner) => inner,\r\n        None => default,\r\n    }\r\n}\r\n```\r\n\r\n`opt` never needs to be dropped, since it is either moved out of (if it is `Some`) or has no drop glue (if it is `None`), and `default` only needs to be dropped if `opt` is `Some`. This is not reflected in the MIR we currently pass to codegen.\r\n\r\n![pasted_image](https://user-images.githubusercontent.com/29463364/73384403-109a0d80-4280-11ea-8500-0637b368f2dc.png)\r\n\r\n@eddyb also suggested the solution to this problem. When we switch on an enum discriminant, we should be marking all fields in other variants as definitely uninitialized. I implemented this on top of alongside a small optimization (split out into #68943) that suppresses drop terminators for enum variants with no fields (e.g. `Option::None`). This is the resulting MIR for `unwrap_or`.\r\n\r\n![after](https://user-images.githubusercontent.com/29463364/73384823-e432c100-4280-11ea-84bd-d0bcc3b777b4.png)\r\n\r\nIn concert with #68943, this change speeds up many [optimized and debug builds](https://perf.rust-lang.org/compare.html?start=d55f3e9f1da631c636b54a7c22c1caccbe4bf0db&end=0077a7aa11ebc2462851676f9f464d5221b17d6a). We need to carefully investigate whether I have introduced any miscompilations before merging this. Code that never drops anything would be very fast indeed until memory is exhausted.\r\n", "labels": ["S-waiting-on-review"], "number_of_comments": 23, "created_at": "2020-01-25 00:28:52", "reactions": {"total_count": 4, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 4}}, "555006502": {"author_username": "Fihtangolz", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68527, "title": "Add note for to clarify trait restriction for function if we get (in my example \"borrow as mutable\" error)", "body": "Code example\r\nhttps://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=63c770ffce3c7420dd845653f7250b9f\r\nWe can try brute force all implementation, dropping trait restriction:\r\nfor generic type \r\nfor concrete type\r\nIf we find some implementation which allow you to get rid of this error (or maybe from all errors). \r\nWe can provide note with candidates and fix for restriction  \r\n \r\n", "labels": [], "number_of_comments": 1, "created_at": "2020-01-24 23:48:58", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "554967660": {"author_username": "Nokel81", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68523, "title": "Bad error message with async main", "body": "If someone tries to do the following `async fn main() -> Result<(), Box<dyn std::error::Error>` the error message is not helpful (though it is technically correct).\r\n\r\n```rust\r\nerror[E0277]: `main` has invalid return type `impl futures::Future`\r\n  --> rs/agent-updater/src/main.rs:46:20\r\n   |\r\n46 | async fn main() -> Result<(), Box<dyn std::error::Error>> {\r\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `main` can only return types that implement `std::process::Termination`\r\n   |\r\n   = help: consider using `()`, or a `Result`\r\n```\r\n\r\nI think that it should point to the `async` keyword and say that standard rust does not support `async` main.\n\n<!-- TRIAGEBOT_START -->\n\n<!-- TRIAGEBOT_ASSIGN_START -->\nThis issue has been assigned to @Nokel81 via [this comment](https://github.com/rust-lang/rust/issues/68523#issuecomment-580037030).\n<!-- TRIAGEBOT_ASSIGN_DATA_START$${\"user\":\"Nokel81\"}$$TRIAGEBOT_ASSIGN_DATA_END -->\n\n<!-- TRIAGEBOT_ASSIGN_END -->\n<!-- TRIAGEBOT_END -->", "labels": ["A-async-await", "A-diagnostics", "A-suggestion-diagnostics", "AsyncAwait-OnDeck", "AsyncAwait-Triaged", "C-enhancement", "D-confusing", "D-papercut", "T-compiler"], "number_of_comments": 11, "created_at": "2020-01-24 21:41:45", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "554910558": {"author_username": "shepmaster", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68521, "title": "\"expected bound lifetime parameter, found concrete lifetime\" when passing a 'static reference to a closure that returns a future", "body": "```rust\r\nuse std::future::Future;\r\n\r\nfn main() {\r\n    let _ = wrapper(hello);\r\n}\r\n\r\nstatic GLOBAL: i32 = 42;\r\n\r\nasync fn wrapper<F, FutResp>(f: F)\r\nwhere\r\n    F: Fn(&i32) -> FutResp,\r\n    FutResp: Future<Output = ()>,\r\n{\r\n    f(&GLOBAL).await\r\n}\r\n\r\nasync fn hello(_: &i32) {\r\n    println!(\"Hello\");\r\n}\r\n```\r\n\r\n([Playground](https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=27552741e074086dcc84a6734fe862cc))\r\n\r\nErrors:\r\n\r\n```\r\nerror[E0271]: type mismatch resolving `for<'r> <for<'_> fn(&i32) -> impl std::future::Future {hello} as std::ops::FnOnce<(&'r i32,)>>::Output == _`\r\n  --> src/main.rs:4:13\r\n   |\r\n4  |     let _ = wrapper(hello);\r\n   |             ^^^^^^^ expected bound lifetime parameter, found concrete lifetime\r\n...\r\n9  | async fn wrapper<F, FutResp>(f: F)\r\n   |          -------\r\n10 | where\r\n11 |     F: Fn(&i32) -> FutResp,\r\n   |                    ------- required by this bound in `wrapper`\r\n```\r\n\r\nI can make the code work by restricting the closure to only accept `'static` references:\r\n\r\n```rust\r\nasync fn wrapper<F, FutResp>(f: F)\r\nwhere\r\n    F: Fn(&'static i32) -> FutResp,\r\n    //     ^^^^^^^\r\n    FutResp: Future<Output = ()>,\r\n```\r\n\r\nI did try to add `'static` bounds to the response future (and the closure, for good measure), but this did not help:\r\n\r\n```rust\r\nasync fn wrapper<F, FutResp>(f: F)\r\nwhere\r\n    F: Fn(&i32) -> FutResp + 'static,\r\n    FutResp: Future<Output = ()> + 'static,\r\n```\r\n\r\nThe equivalent(?) synchronous code works as I'd expect:\r\n\r\n```rust\r\nfn main() {\r\n    let _ = wrapper(hello);\r\n}\r\n\r\nstatic GLOBAL: i32 = 42;\r\n\r\nfn wrapper<F>(f: F)\r\nwhere\r\n    F: Fn(&i32) -> (),\r\n{\r\n    f(&GLOBAL)\r\n}\r\n\r\nfn hello(_: &i32) {\r\n    println!(\"Hello\");\r\n}\r\n```\r\n", "labels": ["A-async-await", "A-closures", "A-diagnostics", "A-lifetimes", "AsyncAwait-OnDeck", "AsyncAwait-Triaged", "C-bug", "T-compiler"], "number_of_comments": 1, "created_at": "2020-01-24 19:23:14", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "554898989": {"author_username": "jonas-schievink", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68520, "title": "Closure capturing itself results in unclear \"mismatched types\" error", "body": "Code:\r\n\r\n```rust\r\nfn main() {\r\n    let mut r = None;\r\n    \r\n    let c = move || {\r\n        let _r = r;\r\n    };\r\n    \r\n    r = Some(c);\r\n}\r\n```\r\n\r\nResults in this error:\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n --> src/main.rs:4:13\r\n  |\r\n4 |       let c = move || {\r\n  |  _____________^\r\n5 | |         let _r = r;\r\n6 | |     };\r\n  | |_____^ cyclic type of infinite size\r\n```\r\n\r\nThis seems a bit unclear to me. What types don't match here?\r\n\r\nThere is special code in the compiler that is supposed to give a better error message, but for some reason it's not happening in this case:\r\n\r\nhttps://github.com/rust-lang/rust/blob/73f76b74efcaf21bd5424d87c66cd6ed7fe5c7de/src/librustc/infer/error_reporting/mod.rs#L2003-L2006", "labels": ["A-closures", "A-diagnostics", "C-bug", "T-compiler"], "number_of_comments": 1, "created_at": "2020-01-24 18:56:05", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 1, "heart": 0, "hooray": 0}}, "554644769": {"author_username": "gakonst", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68508, "title": "Exponential Type Blowup when wrapping function", "body": "I am implementing a service architecture, where each service can be thought of as middleware. It makes sense to define complex services which need to manage their own complex state as their own structs and implement my `Service` trait for each one. However, for simple operations, e.g. logging or manipulating some argument in place, it makes more sense to have a wrapper service which receives the previous service's \"request\", does whatever it needs to do, and passes it on. The wrapper service also implements the `Service` trait. \r\n\r\nThe problem here is that there is an exponential type length complexity blowup when passing in the function. \r\n\r\nProbably related: https://github.com/rust-lang/rust/issues/54540, note how there's no closure in my example\r\n\r\nMVCE below: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=17d88bb1e552b2cc285ced44777e726b\r\n\r\n(complex services: BaseService / MyService, stateless services: logger, doubler)\r\n\r\n```rust\r\n// The objective is to be able to wrap existing services with simple functions, without\r\n// having to define a new service each time we want to perform a very minimal action\r\n// on the data flow. We could define a LoggerService and a DoublingService, but that\r\n// is _a lot_ of boilerplate.\r\nfn main() {\r\n    let s = BaseService;\r\n    // We can create as many new services as we want,\r\n    // the type length increases linearly, as expected\r\n    let s = MyService::new(s);\r\n    let s = MyService::new(s);\r\n    // The type length of `s` doubles\r\n    let s = WrappedService::new(s, stateless_log);\r\n    // if you try to wrap a few times, your code hits the type length limit\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double);\r\n    let s = WrappedService::new(s, stateless_double)\r\n}\r\n\r\ntype Request = u64;\r\ntype MyResult = Result<(), ()>;\r\n\r\npub trait Service {\r\n    fn handle(&mut self, request: Request) -> MyResult;\r\n}\r\n\r\n// A simple service which we we use as our base\r\n#[derive(Clone)]\r\npub struct BaseService;\r\nimpl Service for BaseService {\r\n    fn handle(&mut self, _request: Request) -> MyResult {\r\n        Ok(())\r\n    }\r\n}\r\n\r\n// A service that takes another service (and could have more state)\r\n#[derive(Clone)]\r\npub struct MyService<O> {\r\n    next: O,\r\n}\r\nimpl<O> MyService<O>\r\nwhere\r\n    O: Service + Clone + Send,\r\n{\r\n    pub fn new(next: O) -> Self {\r\n        MyService { next }\r\n    }\r\n}\r\nimpl<O> Service for MyService<O>\r\nwhere\r\n    O: Service + Clone + Send,\r\n{\r\n    fn handle(&mut self, request: Request) -> MyResult {\r\n        self.next.handle(request)\r\n    }\r\n}\r\n\r\n/// =========== Stateless Services =========\r\n\r\nuse std::sync::Arc;\r\n\r\n// We have to store the service onion so far, and the function we want to inject\r\n#[derive(Clone)]\r\npub struct WrappedService<F, I> {\r\n    f: F,\r\n    inner: Arc<I>,\r\n}\r\nimpl<F, S> WrappedService<F, S>\r\nwhere\r\n    F: Fn(S, Request) -> MyResult,\r\n    S: Service + Clone,\r\n{\r\n    pub fn new(inner: S, f: F) -> Self {\r\n        WrappedService {\r\n            f,\r\n            inner: Arc::new(inner),\r\n        }\r\n    }\r\n}\r\nimpl<F, S> Service for WrappedService<F, S>\r\nwhere\r\n    F: Fn(S, Request) -> MyResult,\r\n    S: Service + Clone,\r\n{\r\n    fn handle(&mut self, request: Request) -> MyResult {\r\n        (self.f)((*self.inner).clone(), request)\r\n    }\r\n}\r\n\r\n// Is there a way to convert these to a service, without having to go through a lot of boilerplate?\r\npub fn stateless_log<O: Service + Clone>(mut next: O, request: Request) -> MyResult {\r\n    println!(\"sending request\");\r\n    let result = next.handle(request);\r\n    println!(\"got result\");\r\n    result\r\n}\r\n\r\npub fn stateless_double<O: Service + Clone>(mut next: O, request: Request) -> MyResult {\r\n    let request = 2 * request;\r\n    let result = next.handle(request);\r\n    result\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=17d88bb1e552b2cc285ced44777e726b))", "labels": ["I-compiletime", "T-compiler"], "number_of_comments": 2, "created_at": "2020-01-24 10:05:41", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "554613889": {"author_username": "sinkuu", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68507, "title": "Confusing \"type annotations needed\" for errorneous struct field type", "body": "```rust\r\nstruct Foo {\r\n    x: Option<NotInScope>,\r\n}\r\n\r\nfn main() {\r\n    let f = Foo {\r\n        x: None,\r\n    };\r\n}\r\n```\r\n\r\n```\r\nerror[E0412]: cannot find type `NotInScope` in this scope\r\n --> src/main.rs:2:15\r\n  |\r\n2 |     x: Option<NotInScope>,\r\n  |               ^^^^^^^^^^ not found in this scope\r\n\r\nerror[E0282]: type annotations needed\r\n --> src/main.rs:7:12\r\n  |\r\n7 |         x: None,\r\n  |            ^^^^ cannot infer type for `T`\r\n\r\nerror: aborting due to 2 previous errors\r\n```\r\n\r\nThis \"type annotations needed\" error is confusing, especially if the two error messages are apart.", "labels": ["A-diagnostics", "A-inference", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-24 08:56:18", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "554579928": {"author_username": "skinny121", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68505, "title": "Canonicalize inputs to const eval where needed", "body": "Canonicalize inputs to const eval, so that they can contain inference variables. Which enables invoking const eval queries even if the current param env has inference variable within it, which can occur during trait selection.\r\n\r\nThis is a reattempt of #67717, in a far less invasive way.\r\n\r\nFixes #68477\r\n\r\nr? @nikomatsakis \r\ncc @eddyb ", "labels": ["F-const_generics", "S-waiting-on-review"], "number_of_comments": 23, "created_at": "2020-01-24 07:14:53", "reactions": {"total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "heart": 3, "hooray": 0}}, "554506091": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68501, "title": "Minimum lint levels for C-future-compatibility issues: take two", "body": "This is a revival of https://github.com/rust-lang/rust/pull/59658.\r\n\r\nFor now, I've just rebased against `master`, and tweaked the output (e.g. added in backticks) to remove unnecessary churn.\r\n\r\nIt doesn't look like the discussion in https://github.com/rust-lang/rust/pull/59658 arrived at a consensus as to what the exact behavior of this should be. The main options seem to be:\r\n\r\n1. For all crates (ignoring `cap-lint`): do not suppress any warning messages, and additional emit a warning whenever `#[allow]` is applied to the future-compat lint. This is the most verbose option, and seems quite spammy.\r\n2. For all crates (ignoring `cap-lint`): emit a single message per lint type, possibly pointing to the span where it occurs.\r\n3. Don't make this change at all.\r\n\r\nI'm interested in getting this infrastructure merged in order to support https://github.com/rust-lang/rust/pull/68350 (never-type fallback lint)., I'd like the never-type fallback lint to be deny-by-default while piercing `cap-lints`.", "labels": ["S-waiting-on-author"], "number_of_comments": 5, "created_at": "2020-01-24 01:55:26", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 1, "hooray": 0}}, "554458804": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68497, "title": "Lint missing Copy impl/derive on fully public types.", "body": "Any public `enum`/`struct` which has only `pub` fields and isn't `#[non_exhaustive]`, can be \"manually copied\", i.e. a new value can always be produced by copying out the data fields (of the active variant, in the `enum` case) and passing the values back to the constructor.\r\n\r\nTherefore, we might want to lint cases in which such a type doesn't implement `Copy`, because the most likely reasons it doesn't are (assuming no `Drop` impl):\r\n* it would be fine but was forgotten\r\n* the fields weren't actually meant to be publicly accessible\r\n  * this could be hinted at by phrasing the lint to express the fact that anyone can copy all the fields out and make a new value out of them\r\n\r\n**EDIT**: @dtolnay (in https://github.com/rust-lang/rust/issues/68497#issuecomment-577955798) also pointed out compile-times as a big reason to *deliberately* skip, or make opt-in, some derives.\r\nA workaround, in the opt-in case, could be, at the crate-level:\r\n```rust\r\n#![cfg_attr(not(feature = \"clone-impls\"), allow(this_lint))]\r\n```\r\n\r\n<hr/>\r\n\r\nA good (and bad, at the same time) example is `std::ops::Range<T>`, which can be copied by simply doing `r.start..r.end` (or `Range { start: r.start, end: r.end }`, like any `struct`).\r\n\r\nIt's a bad example because the current (suboptimal) convention avoids `Copy` on types implementing `Iterator` (and I suppose the lint could take that into account), but if anyone else wrote a similar struct (and it wasn't an iterator), they would probably want it to be `Copy`.\r\n\r\ncc @Manishearth @oli-obk ", "labels": ["A-lint", "C-feature-request", "T-lang"], "number_of_comments": 7, "created_at": "2020-01-23 23:06:57", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "554392242": {"author_username": "Veetaha", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68492, "title": "Export functions for parsing rust numeric literals", "body": "Hi, I am from [rust-analyzer](https://github.com/rust-analyzer/rust-analyzer) project. We would like to use an API for parsing numeric literals of rust source code. E.g. `42`, `0x2a`, `0b101010`, `42_usize`, `42f64` etc.\r\n\r\nFrom my viewpoint, such a utility should be available in `rustc_lexer` crate which we already heavily depend on. It would be helpful if someone could point out where these functions currently reside in `rust` monorepo, I could try to do my best to move them to `rustc_lexer` and submit a PR.", "labels": ["T-compiler"], "number_of_comments": 0, "created_at": "2020-01-23 20:35:21", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "554366899": {"author_username": "LukasKalbertodt", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68490, "title": "Tracking issue for RFC 2700: numeric constants as associated consts", "body": "This is a tracking issue for [the RFC 2700](https://github.com/rust-lang/rfcs/blob/master/text/2700-associated-constants-on-ints.md) (rust-lang/rfcs#2700): \"Deprecate stdlib modules dedicated to numeric constants and move those constants to associated consts\".\r\n\r\n**Steps:**\r\n\r\n- [x] Add new constants (see #68325) \r\n- [ ] Stabilize new constants ([see instructions on rustc-guide][stabilization-guide])\r\n- [ ] Potentially deprecate old items (see unresolved questions below)\r\n- [ ] Adjust documentation ([see instructions on rustc-guide][doc-guide])\r\n\r\n[stabilization-guide]: https://rust-lang.github.io/rustc-guide/stabilization_guide.html#stabilization-pr\r\n[doc-guide]: https://rust-lang.github.io/rustc-guide/stabilization_guide.html#documentation-prs\r\n\r\n**Unresolved questions:**\r\n\r\n- [ ] Should the old items be deprecated? See the RFC thread as well as [\"unresolved questions\"](https://github.com/rust-lang/rfcs/blob/master/text/2700-associated-constants-on-ints.md#unresolved-questions): \r\n  > How long should we go before issuing a deprecation warning? At the extreme end of the scale we could wait until the next edition of Rust is released, and have the legacy items only issue deprecation warnings when opting in to the new edition; this would limit disruption only to people opting in to a new edition (and, being merely an trivially-addressed deprecation, would constitute far less of a disruption than any ordinary edition-related change; any impact of the deprecation would be mere noise in light of the broader edition-related impacts). However long it takes, it is the opinion of the author that deprecation should happen eventually, as we should not give the impression that it is the ideal state of things that there should exist three ways of finding the maximum value of an integer type; we expect experienced users to intuitively reach for the new way proposed in this RFC as the \"natural\" way these constants ought to be implemented, but for the sake of new users it would be a pedagogical wart to allow all three to exist without explicitly calling out the preferred one.", "labels": ["B-RFC-approved", "C-tracking-issue", "T-libs"], "number_of_comments": 3, "created_at": "2020-01-23 19:46:17", "reactions": {"total_count": 4, "+1": 3, "-1": 0, "laugh": 0, "heart": 0, "hooray": 1}}, "554355113": {"author_username": "dtolnay", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68489, "title": "Turbofish triggers loss of spans", "body": "This is a subissue of #43081 but likely fixable without fixing #43081 in full generality.\r\n\r\n#### src/lib.rs\r\n\r\n```rust\r\nextern crate proc_macro;\r\nuse proc_macro::TokenStream;\r\n\r\n#[proc_macro_attribute]\r\npub fn repro(_args: TokenStream, input: TokenStream) -> TokenStream {\r\n    println!(\"{:#?}\", input);\r\n    input.into_iter().collect()\r\n}\r\n```\r\n\r\n#### src/main.rs\r\n\r\n```rust\r\n#[repro::repro]\r\nfn repro() {\r\n    f :: < Vec < _ > > ( ) ;\r\n}\r\nfn main() {}\r\n```\r\n\r\nWhen running `cargo check`, notice that all the spans in the output are `#0 bytes(0..0)` (classic #43081) and therefore all error reporting within the function body is broken; there is no line number on the \"cannot find function \\`f\\` in this scope\" error.\r\n\r\nThe following script reproduces the issue as of rustc 1.42.0-nightly (d1e594f40 2020-01-22):\r\n\r\n```bash\r\n#!/bin/bash\r\n\r\ncargo new repro\r\n\r\necho >>repro/Cargo.toml '\r\n[lib]\r\nproc-macro = true\r\n'\r\n\r\necho >repro/src/lib.rs '\r\nextern crate proc_macro;\r\nuse proc_macro::TokenStream;\r\n\r\n#[proc_macro_attribute]\r\npub fn repro(_args: TokenStream, input: TokenStream) -> TokenStream {\r\n    println!(\"{:#?}\", input);\r\n    TokenStream::new()\r\n}\r\n'\r\n\r\necho >repro/src/main.rs '\r\n#[repro::repro]\r\nfn repro() {\r\n    f :: < Vec < _ > > ( ) ;\r\n}\r\nfn main() {}\r\n'\r\n\r\ncargo +nightly check --manifest-path repro/Cargo.toml\r\n```\r\n\r\ncc @petrochenkov who fixed a previous special case of #43081.", "labels": ["A-diagnostics", "A-macros", "C-bug", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-23 19:22:34", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "554187760": {"author_username": "HeroicKatora", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68488, "title": "Compile error in main code when doc-testing a crate that has the same name as a module", "body": "In a crate that has the same name as a top-level module, exporting a name from this module causes rustdoc (and only rustdoc) to error when it is ran.\r\n\r\n```rust\r\n// Crate name: `this_crate`.\r\nmod this_crate { pub struct Item; }\r\n\r\npub use this_crate::Item;\r\n```\r\n\r\n<details>\r\n<summary>error[E0659]: `this_crate` is ambiguous</summary>\r\n<pre>\r\n> cargo test --doc\r\n    Finished test [unoptimized + debuginfo] target(s) in 0.00s\r\n   Doc-tests this_crate\r\nerror[E0659]: `this_crate` is ambiguous (name vs any other name during import resolution)\r\n --> /tmp/test_dir/no-alloc/src/lib.rs:7:9\r\n  |\r\n7 | pub use this_crate::Item;\r\n  |         ^^^^^^^^^^ ambiguous name\r\n  |\r\n  = note: `this_crate` could refer to a crate passed with `--extern`\r\n  = help: use `::this_crate` to refer to this crate unambiguously\r\nnote: `this_crate` could also refer to the module defined here\r\n --> /tmp/test_dir/no-alloc/src/lib.rs:1:1\r\n  |\r\n1 | mod this_crate { pub struct Item; }\r\n  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  = help: use `crate::this_crate` to refer to this module unambiguously\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0659`.\r\n\r\nrunning 0 tests\r\n\r\ntest result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out\r\n&gt; echo $?\r\n0\r\n</pre>\r\n</details>", "labels": ["A-doctests", "C-bug", "T-rustdoc"], "number_of_comments": 3, "created_at": "2020-01-23 14:21:19", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "554146412": {"author_username": "timvermeulen", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68484, "title": "Severe slowdown when wrapping a [MaybeUninit<T>; N] in a struct", "body": "Consider the following function:\r\n\r\n```rust\r\n#![feature(maybe_uninit_extra)]\r\n\r\nuse std::{mem::MaybeUninit, ops::Range};\r\n\r\nconst N: usize = 10_000;\r\nconst RANGE: Range<u32> = 2500..7500;\r\n\r\nfn foo() -> u32 {\r\n    unsafe {\r\n        let mut array = MaybeUninit::<[MaybeUninit<u32>; N]>::uninit().assume_init();\r\n        let mut len = 0;\r\n\r\n        for value in RANGE {\r\n            array.get_unchecked_mut(len).write(value);\r\n            len += 1;\r\n        }\r\n\r\n        (0..len).map(|i| array.get_unchecked(i).read()).sum()\r\n    }\r\n}\r\n```\r\n\r\nThis runs as fast as I would expect. But if I put `array` and `len` in a struct, like this:\r\n\r\n```rust\r\nstruct S {\r\n    array: [MaybeUninit<u32>; N],\r\n    len: usize,\r\n}\r\n\r\npub fn bar() -> u32 {\r\n    unsafe {\r\n        let mut s = S {\r\n            array: MaybeUninit::uninit().assume_init(),\r\n            len: 0,\r\n        };\r\n\r\n        for value in RANGE {\r\n            s.array.get_unchecked_mut(s.len).write(value);\r\n            s.len += 1;\r\n        }\r\n\r\n        (0..s.len).map(|i| s.array.get_unchecked(i).read()).sum()\r\n    }\r\n}\r\n```\r\n\r\nThis runs about 15x as slowly using (although these didn't change anything)\r\n```\r\n[profile.bench]\r\nlto = true\r\ncodegen-units = 1\r\n```\r\nwith the 2020-01-22 nightly toolchain. This difference can be observed with much smaller values of `N`, too, and blackboxing values didn't make a difference.\r\n\r\n[Playground with benchmarks](https://play.rust-lang.org/?version=nightly&mode=release&edition=2018&gist=ece1d1e8eea46b962166a27325fb60f8)", "labels": ["A-codegen", "I-slow", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-23 13:09:02", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553954609": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68480, "title": "Add sanity checking for query keys", "body": "We frequently see issues where a query parameter ends up containing something that it's not supposed to (an inference variable, a placeholder region, etc): https://github.com/rust-lang/rust/issues/68477 and https://github.com/rust-lang/rust/issues/64964 are recent examples.\r\n\r\nCurrently, incremental compilation must be enabled to see these crashes, since they only occur when we try to hash the 'bad' type. This presents a number of issues:\r\n\r\n1. The playground can't be used to reproduce them, since it (rightly) disables incremental compilation.\r\n2. We may miss these kinds of issues when invoking `rustc` directly (e.g. the `ui` test suite), since `-C incremental=1` is usually not passed.\r\n3. The panic message isn't very helpful - in particular, it doesn't show the original type being hashed.\r\n\r\nI think it would be useful to add a `sanity_check` method to `Key`, which would verify that the value is sane (e.g. no inference variances or placeholder regions) regardless of whether or not incremental compilation is enabled.", "labels": ["C-cleanup", "T-compiler"], "number_of_comments": 1, "created_at": "2020-01-23 05:59:49", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553897648": {"author_username": "shisoft", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68477, "title": "ICE cause by tokio::spawn a async function return future opaque type", "body": "The ICE cause by `cargo check`, seems happened in multiple locations. One of the cause is when calling `tokio::spawn` function. \r\n\r\nI don't know how to reproduce this problem in minimal example,  but the faulty code in my project comes from here\r\nhttps://github.com/ShisoftResearch/bifrost/blob/f67c57209dd15072a2868f46c1d26cd356caafae/src/raft/mod.rs#L631\r\n\r\nExpecting the code to compile or providing reason for the failure. Instead, the compile just crashed.\r\nThis problem appears on both MacOS and Linux\r\n## Meta\r\n\r\nrustc 1.42.0-nightly (5e8897b7b 2020-01-21)\r\nbinary: rustc\r\ncommit-hash: 5e8897b7b51636f157630e6639b711d698e1d101\r\ncommit-date: 2020-01-21\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.42.0-nightly\r\nLLVM version: 9.0\r\n\r\ntokio 0.2.10\r\n\r\nBacktrace:\r\n```\r\nerror: internal compiler error: src/librustc/ich/impls_ty.rs:96: StableHasher: unexpected region RePlaceholder(Placeholder { universe: U596, name: BrAnon(3) })\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:882:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1052\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: <alloc::boxed::Box<F> as core::ops::function::Fn<A>>::call\r\n             at /rustc/5e8897b7b51636f157630e6639b711d698e1d101/src/liballoc/boxed.rs:1029\r\n  12: proc_macro::bridge::client::<impl proc_macro::bridge::Bridge>::enter::{{closure}}::{{closure}}\r\n             at /rustc/5e8897b7b51636f157630e6639b711d698e1d101/src/libproc_macro/bridge/client.rs:305\r\n  13: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  14: std::panicking::begin_panic\r\n  15: rustc_errors::HandlerInner::bug\r\n  16: rustc_errors::Handler::bug\r\n  17: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  18: rustc::ty::context::tls::with_opt::{{closure}}\r\n  19: rustc::ty::context::tls::with_opt\r\n  20: rustc::util::bug::opt_span_bug_fmt\r\n  21: rustc::util::bug::bug_fmt\r\n  22: rustc::ich::impls_ty::<impl rustc_data_structures::stable_hasher::HashStable<rustc::ich::hcx::StableHashingContext> for rustc::ty::sty::RegionKind>::hash_stable\r\n  23: rustc::ty::sty::_DERIVE_rustc_data_structures_stable_hasher_HashStable_rustc_ich_StableHashingContext_ctx_FOR_TyKind::<impl rustc_data_structures::stable_hasher::HashStable<rustc::ich::hcx::StableHashingContext> for rustc::ty::sty::TyKind>::hash_stable\r\n  24: std::thread::local::LocalKey<T>::with\r\n  25: rustc::ty::sty::_DERIVE_rustc_data_structures_stable_hasher_HashStable_rustc_ich_StableHashingContext_ctx_FOR_TyKind::<impl rustc_data_structures::stable_hasher::HashStable<rustc::ich::hcx::StableHashingContext> for rustc::ty::sty::TyKind>::hash_stable\r\n  26: std::thread::local::LocalKey<T>::with\r\n  27: rustc::mir::interpret::_DERIVE_rustc_data_structures_stable_hasher_HashStable_rustc_ich_StableHashingContext_ctx_FOR_GlobalId::<impl rustc_data_structures::stable_hasher::HashStable<rustc::ich::hcx::StableHashingContext> for rustc::mir::interpret::GlobalId>::hash_stable\r\n  28: <T as rustc::dep_graph::dep_node::DepNodeParams>::to_fingerprint\r\n  29: rustc::dep_graph::dep_node::DepNode::new\r\n  30: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  31: rustc::mir::interpret::queries::<impl rustc::ty::context::TyCtxt>::const_eval_instance\r\n  32: rustc::mir::interpret::queries::<impl rustc::ty::context::TyCtxt>::const_eval_resolve\r\n  33: <rustc::traits::project::AssocTypeNormalizer as rustc::ty::fold::TypeFolder>::fold_const\r\n  34: rustc::ty::structural_impls::<impl rustc::ty::fold::TypeFoldable for &rustc::ty::TyS>::super_fold_with\r\n  35: <rustc::traits::project::AssocTypeNormalizer as rustc::ty::fold::TypeFolder>::fold_ty\r\n  36: rustc::traits::project::normalize_with_depth\r\n  37: rustc::infer::InferCtxt::commit_unconditionally\r\n  38: <core::iter::adapters::flatten::FlatMap<I,U,F> as core::iter::traits::iterator::Iterator>::next\r\n  39: <alloc::vec::Vec<T> as alloc::vec::SpecExtend<T,I>>::from_iter\r\n  40: rustc::traits::select::SelectionContext::collect_predicates_for_types\r\n  41: rustc::traits::select::SelectionContext::confirm_candidate\r\n  42: rustc::traits::select::SelectionContext::select\r\n  43: rustc_data_structures::obligation_forest::ObligationForest<O>::process_obligations\r\n  44: <rustc::traits::fulfill::FulfillmentContext as rustc::traits::engine::TraitEngine>::select_where_possible\r\n  45: rustc_typeck::check::FnCtxt::check_argument_types\r\n  46: rustc_typeck::check::callee::<impl rustc_typeck::check::FnCtxt>::confirm_builtin_call\r\n  47: rustc_typeck::check::callee::<impl rustc_typeck::check::FnCtxt>::check_call\r\n  48: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  49: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  50: rustc_typeck::check::FnCtxt::check_decl_initializer\r\n  51: rustc_typeck::check::FnCtxt::check_decl_local\r\n  52: rustc_typeck::check::FnCtxt::check_stmt\r\n  53: rustc_typeck::check::FnCtxt::check_block_with_expected\r\n  54: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  55: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  56: rustc_typeck::check::FnCtxt::check_stmt\r\n  57: rustc_typeck::check::FnCtxt::check_block_with_expected\r\n  58: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  59: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  60: rustc_typeck::check::_match::<impl rustc_typeck::check::FnCtxt>::check_match\r\n  61: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  62: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  63: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  64: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  65: rustc_typeck::check::FnCtxt::check_stmt\r\n  66: rustc_typeck::check::FnCtxt::check_block_with_expected\r\n  67: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  68: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  69: rustc_typeck::check::_match::<impl rustc_typeck::check::FnCtxt>::check_match\r\n  70: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  71: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  72: rustc_typeck::check::FnCtxt::check_block_with_expected\r\n  73: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  74: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  75: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  76: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  77: rustc_typeck::check::FnCtxt::check_block_with_expected\r\n  78: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  79: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  80: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_return_expr\r\n  81: rustc_typeck::check::check_fn\r\n  82: rustc_typeck::check::closure::<impl rustc_typeck::check::FnCtxt>::check_expr_closure\r\n  83: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  84: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  85: rustc_typeck::check::FnCtxt::check_argument_types\r\n  86: rustc_typeck::check::callee::<impl rustc_typeck::check::FnCtxt>::confirm_builtin_call\r\n  87: rustc_typeck::check::callee::<impl rustc_typeck::check::FnCtxt>::check_call\r\n  88: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_kind\r\n  89: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_expr_with_expectation_and_needs\r\n  90: rustc_typeck::check::expr::<impl rustc_typeck::check::FnCtxt>::check_return_expr\r\n  91: rustc_typeck::check::check_fn\r\n  92: rustc::ty::context::tls::with_context::{{closure}}\r\n  93: rustc_typeck::check::typeck_tables_of\r\n  94: rustc::ty::query::__query_compute::typeck_tables_of\r\n  95: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::typeck_tables_of>::compute\r\n  96: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  97: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  98: rustc_typeck::collect::type_of\r\n  99: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::type_of>::compute\r\n 100: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n 101: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n 102: rustc::traits::select::SelectionContext::constituent_types_for_ty\r\n 103: rustc::ty::sty::Binder<T>::map_bound\r\n 104: rustc::traits::select::SelectionContext::confirm_candidate\r\n 105: rustc::infer::InferCtxt::probe\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (5e8897b7b 2020-01-21) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -C debuginfo=2 -C incremental --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [typeck_tables_of] processing `raft::RaftService::send_followers_heartbeat`\r\n#1 [type_of] processing `raft::RaftService::send_followers_heartbeat::{{opaque}}#0`\r\n#2 [evaluate_obligation] evaluating trait selection obligation `for<'r, 's, 't0, 't1, 't2, 't3, 't4, 't5, 't6, 't7, 't8, 't9, 't10, 't11, 't12, 't13, 't14, 't15, 't16, 't17, 't18, 't19, 't20, 't21, 't22, 't23> {std::sync::Arc<raft::RaftService>, i64, i64, raft::RaftService, std::sync::Arc<raft::RaftService>, &'r utils::rwlock::RwLock<raft::RaftMeta>, utils::rwlock::RwLock<raft::RaftMeta>, utils::rwlock::RwLockWriteGuardFut<'s, raft::RaftMeta>, utils::rwlock::RwLockWriteGuardFut<'t0, raft::RaftMeta>, (), (), utils::rwlock::RwLockWriteGuard<'t1, raft::RaftMeta>, raft::CheckerAction, raft::CheckerAction, &'t2 raft::RaftService, std::sync::Arc<raft::RaftService>, utils::rwlock::RwLockWriteGuard<'t3, raft::RaftMeta>, &'t4 mut utils::rwlock::RwLockWriteGuard<'t5, raft::RaftMeta>, &'t6 mut utils::rwlock::RwLockWriteGuard<'t7, raft::RaftMeta>, std::option::Option<u64>, impl core::future::future::Future, impl core::future::future::Future, (), (), &'t14 raft::RaftService, std::sync::Arc<raft::RaftService>, utils::rwlock::RwLockWriteGuard<'t15, raft::RaftMeta>, &'t16 mut utils::rwlock::RwLockWriteGuard<'t17, raft::RaftMeta>, &'t18 mut utils::rwlock::RwLockWriteGuard<'t19, raft::RaftMeta>, impl core::future::future::Future, impl core::future::future::Future, (), (), i64, i64, bool, bool, i64, u64, std::time::Duration, tokio::time::delay::Delay, tokio::time::delay::Delay, (), ()}: std::marker::Send`\r\n#3 [typeck_tables_of] processing `raft::RaftService::start`\r\n#4 [typeck_tables_of] processing `raft::RaftService::start::{{closure}}#0`\r\n#5 [type_of] processing `raft::RaftService::start::{{closure}}#0`\r\n#6 [collect_mod_item_types] collecting item types in module `raft`\r\n#7 [analysis] running analysis passes on this crate\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `bifrost`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```", "labels": ["A-async-await", "A-const-eval", "A-impl-trait", "AsyncAwait-Focus", "AsyncAwait-Triaged", "C-bug", "I-ICE", "P-high", "T-compiler"], "number_of_comments": 3, "created_at": "2020-01-23 02:05:02", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553893007": {"author_username": "shepmaster", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68476, "title": "Diagnostics for mismatched generic types for enum constructors accessed via Self could show where the mismatch occurs", "body": "In this code, I used `Self::VariantName` to construct a new enum. However, since `Self` is treated as `Wrapper<T>`, I get an error when I try to populate `Self::There` / `Wrapper<T>::There` with a value of type `U`:\r\n\r\n```rust\r\nenum Wrapper<T> {\r\n    There(T),\r\n    NotThere,\r\n}\r\n\r\nimpl<T> Wrapper<T> {\r\n    fn map<U>(self, f: impl FnOnce(T) -> U) -> Wrapper<U> {\r\n        match self {\r\n            Self::There(v) => Self::There(f(v)),\r\n            Self::NotThere => Self::NotThere,\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n([Playground](https://play.integer32.com/?version=stable&mode=debug&edition=2018&gist=d2020ec808cbb3a65df21fb04012ac22))\r\n\r\nErrors:\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n --> src/lib.rs:9:43\r\n  |\r\n9 |             Self::There(v) => Self::There(f(v)),\r\n  |                                           ^^^^ expected type parameter, found a different type parameter\r\n  |\r\n  = note: expected type `T`\r\n             found type `U`\r\n  = note: a type parameter was expected, but a different one was found; you might be missing a type parameter or trait bound\r\n  = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\r\n\r\nerror[E0308]: mismatched types\r\n --> src/lib.rs:9:31\r\n  |\r\n7 |     fn map<U>(self, f: impl FnOnce(T) -> U) -> Wrapper<U> {\r\n  |                                                ---------- expected `Wrapper<U>` because of return type\r\n8 |         match self {\r\n9 |             Self::There(v) => Self::There(f(v)),\r\n  |                               ^^^^^^^^^^^^^^^^^ expected type parameter, found a different type parameter\r\n  |\r\n  = note: expected type `Wrapper<U>`\r\n             found type `Wrapper<T>`\r\n  = note: a type parameter was expected, but a different one was found; you might be missing a type parameter or trait bound\r\n  = note: for more information, visit https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters\r\n```\r\n\r\nThis threw me for a fair number of minutes, mostly spent saying \"no, that function `f` takes a `T` and returns a `U`, not the other way around\". \r\n\r\nTechnically, the compiler *is* pointing to the entire call of `f` which should have tipped me off to realizing that it's the constructor call that was an issue.\r\n\r\nInterestingly, the same problem doesn't occur for structs:\r\n\r\n```rust\r\nstruct Wrapper<T>(T);\r\n\r\nimpl<T> Wrapper<T> {\r\n    fn map<U>(self, f: impl FnOnce(T) -> U) -> Wrapper<U> {\r\n        Self(f(self.0))\r\n    }\r\n}\r\n```", "labels": ["A-associated-items", "A-diagnostics", "C-enhancement", "D-confusing", "D-papercut", "T-compiler"], "number_of_comments": 2, "created_at": "2020-01-23 01:45:27", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553826136": {"author_username": "Marwes", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68472, "title": "perf: Let &mut T iterators forward for_each and friends", "body": "Currently `impl Iterator for &mut T` does not forward `for_each` to the\r\ninner `T` which means that it is easy to lose optimized implementations\r\nof these methods. (See #68046)\r\n\r\nBy using specialization on `T: Sized` we can allow calls on non-trait\r\nobjects to still forward to the inner methods.\r\n\r\nThis isn't tested yet and there are more methods that should be\r\nforwarded, just posting this as a POC and to see if it is something that\r\nis wanted.\r\n\r\nEDIT: I believe I were wrong in #68046 and I did not get the slow default implementation. `by_ref` called on a `&mut T` will just yield `&mut T` again, so you more or less have to use  `&mut iter` on a `&mut T` to get the slow implementations which this fixes. Might warrant a clippy lint at least if this looks to heavy handed.", "labels": ["S-waiting-on-author"], "number_of_comments": 11, "created_at": "2020-01-22 22:15:32", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 1, "hooray": 0}}, "553744282": {"author_username": "lovasoa", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68467, "title": "Code generation quality for a recursive function", "body": "After reading [this blog post](https://thomashartmann.dev/blog/feature(slice_patterns)/) recently, I was very happily surprised with the quality of the code generation for the following function : \r\n\r\n```rust\r\nfn middle(xs: &[u32]) -> Option<&u32> {\r\n    match xs {\r\n        [_, inner @ .., _] => middle(inner),\r\n        [x] => Some(x),\r\n        [] => None,\r\n    }\r\n}\r\n```\r\n\r\n```asm\r\nexample::middle:\r\n        cmp     rsi, 2\r\n        jb      .LBB0_2\r\n        add     rsi, -2\r\n        mov     rax, rsi\r\n        and     rax, -2\r\n        lea     rdi, [rdi + 2*rax]\r\n        add     rdi, 4\r\n        and     esi, 1\r\n.LBB0_2:\r\n        xor     eax, eax\r\n        cmp     rsi, 1\r\n        cmove   rax, rdi\r\n        ret\r\n```\r\n\r\nIt is amazing what the compiler is able to achieve !\r\n\r\nBut then, I tried this very slight variation : \r\n\r\n```rust\r\npub fn middle(xs: &[u32]) -> Option<u32> {\r\n    match xs {\r\n        [_, inner @ .., _] => middle(inner),\r\n        [x] => Some(*x),\r\n        [] => None,\r\n    }\r\n}\r\n```\r\n\r\n(the only difference is that we are returning an `u32` instead of an `&u32`)\r\n\r\nAnd the generated code changes dramatically:\r\n\r\n```asm\r\nexample::middle:\r\n        push    rax\r\n        cmp     rsi, 1\r\n        jbe     .LBB0_1\r\n        add     rdi, 4\r\n        add     rsi, -2\r\n        call    qword ptr [rip + example::middle@GOTPCREL]\r\n        pop     rcx\r\n        ret\r\n.LBB0_1:\r\n        cmp     rsi, 1\r\n        jne     .LBB0_2\r\n        mov     edx, dword ptr [rdi]\r\n        mov     eax, 1\r\n        pop     rcx\r\n        ret\r\n.LBB0_2:\r\n        xor     eax, eax\r\n        pop     rcx\r\n        ret\r\n``` \r\n\r\nIs there something making the optimization harder to apply in the second case, or is it a bug somewhere in the compiler ? ", "labels": ["A-codegen", "A-slice-patterns", "I-slow", "T-compiler", "WG-codegen"], "number_of_comments": 3, "created_at": "2020-01-22 19:25:16", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553690135": {"author_username": "tmiasko", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68464, "title": "Lift unnecessary restriction on CAS failure ordering", "body": "Currently `compare_exchange` requires the failure ordering to \"be equivalent to\r\nor weaker than a success ordering\". On the other hand C11/C++11 requires only\r\nthat \"failure shall be no stronger than the success\", which arguably means that\r\none can write e.g. `compare_exchange(..., Release, Acquire)` in C/C++ but not in Rust.\r\n\r\nArguably, because neither C11 standard nor C++11 standard defines what it means\r\nfor an ordering to be stronger from another. When the issue was raised in\r\n[LWG2445], the proposed and accepted resolution was to lift those restrictions\r\naltogether, leaving only requirement that \"the failure argument shall not be\r\n`memory_order_release` nor `memory_order_acq_rel`\". \r\n\r\nIt would be beneficial to remove success/failure ordering restrictions for\r\nreasons described in C++ proposal [P0418r2].\r\n\r\n[LWG2445]: https://cplusplus.github.io/LWG/issue2445\r\n[P0418r2]: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0418r2.html\r\n", "labels": ["A-concurrency", "C-enhancement", "T-lang", "T-libs"], "number_of_comments": 0, "created_at": "2020-01-22 17:34:06", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553606506": {"author_username": "Centril", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68458, "title": "Broken tool going into toolstate week blocks PRs from landing", "body": "Despite Clippy already being broken in toolstate, https://github.com/rust-lang/rust/pull/68432#issuecomment-576955941 failed to land due to Clippy not passing.\r\n\r\nWe had to fix clippy in https://github.com/rust-lang/rust/pull/68442 so that PRs could start landing again.\r\n\r\nIt's unclear whether this is intentional or not.\r\n\r\nRelevant discussion: https://discordapp.com/channels/442252698964721669/443148319431065610/669558059831394346.", "labels": ["T-infra"], "number_of_comments": 0, "created_at": "2020-01-22 15:13:21", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553596630": {"author_username": "jorendorff", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68457, "title": "Error message [E0423] \"expected value, found built-in attribute `start`\" is confusing", "body": "[Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=d80302b4633e9c6b07744fd31e1a2330):\r\n\r\n```rust\r\nfn one_char_range(s: &str, offset: usize) -> &str {\r\n    &s[start..start + 1]\r\n}\r\n```\r\n\r\n```\r\nerror[E0423]: expected value, found built-in attribute `start`\r\n --> src/lib.rs:2:8\r\n  |\r\n2 |     &s[start..start + 1]\r\n  |        ^^^^^ not a value\r\n```\r\n\r\nrustc thinks maybe I mean `#[start]`. But that is silly.\r\n\r\nAnd it was confusing to me as a user. I know there's an attribute `#[start]`, but presented like that without the `#[]` punctuation, I didn't recognize it, even though the message says exactly what it means!\r\n\r\n`rustc --explain E0423` didn't help.\r\n\r\nI think E0423 is confusing here, and rustc should fall back on E0425 (\"cannot find the value `start` in scope\").", "labels": ["A-diagnostics", "A-resolve", "C-enhancement", "D-confusing", "T-compiler"], "number_of_comments": 3, "created_at": "2020-01-22 14:58:49", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553592705": {"author_username": "xfix", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68456, "title": "CString::from_raw should be document that changing the length of a string is UB", "body": "Consider the following code:\r\n\r\n```rust\r\nuse std::ffi::CString;\r\n\r\nfn main() {\r\n    let c = CString::new(&b\"Hello, world\"[..]).unwrap();\r\n    let ptr = c.into_raw();\r\n    unsafe {\r\n        *ptr = 0;\r\n        CString::from_raw(ptr); // UB\r\n    }\r\n}\r\n```\r\n\r\nShortening the string from `CString::into_raw` and then passing it to `CString::from_raw` will cause UB, but this is not documented in safety section of the documentation.", "labels": ["A-ffi", "T-doc", "T-libs"], "number_of_comments": 3, "created_at": "2020-01-22 14:52:37", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553546171": {"author_username": "yoshuawuyts", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68455, "title": "SIMD-enabled utf-8 validation", "body": "## Introduction\r\n\r\nThe [\"Parsing Gigabytes of JSON per second\"](https://branchfree.org/2019/02/25/paper-parsing-gigabytes-of-json-per-second/) post ([ArXiv - langdale, lemire](https://t.co/MgQINMJlNB?amp=1)) proposes a novel approach for parsing JSON that is fast enough that on many systems it moves the bottleneck to the disk and network instead of the parser. This is done through the clever use of SIMD instructions.\r\n\r\nSomething that stood out to me from the post is that JSON is required to be valid utf-8, and they had come up with new algorithms to validate utf-8 using SIMD instructions that function *much* faster than conventional approaches.\r\n\r\nSince rustc does a *lot* of utf-8 validation (each `.rs` source file needs to be valid utf-8), it \r\ngot me curious about what rustc currently does. Validation seems to be done by the following routine:\r\n\r\nhttps://github.com/rust-lang/rust/blob/2f688ac602d50129388bb2a5519942049096cbff/src/libcore/str/mod.rs#L1500-L1618\r\n\r\nThis doesn't appear to use SIMD anywhere, not even conditionally. But it's run a *lot*, so I figured it might be interesting to use a more efficient algorithm for.\r\n\r\n## Performance improvements\r\n\r\nThe post [\"Validating UTF-8 strings using as little as 0.7 cycles per byte\"](https://lemire.me/blog/2018/05/16/validating-utf-8-strings-using-as-little-as-0-7-cycles-per-byte/) shows about an order of magnitude performance improvement on validating utf-8, going from `8` cycles per byte parsed to `0.7` cycles per byte parsed.\r\n\r\nWhen passing Rust's validation code through the godbolt decompiler, `from_utf8_unchecked` outputs 7 instructions, and `from_utf8` outputs 57 instructions. In the case of `from_utf8` most instructions seem to occur inside a loop. Which makes it likely we'll be able to observe a performance improvement by using a SIMD-enabled utf-8 parsing algorithm. Especially since economies of scale would apply here -- it's not uncommon for the compiler to parse several million bytes of input in a run. Any improvements here would quickly add up.\r\n\r\n- [assembly for str::from_utf8_unchecked (godbolt) - 7 lines](https://godbolt.org/z/Y9mwfd)\r\n- [assembly for str::from_utf8 (godbolt) - 57 lines](https://godbolt.org/z/ZJk8mL)\r\n- [assembly for run_utf8_validation routine (godbolt) - 183 lines](https://godbolt.org/z/sQteLm)\r\n\r\n_All examples linked have been compiled with `-O -C target-cpu=native`._\r\n\r\nAlso ecosystem libraries such as `serde_json` perform utf-8 [validation in several locations](https://github.com/serde-rs/json/search?q=utf8&unscoped_q=utf8), so would likely also benefit from performance improvements to Rust's utf-8 validation routines.\r\n\r\n## Implementation\r\n\r\nThere are two known Rust implementations of lemire's algorithm available in Rust today:\r\n\r\n- [simd-lite/simdjson-rs](https://github.com/simd-lite/simdjson-rs)\r\n- [argnidagur/rust-isutf8](https://github.com/ArniDagur/rust-isutf8)\r\n\r\nThe latter even includes benchmarks against the compiler's algorithm (which makes it probable I'm not be the first person to think of this). But I haven't been able to successfully compile the benches, so I don't know how they stack up against the current implementation.\r\n\r\nI'm not overly familiar with rustc's internals. But it seems we would likely want to keep the current algorithm, and through feature detection enable SIMD algorithms. The `simdjson` library has different algorithms for different architectures, but we could probably start with instructions that are widely available and supported on tier-1 targets (such as `AVX2`).\r\n\r\nThese changes wouldn't require an RFC because no APIs would change. The only outcome would be a performance improvement.\r\n\r\n## Future work\r\n\r\n[Lemire's post](https://lemire.me/blog/2018/05/16/validating-utf-8-strings-using-as-little-as-0-7-cycles-per-byte/) also covers parsing ASCII in as little as 0.1 cycles per byte parsed. Rust's current ASCII validation algorithm validates bytes one at the time, and could likely benefit from similar optimizations.\r\n\r\nhttps://github.com/rust-lang/rust/blob/2f688ac602d50129388bb2a5519942049096cbff/src/libcore/str/mod.rs#L4136-L4141\r\n\r\nSpeeding this up would likely have ecosystem implications as well. For example HTTP headers must be valid ASCII, and are often performance sensitive. If the stdlib sped up ASCII validation, it would likely benefit the wider ecosystem as well.\r\n\r\n## Conclusion\r\n\r\nIn this issue I propose to use a SIMD-enabled algorithm for utf-8 validation in rustc. This seems like an interesting avenue to explore since there's a reasonable chance it might yield a performance improvement for many rust programs.\r\n\r\nI'm somewhat excited to have stumbled upon this, but was also surprised no issue had been filed for this yet. I'm a bit self-aware posting this since I'm not a rustc compiler engineer; but I hope this proves to be useful!\r\n\r\ncc/ @jonas-schievink @nnethercote \r\n\r\n## References\r\n- [Parsing Gigabytes of JSON per second](https://branchfree.org/2019/02/25/paper-parsing-gigabytes-of-json-per-second/)\r\n- [simd-lite/simdjson-rs](https://github.com/simd-lite/simdjson-rs)\r\n- [argnidagur/rust-isutf8](https://github.com/ArniDagur/rust-isutf8)\r\n- [lemire/simdjson](https://github.com/lemire/simdjson)\r\n- [Validating UTF-8 strings using as little as 0.7 cycles per byte](https://lemire.me/blog/2018/05/16/validating-utf-8-strings-using-as-little-as-0-7-cycles-per-byte/)\r\n- [assembly for str::from_utf8_unchecked (godbolt) - 7 lines](https://godbolt.org/z/Y9mwfd)\r\n- [assembly for str::from_utf8 (godbolt) - 57 lines](https://godbolt.org/z/ZJk8mL)\r\n- [assembly for run_utf8_validation routine (godbolt) - 183 lines](https://godbolt.org/z/sQteLm)", "labels": ["A-simd", "A-unicode", "C-enhancement", "T-libs"], "number_of_comments": 13, "created_at": "2020-01-22 13:36:37", "reactions": {"total_count": 10, "+1": 4, "-1": 0, "laugh": 0, "heart": 6, "hooray": 0}}, "553537669": {"author_username": "ThomasdenH", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68453, "title": "`char::is_ascii_digit()` is slower than `char::is_digit(10)`", "body": "Using the method `is_ascii_digit` on a char is about 17% slower than using `is_digit(10)`. I wouldn't expect there to be a difference, of if there was, I would expect the former to be faster. Could this be improved or are the two not actually equivalent?", "labels": [], "number_of_comments": 4, "created_at": "2020-01-22 13:22:00", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553299820": {"author_username": "avandesa", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68445, "title": "Misleading diagnostics for `.iter()`", "body": "The following code:\r\n```rust\r\nfn main() {\r\n    let iter = vec![1, 2, 3].iter().map(|x| x * x);\r\n\r\n    for x in iter {\r\n        println!(\"{}\", x);\r\n    }\r\n}\r\n```\r\n\r\nProduces the following error:\r\n```\r\nerror[E0716]: temporary value dropped while borrowed\r\n --> foo.rs:2:16\r\n  |\r\n2 |     let iter = vec![1, 2, 3].iter().map(|x| x * x);\r\n  |                ^^^^^^^^^^^^^                      - temporary value is freed at the end of this statement\r\n  |                |\r\n  |                creates a temporary which is freed while still in use\r\n3 | \r\n4 |     for x in iter {\r\n  |              ---- borrow later used here\r\n  |\r\n  = note: consider using a `let` binding to create a longer lived value\r\n  = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0716`.\r\n```\r\n\r\nThough the suggestion to make a let binding works, and is probably useful for other situations, it's not as elegant here:\r\n```rust\r\nfn main() {\r\n    let vec = complicated_get_vec();\r\n    let iter = vec.iter().map(|x| x * x);\r\n\r\n    for x in iter {\r\n        println!(\"{}\", x);\r\n    }\r\n}\r\n```\r\n\r\nThe better solution to the compile error is to replace `vec![].iter() ...` with `vec![].into_iter()`, and the compiler error message may be updated to reflect this.", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-22 04:25:19", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553218075": {"author_username": "varkor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68437, "title": "Improve generic arg\u2013param mismatch errors", "body": "The current diagnostics are a little ad hoc and rely on counting the number of mismatches (e.g. they will only produce an error for the first mismatch). It would be nice to produce diagnostics like:\r\n```\r\nmissing generic arguments for `T`, `const N: usize`, `U`\r\n```\r\n\r\ncc @eddyb", "labels": ["A-diagnostics", "C-cleanup", "T-compiler"], "number_of_comments": 1, "created_at": "2020-01-21 23:48:51", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553209442": {"author_username": "varkor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68436, "title": "There's currently no way to specify bounds requiring constants in types to be well-formed", "body": "When we have a const expression with a generic parameter in it, we cannot be sure that the const expression is valid for all the values that the generic parameter might take.\r\n```rust\r\nfn foo<const N: usize>() {\r\n\tlet _: [u8; { /* some expression involving N */ }] = ...;\r\n\t// ^ this type may not be well-formed, because the length may result in an error\r\n}\r\n```\r\nIf we do not force the caller of the function to specify that the expression must be well-formed, we may get post-monomorphisation errors, as we can only determine that the expression is well-formed after substituting the concrete values for the generic parameters. We therefore need some way to specify such a bound. This is currently not possible.\r\n\r\nThis was discussed in https://github.com/rust-lang/rust/issues/66962#issuecomment-575907083, https://github.com/rust-lang/rust/issues/66962#issuecomment-576305088, https://github.com/rust-lang/rust/pull/68388#discussion_r368710472.\r\n\r\n@eddyb suggested the syntax `where [u8; { /* some expression involving N */ }]:`, though it is not clear whether this would be appropriate. This needs some discussion and careful consideration of the WF implications.", "labels": ["A-const-generics", "A-traits", "F-const_generics", "T-lang"], "number_of_comments": 2, "created_at": "2020-01-21 23:28:26", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 1, "hooray": 0}}, "553200834": {"author_username": "varkor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68434, "title": "Move generic arg/param validation to `create_substs_for_generic_args` to resolve various const generics issues", "body": "This changes some diagnostics, but I think they're around as helpful as the previous ones, and occur infrequently regardless.\r\n\r\nFixes https://github.com/rust-lang/rust/issues/68257.\r\nFixes https://github.com/rust-lang/rust/issues/68398.\r\n\r\nr? @eddyb \r\n", "labels": ["F-const_generics", "S-waiting-on-review"], "number_of_comments": 7, "created_at": "2020-01-21 23:09:39", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553179769": {"author_username": "Alexhuszagh", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68433, "title": "Add Default Lint to Ensure Match Arm Bindings do not Shadow Local Variables.", "body": "Given the following code:\r\n\r\n```rust\r\nfn foo(x: u32) -> u32 {\r\n  let a = 100;\r\n  let b = 200;\r\n  let c = 300;\r\n\r\n  match x {\r\n      c => 3,\r\n      b => 2,\r\n      a => 1,\r\n      _ => 0\r\n  }\r\n}\r\n```\r\n\r\nwe currently emit:\r\n\r\n```rust\r\nwarning: unreachable pattern\r\n --> <source>:8:7\r\n  |\r\n7 |       c => 3,\r\n  |       - matches any value\r\n8 |       b => 2,\r\n  |       ^ unreachable pattern\r\n  |\r\n  = note: `#[warn(unreachable_patterns)]` on by default\r\n```\r\n\r\nHowever, in this case, the developer was likely confused and thought they were matching on the value of `c`, not creating a binding of with name `c`. We should emit something more similar to:\r\n\r\n```rust\r\nwarning: match arm binding shadows local binding\r\n --> <source>:8:7\r\n  |\r\n7 |       c => 3,\r\n  |       ^\r\n  = note: shadows local binding `c` declared at <source>:4:7\r\n  = note: `#[warn(arm_binding_shadows_local)]` on by default\r\n\r\n```\r\n", "labels": ["A-diagnostics", "A-lint", "C-enhancement", "D-newcomer-roadblock", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-21 22:29:36", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553168742": {"author_username": "natemara", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68430, "title": "Rustc doesn't report line numbers for type errors within proc macro async fn within macro_rules macro", "body": "When using a macro to generate an async fn with a proc macro inside it, if the generated function includes a type error, rustc will not report any line number information. This makes finding and debugging type errors in large async applications extremely difficult.\r\n\r\nI tried this code:\r\n\r\n```\r\nasync fn foo() {}\r\n\r\nmacro_rules! gen_test {\r\n    ($before:expr) => {\r\n        #[tokio::test]\r\n        async fn test_foo() {\r\n            $before;\r\n            let x: () = foo();\r\n        }\r\n    }\r\n}\r\n\r\ngen_test!(dbg!(4));\r\n```\r\n\r\nI expected to see this happen: \r\n\r\nError including line number information (you will get this output if you just comment out the `$before`line in the test fn)\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n  --> src/lib.rs:8:25\r\n   |\r\n8  |             let x: () = foo();\r\n   |                         ^^^^^\r\n   |                         |\r\n   |                         expected (), found opaque type\r\n   |                         help: consider using `.await` here: `foo().await`\r\n...\r\n13 | gen_test!(dbg!(4));\r\n   | ------------------- in this macro invocation\r\n   |\r\n   = note: expected type `()`\r\n              found type `impl std::future::Future`\r\n```\r\n\r\nInstead, this happened: \r\n\r\nError including no line number information\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n  |\r\n  = note: expected type `()`\r\n             found type `impl std::future::Future`\r\n\r\nerror: aborting due to previous error\r\n```\r\n\r\n## Meta\r\n\r\n`rustc --version --verbose`: Tested on Playground with stable 1.40.0 and nightly 1.42.0 (2020-01-20)", "labels": ["A-async-await", "A-diagnostics", "A-macros", "AsyncAwait-OnDeck", "AsyncAwait-Triaged", "C-bug", "T-compiler"], "number_of_comments": 3, "created_at": "2020-01-21 22:12:13", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553153604": {"author_username": "Centril", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68429, "title": "typeck: diverging binding in pattern does not generate unreachable_code", "body": "The following should probably result in the lint being emitted:\r\n```rust\r\n#![feature(never_type)]\r\n\r\npub fn foo(maybe_never: Option<!>) {\r\n    match maybe_never {\r\n        Some(_never) => {\r\n            println!(\"foo\");\r\n        }\r\n        None => {}\r\n    }\r\n}\r\n```\r\nas `_never` is matched on, and it has a diverging type.\r\n\r\nCompare this with:\r\n\r\n```rust\r\n#![feature(never_type)]\r\n\r\npub fn foo(maybe_never: Option<!>) {\r\n    match maybe_never {\r\n        Some(never) => {\r\n            let _ = never;\r\n            println!(\"foo\");\r\n        }\r\n        None => {}\r\n    }\r\n}\r\n```\r\n\r\nCurrently, the pattern type checking code does not care about `diverges`.\r\n\r\nWe should probably avoid fixing this in typeck and have this be fixed automatically (?) by moving `diverges` logic to MIR or some such.\r\n\r\ncc @eddyb https://github.com/rust-lang/rust/pull/68422#discussion_r369246043.", "labels": ["A-lint", "C-bug", "C-enhancement", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-21 21:49:03", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553128991": {"author_username": "TimNN", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68427, "title": "rustdoc only: duplicate lang item `panic_halt`", "body": "This is a regression from `rustdoc 1.40.0 (73528e339 2019-12-16)` to `rustdoc 1.41.0-beta.3 (fb3056216 2020-01-19)`.\r\n\r\nIf rustdoc attempts to document a crate that has at least two dependencies which implement a `panic_handler`, it fails with an error similar to\r\n\r\n```\r\nerror: duplicate lang item in crate `panic_halt` (which `panic2` depends on): `panic_impl`.\r\n  |\r\n  = note: first defined in crate `std` (which `panic2` depends on).\r\n```\r\n\r\nNote that the crate *builds* fine, it's just documenting that is broken.\r\n\r\n---\r\n\r\n**Steps to reproduce**\r\n\r\n1. Create a new project, e.g. `cargo new panic2`\r\n2. Add a dependency on `panic-halt = \"0.2.0\"`, e.g. `cargo add panic-halt`\r\n3. Attempt to document the crate, e.g. `cargo doc`\r\n\r\n<details><summary>An example of the different behavior between `stable`/`beta` and `build`/`doc`.</summary>\r\n\r\n```shell\r\n$ cargo +stable clean\r\n\r\n$ cargo +beta clean\r\n\r\n$ cargo +stable build\r\n   Compiling panic-halt v0.2.0\r\n   Compiling panic2 v0.1.0 (/Users/logic/Projects/tmp/panic2)\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.35s\r\n\r\n$ cargo +stable doc\r\n Documenting panic-halt v0.2.0\r\n    Checking panic-halt v0.2.0\r\n Documenting panic2 v0.1.0 (/Users/logic/Projects/tmp/panic2)\r\n    Finished dev [unoptimized + debuginfo] target(s) in 1.40s\r\n\r\n$ cargo +beta build\r\n   Compiling panic-halt v0.2.0\r\n   Compiling panic2 v0.1.0 (/Users/logic/Projects/tmp/panic2)\r\n    Finished dev [unoptimized + debuginfo] target(s) in 0.27s\r\n\r\n$ cargo +beta doc\r\n Documenting panic-halt v0.2.0\r\n    Checking panic-halt v0.2.0\r\n Documenting panic2 v0.1.0 (/Users/logic/Projects/tmp/panic2)\r\nerror: duplicate lang item in crate `panic_halt` (which `panic2` depends on): `panic_impl`.\r\n  |\r\n  = note: first defined in crate `std` (which `panic2` depends on).\r\n\r\nerror: aborting due to previous error\r\n\r\nerror: Could not document `panic2`.\r\n\r\nCaused by:\r\n  process didn't exit successfully: `rustdoc --edition=2018 --crate-type bin --crate-name panic2 src/main.rs -o /Users/logic/Projects/tmp/panic2/target/doc --error-format=json --json=diagnostic-rendered-ansi --document-private-items -L dependency=/Users/logic/Projects/tmp/panic2/target/debug/deps --extern panic_halt=/Users/logic/Projects/tmp/panic2/target/debug/deps/libpanic_halt-6d0ca720c3c355fb.rmeta` (exit code: 1)\r\n```\r\n\r\n</details>\r\n", "labels": ["A-lang-item", "C-bug", "T-rustdoc", "regression-from-stable-to-stable"], "number_of_comments": 14, "created_at": "2020-01-21 21:05:34", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "553017667": {"author_username": "pnkfelix", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68420, "title": "transparent enum diagnostic should suppress field count when >1 variant", "body": "Consider this code:\r\n\r\n```rust\r\n#![feature(transparent_enums)]\r\n\r\nuse std::mem::size_of;\r\n\r\nfn main() {\r\n    #[repr(transparent)]\r\n    enum VisibleE8 {\r\n        A(u8), B(u8), C(u8), D(u8), E(u8), F(u8), G(u8), H(u8), I(u8), J(u8),\r\n        K(u8), L(u8), M(u8), N(u8), O(u8), P(u8), Q(u8), R(u8), S(u8), T(u8),\r\n    }\r\n\r\n    println!(\"VisibleE8: {}\", size_of::<VisibleE8>());\r\n}\r\n```\r\n\r\nWhen you try to compile this, you get two error diagnostics:\r\n\r\n```\r\nerror[E0731]: transparent enum needs exactly one variant, but has 20\r\n --> src/main.rs:7:5\r\n  |\r\n7 |     enum VisibleE8 {\r\n  |     ^^^^^^^^^^^^^^ needs exactly one variant, but has 20\r\n8 |         A(u8), B(u8), C(u8), D(u8), E(u8), F(u8), G(u8), H(u8), I(u8), J(u8),\r\n  |         -----  -----  -----  -----  -----  -----  -----  -----  -----  -----\r\n9 |         K(u8), L(u8), M(u8), N(u8), O(u8), P(u8), Q(u8), R(u8), S(u8), T(u8),\r\n  |         -----  -----  -----  -----  -----  -----  -----  -----  -----  ----- too many variants in `main::VisibleE8`\r\n\r\nerror[E0690]: the variant of a transparent enum needs exactly one non-zero-sized field, but has 20\r\n --> src/main.rs:7:5\r\n  |\r\n7 |     enum VisibleE8 {\r\n  |     ^^^^^^^^^^^^^^ needs exactly one non-zero-sized field, but has 20\r\n8 |         A(u8), B(u8), C(u8), D(u8), E(u8), F(u8), G(u8), H(u8), I(u8), J(u8),\r\n  |           --     --     --     --     --     --     --     --     --     -- this field is non-zero-sized\r\n  |           |      |      |      |      |      |      |      |      |\r\n  |           |      |      |      |      |      |      |      |      this field is non-zero-sized\r\n  |           |      |      |      |      |      |      |      this field is non-zero-sized\r\n  |           |      |      |      |      |      |      this field is non-zero-sized\r\n  |           |      |      |      |      |      this field is non-zero-sized\r\n  |           |      |      |      |      this field is non-zero-sized\r\n  |           |      |      |      this field is non-zero-sized\r\n  |           |      |      this field is non-zero-sized\r\n  |           |      this field is non-zero-sized\r\n  |           this field is non-zero-sized\r\n9 |         K(u8), L(u8), M(u8), N(u8), O(u8), P(u8), Q(u8), R(u8), S(u8), T(u8),\r\n  |           --     --     --     --     --     --     --     --     --     -- this field is non-zero-sized\r\n  |           |      |      |      |      |      |      |      |      |\r\n  |           |      |      |      |      |      |      |      |      this field is non-zero-sized\r\n  |           |      |      |      |      |      |      |      this field is non-zero-sized\r\n  |           |      |      |      |      |      |      this field is non-zero-sized\r\n  |           |      |      |      |      |      this field is non-zero-sized\r\n  |           |      |      |      |      this field is non-zero-sized\r\n  |           |      |      |      this field is non-zero-sized\r\n  |           |      |      this field is non-zero-sized\r\n  |           |      this field is non-zero-sized\r\n  |           this field is non-zero-sized\r\n\r\nerror: aborting due to 2 previous errors\r\n```\r\n\r\n\r\nThe first diagnostic is exactly describing the problem.\r\n\r\nThe second diagnostic is irrelevant, and arguably confusing (at least in my mental model of enums, the field count of one variant should be considered independently of the counts for all of the enum's other variants).", "labels": ["A-diagnostics", "C-enhancement", "D-verbose", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-21 17:18:15", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "552832861": {"author_username": "Ixrec", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68411, "title": "#[may_dangle] compiles on non-Drop impls", "body": "[The RFC](https://github.com/rust-lang/rfcs/pull/1327) pretty strongly implies that this attribute is only supposed to be used on Drop, and the semantics of it don't make any sense on other traits. Yet, this compiles:\r\n```\r\n#![feature(dropck_eyepatch)]\r\n\r\nstruct Foo<T>(T);\r\n\r\nunsafe impl<#[may_dangle] T> std::ops::Deref for Foo<T> {\r\n    type Target = T;\r\n    fn deref(&self) -> &T {\r\n        &self.0\r\n    }\r\n}\r\n```\r\n[playground link](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=d6bd53017167935e14968b885bf14598)", "labels": ["A-attributes", "C-bug", "F-dropck_eyepatch", "T-compiler", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-21 12:00:11", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "552556958": {"author_username": "martinthomson", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68408, "title": "False positive on dead_code lint", "body": "I'm sure that there is a more concise way to generate this error, but this produces a `dead_code` lint warning:\r\n\r\n```rust\r\n#![deny(warnings)]\r\n\r\nuse std::mem;\r\n\r\n#[derive(Default)]\r\nstruct Y {}\r\nenum X {\r\n    A { y: Y },\r\n    B { y: Y },\r\n}\r\nimpl X {\r\n    fn test(&mut self) {\r\n        if let Self::A { y } = self {\r\n            *self = Self::B { y: mem::take(y) };\r\n        }\r\n    }\r\n}\r\npub fn main() {\r\n    let mut x = X::A { y: Y {} };\r\n    x.test();\r\n}\r\n\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=94bad8e4f5752df652d5df266912ebc7))\r\n\r\nThis code instantiates `X::B`, but the `dead_code` lint disagrees:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nerror: variant is never constructed: `B`\r\n --> src/main.rs:9:5\r\n  |\r\n9 |     B { y: Y },\r\n  |     ^^^^^^^^^^\r\n  |\r\nnote: lint level defined here\r\n --> src/main.rs:1:9\r\n  |\r\n1 | #![deny(warnings)]\r\n  |         ^^^^^^^^\r\n  = note: `#[deny(dead_code)]` implied by `#[deny(warnings)]`\r\n```", "labels": ["A-lint", "C-bug", "T-compiler"], "number_of_comments": 2, "created_at": "2020-01-20 23:59:59", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "552531178": {"author_username": "Amanieu", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68404, "title": "Rename asm! to llvm_asm!", "body": "As per https://github.com/rust-lang/rfcs/pull/2843, this PR renames `asm!` to `llvm_asm!`. It also renames the compiler's internal `InlineAsm` data structures to `LlvmInlineAsm` in preparation for the new `asm!` functionality specified in https://github.com/rust-lang/rfcs/pull/2850.\r\n\r\nThis PR doesn't actually deprecate `asm!` yet, it just makes it redirect to `llvm_asm!`. This is necessary because we first need to update the submodules (in particular stdarch) to use `llvm_asm!`.", "labels": ["S-waiting-on-review", "S-waiting-on-team", "T-compiler", "T-lang"], "number_of_comments": 14, "created_at": "2020-01-20 22:16:19", "reactions": {"total_count": 3, "+1": 0, "-1": 0, "laugh": 0, "heart": 3, "hooray": 0}}, "552470016": {"author_username": "varkor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68400, "title": "Classify various const generics bugs", "body": "@eddyb identified several bugs in Playground examples on Discord, starting [here](https://discordapp.com/channels/442252698964721669/443151243398086667/668869625139953675). We should classify them and make sure we have representative edge cases for each when they've fixed.", "labels": ["A-const-generics", "F-const_generics", "metabug"], "number_of_comments": 1, "created_at": "2020-01-20 19:19:09", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "552455568": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68398, "title": "Const generic parameters are allowed in the wrong position (causing ICEs).", "body": "Note the `Array<N, ()>` use, instead of `Array<(), N>`:\r\n```rust\r\n#![feature(const_generics)]\r\n\r\npub type Array<T, const N: usize> = [T; N];\r\n\r\npub fn foo<const N: usize>() -> Array<N, ()> {\r\n    unimplemented!()\r\n}\r\n```\r\nThis currently results in `cat_expr Errd` and `broken MIR` ICEs.\r\n\r\ncc @varkor @yodaldevoid @oli-obk", "labels": ["A-const-generics", "C-bug", "F-const_generics", "I-ICE", "T-compiler", "glacier"], "number_of_comments": 0, "created_at": "2020-01-20 18:38:27", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "552429202": {"author_username": "Centril", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68395, "title": "`PatternError::StaticInPattern` seems to be dead code", "body": "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/hair/pattern/struct.PatCtxt.html#method.report_inlining_errors never hits `PatternError::StaticInPattern` in practice it seems. We should check if it is actually unreachable.\r\n\r\ncc @oli-obk ", "labels": ["C-cleanup", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-20 17:28:03", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "552415696": {"author_username": "jyn514", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68392, "title": "impl From<T> for [T; 1]", "body": "I would have found this useful for writing functions like this: https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=b9c1e08152d1cd3709edf65587d87fc7", "labels": ["S-waiting-on-review", "T-libs", "needs-fcp", "relnotes"], "number_of_comments": 6, "created_at": "2020-01-20 16:57:54", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "552357408": {"author_username": "varkor", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68387, "title": "Consider extending `unused_parens` to `{}`, particularly in const generics", "body": "In const generics, `{}` are required for complex expressions in const generic arguments (e.g. `{M + N}`). They are not required, however, for literals and standalone parameters (in most cases). However, at least at the moment, it is quite common to see curly brackets in user code for all generic arguments. This may be a passing phase, as generic arguments [only recently](https://github.com/rust-lang/rust/pull/66104) started being disambiguated; however, if it is not, we might want to lint on extraneous `{}` to inform users.\r\n\r\nThis might be useful outside of const generis too, such as in:\r\n```rust\r\nlet _ = (5); // lints about unnecessary parens\r\nlet _ = {5}; // does not lint\r\n```", "labels": ["A-const-generics", "A-diagnostics", "A-lint", "A-suggestion-diagnostics", "C-enhancement", "T-compiler", "T-lang"], "number_of_comments": 1, "created_at": "2020-01-20 15:08:45", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "552352064": {"author_username": "tamasfe", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68385, "title": "Const generics, the trait bound is not satisfied", "body": "I would expect the following code to work with different const values just as it does with different types:\r\n\r\n```rust\r\ntrait Trait<const PARAM: &'static str> {\r\n    fn do_stuff(&self);\r\n}\r\n\r\nstruct Struct;\r\n\r\nimpl Trait<\"param\"> for Struct {\r\n    fn do_stuff(&self) {}\r\n}\r\n\r\nimpl Trait<\"another_param\"> for Struct {\r\n    fn do_stuff(&self) {}\r\n}\r\n\r\nfn stuff() {\r\n    let s = Struct;\r\n\r\n    <Struct as Trait<\"param\">>::do_stuff(&s);\r\n}\r\n```\r\n\r\nHowever it fails with:\r\n\r\n```\r\nthe trait bound `Struct: Trait<\"param\">` is not satisfied\r\nthe following implementations were found:\r\n  <Struct as Trait<\"another_param\">>\r\n  <Struct as Trait<\"param\">> rustc(E0277)\r\n```\r\n\r\nIf implemented with only one value, the compiler infers it correctly (_universal function call still doesn't work however_), also adding brackets anywhere makes no difference.\r\n\r\n```\r\nrustc 1.40.0-nightly (4a8c5b20c 2019-10-23)\r\nbinary: rustc\r\ncommit-hash: 4a8c5b20c7772bc5342b83d4b0696ea216ef75a7\r\ncommit-date: 2019-10-23\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.40.0-nightly\r\nLLVM version: 9.0\r\n```", "labels": ["C-bug", "F-const_generics", "T-compiler", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-20 14:59:51", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "552061943": {"author_username": "rickvanprim", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68379, "title": "Expose `type_name()` method on Any.", "body": "In a similar spirit to #61533, it would be nice if the Any trait contained an auto implemented method akin to:\r\n```rust\r\nfn type_name(&self) -> &'static str\r\n{\r\n    std::any::type_name::<T>()\r\n}\r\n```\r\nThis way it would be a lot easier print and surface errors like accidentally trying to cast `Box<T>` to `T` because `&Box<T>` is also `&Any`.", "labels": ["A-intrinsics", "C-feature-request", "T-libs"], "number_of_comments": 0, "created_at": "2020-01-20 04:39:14", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551993466": {"author_username": "gmorenz", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68375, "title": "Associated type behind a *mut unecessarily results in invariant subtyping", "body": "Consider the following code ([playpen](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=a73ee6a15b31f56b93fae74c447ea628))\r\n\r\n```rust\r\npub trait Data {\r\n    type Elem;\r\n}\r\n\r\npub struct ViewRepr<A>(A);\r\n\r\nimpl<'a, A> Data for ViewRepr<&'a A> {\r\n    type Elem = A;\r\n}\r\n\r\npub struct ArrayBase<D: Data> {\r\n    ptr: *mut D::Elem,\r\n    // ptr: *mut f32,\r\n    d: D,\r\n}\r\n\r\npub fn cast_array_view<'shorter, 'longer: 'shorter>(\r\n    input: ArrayBase<ViewRepr<&'longer f32>>\r\n) -> ArrayBase<ViewRepr<&'shorter f32>> {\r\n    input\r\n}\r\n```\r\n\r\n`cast_array_view` fails to compile with the first definition of `ptr`, and succeeds with the second, despite the two functions being apparently identical. \r\n\r\nI think the reason this is happening is most likely related to the fact that subtyping of `*mut` [pointers is invariant on the type of their parameter](https://doc.rust-lang.org/nomicon/subtyping.html#variance), and structs containing `*mut T` pointers are invariant with respect to `T`. Since `D::Elem` is being stored behind a `*mut` pointer rustc has decided that `ArrayBase` is invariant with respect to `D`, instead of `D::Elem`.\r\n\r\nPS: Thanks to /u/Patryk27 on reddit for looking at this and pointing me in the direction of the variance docs.", "labels": ["A-associated-items", "A-typesystem", "T-lang"], "number_of_comments": 5, "created_at": "2020-01-19 22:06:32", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551975209": {"author_username": "sm-Fifteen", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68373, "title": "Wrong error message (E401) when storing the result of a generic const fn inside a const member of a generic function", "body": "I tried this code, assuming the result of `size_of::<T>()` would be considered a constant value since it would be known at function monomorphization:\r\n\r\n```rust\r\nconst fn size_plus_one<T:Sized>() -> usize {\r\n    const size: usize = ::core::mem::size_of::<T>();\r\n\r\n    size + 1\r\n}\r\n```\r\n\r\nThis resulted in the following compilation error:\r\n\r\n```\r\nerror[E0401]: can't use generic parameters from outer function\r\n --> src/lib.rs:2:48\r\n  |\r\n1 | const fn size_plus_one<T:Sized>() -> usize {\r\n  |                        - type parameter from outer function\r\n2 |     const size: usize = ::core::mem::size_of::<T>();\r\n  |                                                ^ use of generic parameter from outer function\r\n```\r\n\r\nAs it turns out, the error message here is incorrect, and the issue can be solved by using `let` instead, something the error message was rather unhelpful with.\r\n\r\n```rust\r\nconst fn size_plus_one<T:Sized>() -> usize {\r\n    let size: usize = ::core::mem::size_of::<T>();\r\n\r\n    size + 1\r\n}\r\n```\r\n\r\n[**PLAYGROUND LINK**](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=a1a19008933627ff9ca64d6751626fce)\r\n\r\n## Meta\r\n\r\n```\r\nrustc 1.40.0 (73528e339 2019-12-16)\r\nbinary: rustc\r\ncommit-hash: 73528e339aae0f17a15ffa49a8ac608f50c6cf14\r\ncommit-date: 2019-12-16\r\nhost: x86_64-unknown-linux-gnu\r\nrelease: 1.40.0\r\nLLVM version: 9.0\r\n```", "labels": ["A-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 2, "created_at": "2020-01-19 20:00:57", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551958954": {"author_username": "mydogisbox", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68371, "title": "Scan is overly specialized", "body": "Here is the existing type signature for std::iter::scan:\r\n`fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F> where\r\n    F: FnMut(&mut St, Self::Item) -> Option<B>, `\r\n\r\nIf I were to use a verbose name for `scan` as implemented now, I would call it `map_with_state_until`, this means that if I just want `map_with_state`, things can get really awkward using the existing scan if I want to return an option which _doesn't_ terminate the Iterator for `collect` etc. e.g. `vecter.iter().scan( |state, x| if x > 1 then Some(None) else Some(Some(x)) ).flatten()`\r\n\r\nIf we instead have `F` just turn `B` instead of `Option<B>` like:\r\n`fn scan<St, B, F>(self, initial_state: St, f: F) -> Scan<Self, St, F> where\r\n    F: FnMut(&mut St, Self::Item) -> B, ` then that becomes a lot more simple:\r\n`vecter.iter().scan( |state, x| if x > 1 then None else Some(x) )`\r\n\r\nand achieving the existing `scan` behavior is trivially achieved by simply adding `fuse()`.\r\n\r\nThis allows `scan` to have behavior more in-line with similar functions like `map` and `fold`:\r\n\r\n```\r\nfn fold<B, F>(self, init: B, f: F) -> B where\r\n    F: FnMut(B, Self::Item) -> B, \r\n\r\nfn map<B, F>(self, f: F) -> Map<Self, F> where\r\n    F: FnMut(Self::Item) -> B,\r\n```\r\n\r\nand also brings it more in-line with how other languages define `scan` :  `(a -> b -> a) -> a -> [b] -> [a]` (Haskell), `('State -> 'T -> 'State) -> 'State -> seq<'T> -> seq<'State>` (F#) etc. \r\n\r\nI think this also gives a clear way forward to addressing other issues which previously ended up unresolved like:\r\nhttps://github.com/rust-lang/rust/pull/14425 \r\n\r\nSo I think there ought to be `scan` as defined above, and `scan_until` which is the existing implementation.\r\n\r\nReferences:\r\nhttp://zvon.org/other/haskell/Outputprelude/scanl_f.html\r\n\r\nhttps://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/seq.scan%5b't,'state%5d-function-%5bfsharp%5d", "labels": ["A-iterators", "C-feature-request", "T-libs"], "number_of_comments": 4, "created_at": "2020-01-19 18:03:15", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551952926": {"author_username": "kai-alpha", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68369, "title": "`x.py install` fails for a nonexistent prefix", "body": "#49778 introduced `fs::canonicalize()` which [fails for a nonexistent path](https://doc.rust-lang.org/std/fs/fn.canonicalize.html#errors)\r\n\r\nThis is a surprise for someone used to GNU Autotools' configure which can create any necessary intermediate directories in `prefix`", "labels": ["A-rustbuild", "C-bug", "T-infra"], "number_of_comments": 1, "created_at": "2020-01-19 17:12:43", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551940263": {"author_username": "DutchGhost", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68366, "title": "Const generics unconstrained generics", "body": "The following code does NOT compile:\r\n```Rust\r\n#![feature(const_generics)]\r\n\r\nstruct Collatz<const N: Option<usize>>;\r\n\r\nimpl <const N: usize> Collatz<{Some(N)}> {\r\n    \r\n}\r\n\r\nfn main() {\r\n}\r\n```\r\nit errors with:\r\n```\r\nerror[E0207]: the const parameter `N` is not constrained by the impl trait, self type, or predicates\r\n --> src/main.rs:5:13\r\n  |\r\n5 | impl <const N: usize> Collatz<{Some(N)}> {\r\n  |             ^ unconstrained const parameter\r\n\r\n```\r\n\r\nHowever, when using normal generics in the places of the const generics, wrapping the `T` in an `Option` and sticking that into the `Collatz` struct does work:\r\n```Rust\r\nstruct Collatz<T>([T; 0]);\r\n\r\nimpl <T> Collatz<Option<T>> {}\r\n```\r\n\r\nIs it intended that const generic dont mimmic this behaviour?", "labels": ["A-const-generics", "C-bug", "F-const_generics", "T-compiler", "requires-nightly"], "number_of_comments": 1, "created_at": "2020-01-19 15:35:49", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551926836": {"author_username": "eddyb", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68364, "title": "Semantics of MIR assignments, around aliasing, ordering, and primitives.", "body": "In today's MIR, an indirect assignment like `*p = *q;` is similar to, but not exactly the same as:\r\n```rust\r\ntmp = *q;\r\n*p = tmp;\r\n```\r\nThe differences are:\r\n* performance: they only produce the same codegen for primitives\r\n  * this is assuming `tmp` isn't used elsewhere, allowing codegen to treat it like an SSA value, resulting in `store(p, load(q))`, which is also what `*p = *q` codegens to\r\n  * for non-primitives, the amount of data being copied doubles, as `tmp` must be in memory\r\n* correctness: only `*p = *q;` is UB (AFAIK) if `p..p+size` overlaps `q..q+size`\r\n  * this also likely only affects non-primitives, which have to copy data in memory, but we could decide to ignore the type and always make it UB when they overlap\r\n\r\n<hr/>\r\n\r\nFor the purposes of this discussion, a primitive is:\r\n* scalar (`bool`, `char`, integer, float, or pointer/reference)\r\n* vector (SIMD-enabled array of scalars)\r\n\r\nScalar pairs likely also should/need to be included, due to how easy they are to support in any code that already handles scalars, and also due to their use in wide pointers/references.\r\n\r\n<hr/>\r\n\r\nWhat's interesting about primitives, though, is that some kinds of `Rvalue`s (the RHS of the assignment) *always* produce primitive values, because they're primitive operations.\r\n\r\nThe `Rvalue` variants which are always primitive, today, are:\r\n* `Ref` (`&T` / `&mut T` - may become dependent on custom DSTs in the future)\r\n* `AddressOf` (`*const T` / `*mut T` - may become dependent on custom DSTs in the future)\r\n* `Len` (`usize`)\r\n* `Cast`, other than unsizing (scalar)\r\n* `BinaryOp`, `UnaryOp` (scalar, or maybe also vector)\r\n* `CheckedBinaryOp` (pair of integer and `bool` - only if we consider scalar pairs to be primitive)\r\n* `NullaryOp(SizeOf)` (`usize`)\r\n* `NullaryOp(Box)` (`Box<T>`)\r\n* `Discriminant` (integer)\r\n\r\nWhich leaves these variants as potentially relying on memory operations to write the result:\r\n* `Use` (any type, one copy)\r\n* `Repeat` (`[T; N]`, `N` copies)\r\n* `Cast`, specifically unsizing (any type implementing `CoerceUnsized`, per-field copies)\r\n* `Aggregate` (any ADT, per-field copies)\r\n\r\nIf we want to remain conservative, we could ignore types for the latter, and just assume that the destination of the assignment cannot overlap any memory read in the `Operand`s of the `Rvalue`.\r\n\r\nWe could even cement the distinction by moving the always-primitive operations into a new `PrimOp` enum, and/or move the other `Rvalue`s to their own statements (e.g. introduce `Copy(*p, *q)`), but that's more aesthetic than anything for the time being.\r\n\r\nAt the very least, we should probably document these differences, and make sure that `miri` only allows overlaps in the cases we don't consider UB (either abstractly, or due to our choice of codegen).\r\n\r\n<hr/>\r\n\r\nAnother interesting aspect of the always-primitive ops is that they're \"pure functions\" of their operands (other than `NullaryOp(Box)`, I suppose, but that could be replaced with a call to a lang item returning a `Box<MaybeUninit<T>>`, instead).\r\n\r\nThis means that if we wanted to, we could replace some of the intermediary locals with an `PrimOp` DAG, a bit like SSA but without \u03c6 (`phi`) nodes or a strict instruction stream.\r\nAll of the necessary ordering would still happen at the statement level (so this is nowhere near as complex as VSDG), but we might see some benefits in scalar-heavy code.\r\n\r\n<hr/>\r\n\r\nAsides aside, cc @RalfJung @rust-lang/wg-mir-opt", "labels": ["A-mir", "T-compiler", "T-lang"], "number_of_comments": 14, "created_at": "2020-01-19 14:04:34", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551889713": {"author_username": "csmoe", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68362, "title": "Record lifetime constraints inside generator interior", "body": "Closes #64552 \r\nr? @ghost \r\ncc @Aaron1011  ", "labels": ["S-waiting-on-author", "T-compiler"], "number_of_comments": 4, "created_at": "2020-01-19 09:01:17", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551826635": {"author_username": "Centril", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68354, "title": "Tracking issue for pattern with by-move & by-ref bindings", "body": "This is the tracking issue for `#![feature(move_ref_pattern)]`, which allows patterns containing both by-ref and by-move bindings at the same time. For example: `(ref x, y, ref mut z)`.\r\n\r\n## Implementation history\r\n\r\n- On 2020-02-09, the implementation of the feature in https://github.com/rust-lang/rust/pull/68376 landed, thereby fixing https://github.com/rust-lang/rust/issues/45600. The PR was written by @Centril and reviewed by @matthewjasper.", "labels": ["A-NLL", "B-unstable", "C-tracking-issue", "F-move_ref_pattern", "NLL-complete", "T-lang"], "number_of_comments": 4, "created_at": "2020-01-18 21:27:03", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551804816": {"author_username": "Aaron1011", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68350, "title": "Add lint for never type regressions", "body": "Fixes #67225\r\nFixes #66173\r\n\r\nTl;DR: This PR introduces a lint that detects the 'bad' never-type fallback in `objc` (which results in U.B.), while allowing safe fallback to occur without a warning.\r\n\r\nSee https://hackmd.io/@FohtAO04T92wF-8_TVATYQ/SJ0vcjyWL for some background on never-type fallback.\r\n\r\n### The problem\r\n\r\nWe want to reject \"bad\" code like this:\r\n\r\n```rust\r\nfn unconstrained_return<T>() -> Result<T, String> {\r\n    let ffi: fn() -> T = transmute(some_pointer);\r\n    Ok(ffi())\r\n}\r\nfn foo() {\r\n    match unconstrained_return::<_>() {\r\n        Ok(x) => x,  // `x` has type `_`, which is unconstrained\r\n        Err(s) => panic!(s),  // \u2026 except for unifying with the type of `panic!()`\r\n        // so that both `match` arms have the same type.\r\n        // Therefore `_` resolves to `!` and we \"return\" an `Ok(!)` value.\r\n    };\r\n}\r\n```\r\n\r\nin which enabling never-type fallback can cause undefined behavior.\r\n\r\nHowever, we want to allow \"good\" code like this:\r\n\r\n```rust\r\nstruct E;\r\nimpl From<!> for E {\r\n    fn from(x: !) -> E { x }\r\n}\r\nfn foo(never: !) {\r\n    <E as From<_>>::from(never);\r\n}\r\n\r\nfn main() {}\r\n```\r\n\r\nwhich relies on never-type fallback being enabled, but is perfectly safe.\r\n\r\n### The solution\r\n\r\nThe key difference between these two examples lies in how the result of never-type fallback is used. In the first example, we end up inferring the generic parameter of `unconstrained_return` to be `!`. In the second example, we still infer a generic parameter to be `!` (`Box::<!>::new(!)`), but we also pass an uninhabited parameter to the function.\r\n\r\nAnother way of looking at this is that the call to `unconstrained_return` is **potentially live* - none of its arguments are uninhabited, so we might (and in fact, do) end up actually executing the call at runtime.\r\n\r\nIn the second example, `Box::new()` has an uninhabited argument (the `!` type). This means that this call is **definitely dead** - since the `!` type can never be instantiated, it's impossible for the call to every be executed.\r\n\r\nThis forms the basis for the check. For each method call, we check the following:\r\n\r\n1. Did the generic arguments have unconstrained type variables prior to fallback?\r\n2. Did any of the generic arguments become uninhabited after fallback?\r\n3. Are all of the method arguments inhabited?\r\n\r\nIf the answer to all of these is *yes*, we emit an error. I've left extensive comments in the code describing how this is accomplished.\r\n\r\nThese conditions ensure that we don't error on the `Box` and `From<!>` examples, while still erroring on the bad `objc` code.\r\n\r\n### Further notes\r\n\r\nYou can test out this branch with the original bad `objc` code as follows:\r\n\r\n1. Clone `https://github.com/Aaron1011/rust-objc`\r\n2. Checkout the `bad-fallback` branch.\r\n3. With a local rustc toolchain built from this branch, run `cargo build --example example`\r\n4. Note that you get an error due to an unconstrained return type\r\n\r\n### Unresolved questions\r\n\r\n1. This lint only checks method calls. I believe this is sufficient to catch any undefined behavior caused by fallback changes. Since the introduced undefined behavior relies on actually 'producing' a `!` type instance, the user must be doing something 'weird' (calling `transmute` or some other intrinsic). I don't think it's possible to trigger this without *some* kind of intrinsic call - however, I'm not 100% certain.\r\n\r\n2. This lint requires us to perform extra work during the type-checking of every single method. This is not ideal - however, changing this would have required significant refactoring to method type-checking. It would be a good idea to due to a perf run to see what kind of impact this has, and it another approach will be required.\r\n\r\n3. This 'lint' is currently a hard error. I believe it should always be possible to fix this error by adding explicit type annotations *somewhere* (though in the `obj` case, this may be in the caller of a macro). Unfortunately, I think actually emitting any kind of suggestion to the user will be extremely difficult. Hopefully, this error is so rare that the lack of suggestion isn't a problem. If users are running into this with any frequency, I think we'll need a different approach.\r\n\r\n4. If this PR is accepted, I see two ways of rolling this out:\r\n\r\n1. If the bad `objc` crate is the only crate known to be affected, we could potentially go from no warning/lint to a hard error in a single release (coupled enabling never-type fallback0.\r\n2. If we're worried that this could break a lot of crates, we could make this into a future compatibility lint. At some point in the future, we could enable never-type fallback while simultaneously making this a hard error.\r\n\r\nWhat we should **not** do is make the never-type fallback changes without making this lint (or whatever lint ends up getting accepted) into a hard error. A lint, even a deny-by-default one, would be insufficient, as we would run a serious risk introducing undefined behavior without any kind of explicit acknowledgment from the user.\r\n", "labels": ["I-nominated", "S-waiting-on-review", "T-lang"], "number_of_comments": 88, "created_at": "2020-01-18 18:20:36", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551802414": {"author_username": "bjorn3", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68349, "title": "Let custom codegen backends opt out of LTO", "body": "For example cg_clif doesn't support LTO. Unfortunately enabling LTO makes the linker code always omit object files, so attempting to use `-Clto=yes` will result in a linker error. It is not practical to just not pass `-Clto=yes`, as many crates enable it in their `Cargo.toml`. I would like to be able to make cg_clif tell rustc that LTO should be disabled, even when `-Clto=yes` is passed. I think there should still be a warning though.", "labels": ["A-codegen", "A-linkage", "C-feature-request", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-18 17:58:59", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551798743": {"author_username": "bjorn3", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68347, "title": "[MIR-opt] error: internal compiler error: src/librustc/traits/codegen/mod.rs:57: Encountered error `OutputTypeParameterMismatch(...) during codegen", "body": "```\r\nerror: internal compiler error: src/librustc/traits/codegen/mod.rs:57: Encountered error `OutputTypeParameterMismatch(\r\n    Binder(<[closure@server/src/cmd.rs:985:19: 1030:10 sim:&&veloren_world::sim::WorldSim, wpos:&vek::vec::repr_c::vec2::Vec2<i32>, sampler:&veloren_world::column::ColumnGen] as std::ops::Fn<()>>),\r\n    Binder(<[closure@server/src/cmd.rs:985:19: 1030:10 sim:&&veloren_world::sim::WorldSim, wpos:&vek::vec::repr_c::vec2::Vec2<i32>, sampler:&impl veloren_world::util::sampler::Sampler] as std::ops::Fn<()>>),\r\n    Sorts(ExpectedFound {\r\n        expected: impl veloren_world::util::sampler::Sampler,\r\n        found: veloren_world::column::ColumnGen\r\n    })\r\n)` selecting `Binder(<\r\n    [closure@server/src/cmd.rs:985:19: 1030:10 sim:&&veloren_world::sim::WorldSim, wpos:&vek::vec::repr_c::vec2::Vec2<i32>, sampler:&impl veloren_world::util::sampler::Sampler]\r\n    as\r\n    std::ops::Fn<()>\r\n>)` during codegen\r\n```\r\n\r\n\r\n```\r\n$ git clone https://gitlab.com/veloren/veloren\r\n$ git checkout 8d2c69673dd63e3cb689f1df5574eabfed7826af\r\n$ RUSTFLAGS=\"-Zmir-opt-level=3\" cargo build\r\n[...]\r\nerror: internal compiler error: src/librustc/traits/codegen/mod.rs:57: Encountered error `OutputTypeParameterMismatch(Binder(<[closure@server/src/cmd.rs:985:19: 1030:10 sim:&&veloren_world::sim::WorldSim, wpos:&vek::vec::repr_c::vec2::Vec2<i32>, sampler:&veloren_world::column::ColumnGen] as std::ops::Fn<()>>), Binder(<[closure@server/src/cmd.rs:985:19: 1030:10 sim:&&veloren_world::sim::WorldSim, wpos:&vek::vec::repr_c::vec2::Vec2<i32>, sampler:&impl veloren_world::util::sampler::Sampler] as std::ops::Fn<()>>), Sorts(ExpectedFound { expected: impl veloren_world::util::sampler::Sampler, found: veloren_world::column::ColumnGen }))` selecting `Binder(<[closure@server/src/cmd.rs:985:19: 1030:10 sim:&&veloren_world::sim::WorldSim, wpos:&vek::vec::repr_c::vec2::Vec2<i32>, sampler:&impl veloren_world::util::sampler::Sampler] as std::ops::Fn<()>>)` during codegen\r\n\r\nthread 'rustc' panicked at 'Box<Any>', src/librustc_errors/lib.rs:872:9\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1057\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:195\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:215\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:467\r\n  12: std::panicking::begin_panic\r\n  13: rustc_errors::HandlerInner::bug\r\n  14: rustc_errors::Handler::bug\r\n  15: rustc::util::bug::opt_span_bug_fmt::{{closure}}\r\n  16: rustc::ty::context::tls::with_opt::{{closure}}\r\n  17: rustc::ty::context::tls::with_opt\r\n  18: rustc::util::bug::opt_span_bug_fmt\r\n  19: rustc::util::bug::bug_fmt\r\n  20: rustc::ty::context::GlobalCtxt::enter_local\r\n  21: rustc::traits::codegen::codegen_fulfill_obligation\r\n  22: rustc::ty::query::__query_compute::codegen_fulfill_obligation\r\n  23: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::codegen_fulfill_obligation>::compute\r\n  24: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  25: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  26: rustc::ty::instance::Instance::resolve\r\n  27: rustc_mir::transform::inline::Inliner::run_pass\r\n  28: <rustc_mir::transform::inline::Inline as rustc_mir::transform::MirPass>::run_pass\r\n  29: rustc_mir::transform::run_passes\r\n  30: rustc_mir::transform::run_optimization_passes\r\n  31: rustc_mir::transform::optimized_mir\r\n  32: rustc::ty::query::<impl rustc::ty::query::config::QueryAccessors for rustc::ty::query::queries::optimized_mir>::compute\r\n  33: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  34: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  35: rustc::ty::<impl rustc::ty::context::TyCtxt>::instance_mir\r\n  36: rustc_mir::monomorphize::collector::collect_items_rec\r\n  37: rustc_mir::monomorphize::collector::collect_items_rec\r\n  38: rustc_mir::monomorphize::collector::collect_items_rec\r\n  39: rustc_mir::monomorphize::collector::collect_items_rec\r\n  40: rustc_mir::monomorphize::collector::collect_items_rec\r\n  41: rustc_mir::monomorphize::collector::collect_items_rec\r\n  42: rustc_mir::monomorphize::collector::collect_items_rec\r\n  43: rustc_mir::monomorphize::collector::collect_items_rec\r\n  44: rustc_mir::monomorphize::collector::collect_items_rec\r\n  45: rustc_mir::monomorphize::collector::collect_items_rec\r\n  46: rustc_mir::monomorphize::collector::collect_items_rec\r\n  47: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  48: rustc_mir::monomorphize::collector::collect_crate_mono_items\r\n  49: rustc_mir::monomorphize::partitioning::collect_and_partition_mono_items\r\n  50: rustc::ty::query::__query_compute::collect_and_partition_mono_items\r\n  51: rustc::dep_graph::graph::DepGraph::with_task_impl\r\n  52: rustc::ty::query::plumbing::<impl rustc::ty::context::TyCtxt>::get_query\r\n  53: rustc_codegen_cranelift::driver::codegen_crate\r\n  54: <rustc_codegen_cranelift::CraneliftCodegenBackend as rustc_codegen_utils::codegen_backend::CodegenBackend>::codegen_crate\r\n  55: rustc_session::utils::<impl rustc_session::session::Session>::time\r\n  56: rustc_interface::passes::QueryContext::enter\r\n  57: rustc_interface::queries::Queries::ongoing_codegen\r\n  58: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  59: scoped_tls::ScopedKey<T>::set\r\n  60: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (31dd4f4ac 2020-01-13) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -Z panic-abort-tests -Z codegen-backend=/home/bjorn/Documenten/cg_clif/target/release/librustc_codegen_cranelift.so -Z mir-opt-level=3 -C opt-level=2 -C panic=abort -C codegen-units=8 -C debug-assertions=on -C incremental -C panic=abort -C debuginfo=2 --crate-type lib\r\n\r\nnote: some of the compiler flags provided by cargo are hidden\r\n\r\nquery stack during panic:\r\n#0 [codegen_fulfill_obligation] checking if `std::ops::Fn` fulfills its obligations\r\n#1 [optimized_mir] processing `cmd::handle_debug_column`\r\n#2 [collect_and_partition_mono_items] collect_and_partition_mono_items\r\nend of query stack\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `veloren-server`.\r\n```\r\n\r\n@rustbot modify labels: +A-mir +C-bug +requires-nightly", "labels": ["A-mir", "C-bug", "T-compiler", "requires-nightly"], "number_of_comments": 0, "created_at": "2020-01-18 17:30:01", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551745005": {"author_username": "crlf0710", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68336, "title": "Support hiding specific stackframes from backtrace by marking on the original functions.", "body": "Recently `#[track_caller]` usages has landed on nightly channel, which is really great! However i want to request a little more here. Currently\r\n```rust\r\nfn main() {\r\n    panic!(\"foo\");\r\n}\r\n```\r\noutput is:\r\n```text\r\nthread 'main' panicked at 'foo', src/main.rs:2:5\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1057\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:472\r\n  11: std::panicking::begin_panic\r\n             at /rustc/689fca01c5a1eac2d240bf08aa728171a28f2285/src/libstd/panicking.rs:399\r\n  12: playground::main\r\n             at src/main.rs:2\r\n  13: std::rt::lang_start::{{closure}}\r\n             at /rustc/689fca01c5a1eac2d240bf08aa728171a28f2285/src/libstd/rt.rs:67\r\n  14: std::rt::lang_start_internal::{{closure}}\r\n             at src/libstd/rt.rs:52\r\n  15: std::panicking::try::do_call\r\n             at src/libstd/panicking.rs:305\r\n  16: __rust_maybe_catch_panic\r\n             at src/libpanic_unwind/lib.rs:86\r\n  17: std::panicking::try\r\n             at src/libstd/panicking.rs:281\r\n  18: std::panic::catch_unwind\r\n             at src/libstd/panic.rs:394\r\n  19: std::rt::lang_start_internal\r\n             at src/libstd/rt.rs:51\r\n  20: std::rt::lang_start\r\n             at /rustc/689fca01c5a1eac2d240bf08aa728171a28f2285/src/libstd/rt.rs:67\r\n  21: main\r\n  22: __libc_start_main\r\n```\r\nHowever, of the 22 stack frames, only 3 or 4 is meaningful to user. It would be great if rest of the  functions can be marked with a special attribute, and maybe marked somehow in the mangled symbol, then be excluded from the default display of backtrace.\r\n\r\n\r\n\r\n", "labels": ["A-runtime", "C-feature-request", "T-lang"], "number_of_comments": 5, "created_at": "2020-01-18 09:22:56", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551738959": {"author_username": "andre-richter", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68334, "title": "AArch64 bare-metal targets: Build rust-std", "body": "This PR complements https://github.com/rust-lang/rust/pull/68253\r\n", "labels": ["O-ARM", "S-waiting-on-author", "T-compiler", "relnotes"], "number_of_comments": 14, "created_at": "2020-01-18 08:22:46", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551732652": {"author_username": "cwfitzgerald", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68333, "title": "--pretty=expanded fails after calling cbindgen in cdylib crate", "body": "# Preface\r\n\r\nThis one is a bit of a doozy and I can't tell if it's a rustc issue or a cbindgen issue or both, so I'm going to cross-report them so both projects can be aware.\r\n\r\nI don't have a minimal reproduction, but it is easily reproducible in my repo.\r\n\r\nRepo: https://github.com/BVE-Reborn/bve-reborn\r\nWorking Commit: [`52b3ec6`](https://github.com/BVE-Reborn/bve-reborn/commit/52b3ec6c232198e7585909f20404b9ee5323bdab)\r\nFailing Commit: [`7799c04`](https://github.com/BVE-Reborn/bve-reborn/commit/7799c04340edefcd52c51023e1271c0bb67d5ad1)\r\n\r\nThe only difference is the addition of the crate type of `cdylib`. (`rlib` is there, but it reproduces on my next commit which removed it)\r\n\r\n# System Info\r\n\r\n`Xubuntu 18.04`\r\n\r\nRust and Cargo locked to `nightly-2020-01-16`\r\nrustc: `rustc 1.42.0-nightly (3291ae339 2020-01-15)`\r\ncargo: `cargo 1.42.0-nightly (ad3dbe10e 2020-01-13)`\r\n\r\nCBindgen latest, compiled on the same nightly toolchain:\r\n`cbindgen 0.12.2`\r\n\r\n# Repro\r\n\r\nThe rustc command is the exact command cbindgen runs to get macro expanded data.\r\n\r\nThis all takes place in the root of my repo.\r\n\r\n```\r\ncargo build\r\ncargo rustc --lib --manifest-path bve-native/Cargo.toml  -p \"bve-native:0.0.0-Placeholder\" \"--verbose\" -- -Z unstable-options --pretty=expanded \r\n```\r\n\r\nBoth succeed as expected. However if you call cbindgen it fails, and the rustc no longer outputs anything at all.\r\n\r\n```\r\n# Succeeds\r\ncargo build\r\n\r\n# Fails citing an issue with compiling\r\n# Occasionally must be run twice\r\ncbindgen bve-native/ -c bve-native/cbindgen.toml -v\r\n\r\n# Returns zero, but outputs nothing.\r\ncargo rustc --lib --manifest-path bve-native/Cargo.toml  -p \"bve-native:0.0.0-Placeholder\" \"--verbose\" -- -Z unstable-options --pretty=expanded \r\n# You can call ^ as many times as you want, it will always fail\r\n```\r\n\r\nThe problem goes away when you `cargo clean` and reappears by running cbindgen again.\r\n\r\n# Comments\r\n\r\nI have no idea what or who is causing this issue.\r\n\r\nI feel like even if cbindgen is ultimately the \"cause\" of the bug, the expansion shouldn't be able to fail and not output anything without erroring (and returning `!= 0`) in some way.\r\n\r\n# Notes:\r\n\r\nPossibly relevant cbindgen code: https://github.com/eqrion/cbindgen/blob/master/src/bindgen/cargo/cargo_expand.rs#L129\r\ncbindgen issue: https://github.com/eqrion/cbindgen/issues/457\r\n\r\nThanks!", "labels": ["A-pretty", "T-compiler", "requires-nightly"], "number_of_comments": 1, "created_at": "2020-01-18 07:09:17", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551729098": {"author_username": "ZaneHannanAU", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68332, "title": "FR: impl core::ops::* for F where F: Fn {}", "body": "Was looking into making closures like\r\n\r\n```rust\r\n|x| !x.some_boolean_function()\r\n```\r\n\r\nor\r\n\r\n```rust\r\n|x| -x.some_numeric_function()\r\n```\r\n\r\ninto more simple manners by way of some closing structure; namely\r\n\r\n```rust\r\n!Structure::some_boolean_function\r\n```\r\n\r\nor\r\n\r\n```rust\r\n-Structure::some_numeric_function\r\n```\r\n\r\nfor something like\r\n\r\n```rust\r\nlet s: String = vec![\"hi \", \"there \", \"friend\", \"\", \".\"].into_iter().filter(!String::is_empty).collect();\r\n```\r\n\r\nor\r\n\r\n```rust\r\nlet neg = ::std::iter::successors(Some(1_i128), -|x| x.checked_mul(2));\r\n```\r\n\r\nor similar.\r\n\r\nWas hoping to figure it out with a simple one but... as it can be seen it takes some work and is not very nice to read through.\r\n\r\n`Neg` may be something to reconsider in this case...", "labels": ["S-waiting-on-review", "T-lang", "T-libs", "needs-fcp", "relnotes"], "number_of_comments": 18, "created_at": "2020-01-18 06:26:22", "reactions": {"total_count": 1, "+1": 1, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551685401": {"author_username": "Serentty", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68327, "title": "LLVM error compiling core and builtin functions using 16-bit pointers in data layout", "body": "I'm trying to compile Rust code to run in 386 real mode, where pointers larger than 2^16 aren't meaningful, even though there are 32-bit registers to work with. It works if I use full 32-bit pointers, but this is quite wasteful, so I've written my target JSON file to specify 16-bit pointers with 16-bit alignment in the LLVM data layout, and set ``target-pointer-width`` to 16. However, I get errors from LLVM itself trying to compiler certain functions in ``core`` and ``builtins``.\r\n\r\n```\r\nLLVM ERROR: Cannot select: 0x7f962aae09c0: i16 = GlobalAddress<<{ [8 x i8], i8*, [2 x i8] }>* @anon.d1d52a4f9fbe2e9a9c47ed4caed11e39.2.llvm.4753579327427470583> 0\r\nIn function: _ZN4core3num7dec2flt3num21compare_with_half_ulp17h4eb4cc321c32da3aE\r\nerror: could not compile `core`.\r\nwarning: build failed, waiting for other jobs to finish...\r\nLLVM ERROR: Cannot select: 0x7f75cd47f2d8: i16 = FrameIndex<-1>\r\nIn function: _ZN51_$LT$u64$u20$as$u20$compiler_builtins..int..Int$GT$12extract_sign17hef80dd72940759b7E\r\nerror: could not compile `compiler_builtins`.\r\n```", "labels": ["A-LLVM", "C-bug", "T-compiler"], "number_of_comments": 2, "created_at": "2020-01-17 23:58:11", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551636083": {"author_username": "wdanilo", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68324, "title": "Exponential compile time for the amount of impls.", "body": "## Summary\r\nHi! After generating over 200 impls with macros, my project **build time just grew from a few seconds to 3 hours**. Even worse, the compilation time grows exponentially in relation to the number of impls, so I'm reporting a bug. I do not have minimal repro, but I have an open-source code and a simple reproducible recipe.\r\n\r\n## Description\r\n- There is `pub struct Texture<StorageType,InternalFormat,ElemType>`.\r\n- `StorageType` is one of `Owned`, `GpuOnly`, and `RemoteImage`.\r\n- Combination `(InternalFormat, ElemType)` is approx 70 possibilities.\r\n\r\nThen we generate the following impls (if an impl mentions 2 types, then we generate it for each combination), where `(S,I,T)` stands for `(StorageType,InternalFormat,ElemType)`:\r\n\r\n```\r\nimpl InternalFormat for I {...}\r\nimpl TextureElement<T> for I {...}\r\n```\r\n\r\nWe also generate a single data type gathering all the texture types as variants:\r\n```\r\npub enum AnyTextureUniform {\r\n            $( S_I_T(Uniform<Texture<S,I,T>) ),*\r\n}\r\n```\r\n\r\nAnd a bunch of conversions like\r\n```\r\nimpl From<Uniform<Texture<S, I, T>>> for AnyUniform {...}\r\n```\r\n\r\nBasically, we can assume that for **EVERY TEXTURE TYPE WE GENERATE 3 VARIANTS AND APPROXIMATELY 18 IMPLS**.\r\n\r\nAnd now the not-fun part. For 8 texture types, it compiles 42s. For 16 types - 1.5 mins. For 32 types - 10 mins. We've got 70 texture types - it takes hours.\r\n\r\n## Analysis\r\n\r\nIt seems we've got exponential growth here. Here is a detailed statistics:\r\n\r\n![image](https://user-images.githubusercontent.com/1623053/72646521-a8415700-3976-11ea-80af-7392ac3d963f.png)\r\n\r\n\r\n## How to reproduce\r\n\r\n1. Clone the project: https://github.com/luna/ide/tree/wip/wd/rust-bug-68324\r\n2. Run `./scripts/watch.sh` - it will compile it and report the time.\r\n3. In the file `lib/core/src/system/gpu/data/texture.rs` uncomment some lines between 265 and 323. (Each line contains an array of types on the far right - the number of elements is the number of additional texture types we uncomment).\r\n4. Observe the time.\r\n\r\nThe generation of structs / impls is done in:\r\n- `lib/core/src/system/gpu/data/texture.rs` line 326\r\n- `lib/core/src/system/gpu/data/uniform.rs` line 269\r\n- `lib/core/src/system/gpu/data/uniform.rs` line 272\r\n- `lib/core/src/system/gpu/data/uniform.rs` line 290", "labels": ["C-bug", "E-needs-bisection", "E-needs-mcve", "I-compiletime", "P-high", "T-compiler"], "number_of_comments": 5, "created_at": "2020-01-17 21:17:59", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551631741": {"author_username": "Serentty", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68323, "title": "Compiler crashes with SIGSEGV when compiling core library with static relocation model", "body": "So, I'm compiling Rust programs to run on MS-DOS (386 real mode). This requires a static relocation model, and I can get many programs to compile and run by passing ``-C relocation-model=static`` during compilation and making sure that my linker flags include ``-fno-pie``. However, things went wrong when I tried to hook the I/O routines that I had written up to Rust's formatting macros. Trait implementations for ``core::fmt::Arguments`` start to get pulled in, and the linker complains that they are looking for _GLOBAL_OFFSET_TABLE_ despite the fact that the compiler shouldn't be generating code which needs that.\r\n\r\n```\r\nerror: linking with `cc` failed: exit code: 1\r\n  |\r\n  = note: \"cc\" \"-Wl,--as-needed\" \"-Wl,-z,noexecstack\" \"-Wl,--gc-sections\" \"-m16\" \"-nostdlib\" \"-march=i386\" \"-ffreestanding\" \"-fno-pie\" \"-Tcom.ld\" \"-L\" \"/home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib\" \"/home/seren/rusty-dos/target/dos/release/deps/dos-81645608ce9864b6.dos.dg1u0jr4-cgu.0.rcgu.o\" \"/home/seren/rusty-dos/target/dos/release/deps/dos-81645608ce9864b6.dos.dg1u0jr4-cgu.1.rcgu.o\" \"/home/seren/rusty-dos/target/dos/release/deps/dos-81645608ce9864b6.dos.dg1u0jr4-cgu.2.rcgu.o\" \"/home/seren/rusty-dos/target/dos/release/deps/dos-81645608ce9864b6.dos.dg1u0jr4-cgu.3.rcgu.o\" \"/home/seren/rusty-dos/target/dos/release/deps/dos-81645608ce9864b6.dos.dg1u0jr4-cgu.4.rcgu.o\" \"/home/seren/rusty-dos/target/dos/release/deps/dos-81645608ce9864b6.dos.dg1u0jr4-cgu.5.rcgu.o\" \"/home/seren/rusty-dos/target/dos/release/deps/dos-81645608ce9864b6.dos.dg1u0jr4-cgu.6.rcgu.o\" \"-o\" \"/home/seren/rusty-dos/target/dos/release/deps/dos-81645608ce9864b6.com\" \"-Wl,--gc-sections\" \"-no-pie\" \"-Wl,-zrelro\" \"-Wl,-znow\" \"-nodefaultlibs\" \"-L\" \"/home/seren/rusty-dos/target/dos/release/deps\" \"-L\" \"/home/seren/rusty-dos/target/release/deps\" \"-L\" \"/home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib\" \"-Wl,-Bstatic\" \"/home/seren/rusty-dos/target/dos/release/deps/libbitflags-e1a464dc3e355838.rlib\" \"/home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/librustc_std_workspace_core-490848ebf202e93d.rlib\" \"/home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib\" \"/home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcompiler_builtins-ae809761299d8c44.rlib\" \"-Wl,-Bdynamic\"\r\n  = note: /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.5.rcgu.o): in function `_ZN4core3fmt10ArgumentV110show_usize17h9290b20043846a9aE.llvm.11768198070876224222':\r\n          core.dffyupwt-cgu.5:(.text._ZN4core3fmt10ArgumentV110show_usize17h9290b20043846a9aE.llvm.11768198070876224222+0x17): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.5.rcgu.o): in function `core::fmt::ArgumentV1::from_usize':\r\n          core.dffyupwt-cgu.5:(.text._ZN4core3fmt10ArgumentV110from_usize17h306ac2fc1d8b66c1E+0xb): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.5.rcgu.o): in function `<core::fmt::Arguments as core::fmt::Debug>::fmt':\r\n          core.dffyupwt-cgu.5:(.text._ZN57_$LT$core..fmt..Arguments$u20$as$u20$core..fmt..Debug$GT$3fmt17h00de601147a33c89E+0x1c): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.5.rcgu.o): in function `<core::fmt::Arguments as core::fmt::Display>::fmt':\r\n          core.dffyupwt-cgu.5:(.text._ZN59_$LT$core..fmt..Arguments$u20$as$u20$core..fmt..Display$GT$3fmt17h8229c189564c851aE+0x1c): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.5.rcgu.o): in function `core::fmt::write':\r\n          core.dffyupwt-cgu.5:(.text._ZN4core3fmt5write17h1c6a04dbcbef5dc7E+0x82): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.5.rcgu.o):core.dffyupwt-cgu.5:(.text._ZN4core3fmt9Formatter8wrap_buf17hf8f3027e075f5fd5E+0xd0): more undefined references to `_GLOBAL_OFFSET_TABLE_' follow\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.12.rcgu.o): in function `<core::sync::atomic::AtomicI64 as core::fmt::Debug>::fmt':\r\n          core.dffyupwt-cgu.12:(.text._ZN66_$LT$core..sync..atomic..AtomicI64$u20$as$u20$core..fmt..Debug$GT$3fmt17hbc9f32d54d630799E+0x35): undefined reference to `__atomic_load_8'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.12.rcgu.o): in function `<core::sync::atomic::AtomicU64 as core::fmt::Debug>::fmt':\r\n          core.dffyupwt-cgu.12:(.text._ZN66_$LT$core..sync..atomic..AtomicU64$u20$as$u20$core..fmt..Debug$GT$3fmt17h2bacc92521ff782aE+0x1a): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: core.dffyupwt-cgu.12:(.text._ZN66_$LT$core..sync..atomic..AtomicU64$u20$as$u20$core..fmt..Debug$GT$3fmt17h2bacc92521ff782aE+0x3a): undefined reference to `__atomic_load_8'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.12.rcgu.o): in function `<&T as core::fmt::Debug>::fmt':\r\n          core.dffyupwt-cgu.12:(.text._ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17h05f349f183bd57f5E+0x1e): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.12.rcgu.o): in function `<&T as core::fmt::Debug>::fmt':\r\n          core.dffyupwt-cgu.12:(.text._ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17h1feb199478027b45E+0x1e): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.12.rcgu.o): in function `<&T as core::fmt::Debug>::fmt':\r\n          core.dffyupwt-cgu.12:(.text._ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17h25a1d98a3ec158d7E+0xd): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.12.rcgu.o): in function `<&T as core::fmt::Debug>::fmt':\r\n          core.dffyupwt-cgu.12:(.text._ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17h2ca09666842d4c7eE+0x1a): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.12.rcgu.o): in function `<&T as core::fmt::Debug>::fmt':\r\n          core.dffyupwt-cgu.12:(.text._ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17h348ad87268046417E+0x1e): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcore-86783f30f14d1df7.rlib(core-86783f30f14d1df7.core.dffyupwt-cgu.12.rcgu.o):core.dffyupwt-cgu.12:(.text._ZN42_$LT$$RF$T$u20$as$u20$core..fmt..Debug$GT$3fmt17h3eb6f5e1d37d7ffdE+0x1e): more undefined references to `_GLOBAL_OFFSET_TABLE_' follow\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcompiler_builtins-ae809761299d8c44.rlib(compiler_builtins-ae809761299d8c44.compiler_builtins.85hciet7-cgu.7.rcgu.o): in function `__llvm_memcpy_element_unordered_atomic_8':\r\n          compiler_builtins.85hciet7-cgu.7:(.text.__llvm_memcpy_element_unordered_atomic_8+0x47): undefined reference to `__atomic_load_8'\r\n          /usr/sbin/ld: compiler_builtins.85hciet7-cgu.7:(.text.__llvm_memcpy_element_unordered_atomic_8+0x5a): undefined reference to `__atomic_store_8'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcompiler_builtins-ae809761299d8c44.rlib(compiler_builtins-ae809761299d8c44.compiler_builtins.85hciet7-cgu.7.rcgu.o): in function `__llvm_memmove_element_unordered_atomic_8':\r\n          compiler_builtins.85hciet7-cgu.7:(.text.__llvm_memmove_element_unordered_atomic_8+0x15): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: compiler_builtins.85hciet7-cgu.7:(.text.__llvm_memmove_element_unordered_atomic_8+0x5a): undefined reference to `__atomic_load_8'\r\n          /usr/sbin/ld: compiler_builtins.85hciet7-cgu.7:(.text.__llvm_memmove_element_unordered_atomic_8+0x6d): undefined reference to `__atomic_store_8'\r\n          /usr/sbin/ld: compiler_builtins.85hciet7-cgu.7:(.text.__llvm_memmove_element_unordered_atomic_8+0xa7): undefined reference to `__atomic_load_8'\r\n          /usr/sbin/ld: compiler_builtins.85hciet7-cgu.7:(.text.__llvm_memmove_element_unordered_atomic_8+0xba): undefined reference to `__atomic_store_8'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcompiler_builtins-ae809761299d8c44.rlib(compiler_builtins-ae809761299d8c44.compiler_builtins.85hciet7-cgu.7.rcgu.o): in function `__llvm_memset_element_unordered_atomic_8':\r\n          compiler_builtins.85hciet7-cgu.7:(.text.__llvm_memset_element_unordered_atomic_8+0x17): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: compiler_builtins.85hciet7-cgu.7:(.text.__llvm_memset_element_unordered_atomic_8+0xaf): undefined reference to `__atomic_store_8'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcompiler_builtins-ae809761299d8c44.rlib(compiler_builtins-ae809761299d8c44.compiler_builtins.85hciet7-cgu.10.rcgu.o): in function `__divdi3':\r\n          compiler_builtins.85hciet7-cgu.10:(.text.__divdi3+0x13): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcompiler_builtins-ae809761299d8c44.rlib(compiler_builtins-ae809761299d8c44.compiler_builtins.85hciet7-cgu.10.rcgu.o): in function `__divti3':\r\n          compiler_builtins.85hciet7-cgu.10:(.text.__divti3+0x1e): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcompiler_builtins-ae809761299d8c44.rlib(compiler_builtins-ae809761299d8c44.compiler_builtins.85hciet7-cgu.10.rcgu.o): in function `__moddi3':\r\n          compiler_builtins.85hciet7-cgu.10:(.text.__moddi3+0x11): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcompiler_builtins-ae809761299d8c44.rlib(compiler_builtins-ae809761299d8c44.compiler_builtins.85hciet7-cgu.10.rcgu.o): in function `__modti3':\r\n          compiler_builtins.85hciet7-cgu.10:(.text.__modti3+0x1e): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          /usr/sbin/ld: /home/seren/rusty-dos/target/sysroot/lib/rustlib/dos/lib/libcompiler_builtins-ae809761299d8c44.rlib(compiler_builtins-ae809761299d8c44.compiler_builtins.85hciet7-cgu.10.rcgu.o): in function `__divmoddi4':\r\n          compiler_builtins.85hciet7-cgu.10:(.text.__divmoddi4+0x13): undefined reference to `_GLOBAL_OFFSET_TABLE_'\r\n          collect2: error: ld returned 1 exit status\r\n```", "labels": ["A-linkage", "C-bug", "T-compiler"], "number_of_comments": 10, "created_at": "2020-01-17 21:06:42", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551620613": {"author_username": "jonas-schievink", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68322, "title": "`#[used]` should work on functions", "body": "Currently `#[used]` only works on static items. It would be more consistent and useful if it also worked on functions.\r\n\r\nMy motivation for this is to prevent some cases of user errors when using `cortex-m-rt`'s `#[exception]` and `#[interrupt]` attributes. As can be seen in [this test](https://github.com/rust-embedded/cortex-m-rt/blob/master/tests/compile-fail/default-handler-hidden.rs), it is possible to use those inside of private modules, which results in the function never ending up in the binary.\r\n\r\nNote that `#[used]` cannot be made to work on functions that have generics in scope, since those can end up producing arbitrary monomorphizations depending on the parameters (and there's no single canonical thing that `#[used]` would make show up in the binary).", "labels": ["A-attributes", "A-linkage", "C-feature-request", "T-lang", "WG-embedded"], "number_of_comments": 0, "created_at": "2020-01-17 20:37:26", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551594354": {"author_username": "nikomatsakis", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68318, "title": "Tracking issue for negative impls", "body": "Generalized negative impls were introduced in https://github.com/rust-lang/rust/pull/68004. They were split out from \"opt-in builtin traits\" (https://github.com/rust-lang/rust/issues/13231). \r\n\r\n## XXX\r\n\r\nThis issue was added in advance of #68004 landed so that I could reference it from within the code. It will be closed if we opt not to go this direction. \r\n\r\n## Unresolved questions to be addressed through design process\r\n\r\n* What should the WF requirements be? ([Context](https://github.com/rust-lang/rust/pull/68004#discussion_r367586615))\r\n* Should we permit combining default + negative impls like `default impl !Trait for Type { }`? ([Context](https://github.com/rust-lang/rust/pull/68004#discussion_r367588811))", "labels": ["C-tracking-issue", "T-lang"], "number_of_comments": 0, "created_at": "2020-01-17 19:32:49", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551378298": {"author_username": "jazzfool", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68309, "title": "Specialization should allow for delegation to default trait method implementation", "body": "Given the following trait:\r\n```rust\r\ntrait Trait {\r\n    fn test(&self) { println!(\"default implementation\"); }\r\n}\r\n```\r\nTo provide a default specialization on `Trait::test`, `test` must be redefined;\r\n```rust\r\nimpl<T> Trait for T {\r\n    default fn test(&self) { println!(\"default implementation\"); }\r\n}\r\n```\r\nHowever this violates the DRY principle. The solution here would be to provide a way to delegate the implementation of `test` to the already existing default implementation found in the trait definition.\r\n\r\nProposed syntax to allow for this delegation:\r\n```rust\r\nimpl<T> Trait for T {\r\n    default fn test(&self);\r\n}\r\n```", "labels": ["A-specialization", "C-feature-request", "F-associated_type_defaults", "F-specialization", "T-lang"], "number_of_comments": 4, "created_at": "2020-01-17 12:05:43", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551354982": {"author_username": "Zoxc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68308, "title": "Parallel tweaks 2", "body": "Based on https://github.com/rust-lang/rust/pull/67870.\r\n\r\nr? @michaelwoerister ", "labels": ["S-waiting-on-author"], "number_of_comments": 1, "created_at": "2020-01-17 11:13:15", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551293096": {"author_username": "llogiq", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68306, "title": "Feature request: Make queries more discoverable", "body": "We already have the `rustc_queries!` macro, so we should create a script (similar to clippy's `clippy_dev update_lints`) that builds a list of queries with their arguments and description to add to the rustc guide, to make existing queries more discoverable.", "labels": ["C-feature-request", "T-compiler", "T-doc"], "number_of_comments": 0, "created_at": "2020-01-17 09:11:22", "reactions": {"total_count": 2, "+1": 2, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551202876": {"author_username": "programmerjake", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68304, "title": "Box<dyn FnOnce> doesn't respect self alignment", "body": "The following code fails on stable:\r\nWhen compiled in release mode, the `\"optimized out\"` assert is optimized out by LLVM even though it checks the exact same condition as the other assert, as can be verified by testing in debug mode.\r\n\r\nNote that it's theoretically possible for the stack to be aligned correctly such that the bug is suppressed, but that's not likely. The 256's can be replaced with larger alignments if that happens.\r\n\r\nThe bug is caused by the impl of `Box<dyn FnOnce>` copying `self` to the stack with the default alignment of 16.\r\n\r\n```rust\r\n#![allow(dead_code)]\r\n#[repr(align(256))]\r\nstruct A {\r\n    v: u8\r\n}\r\n\r\nimpl A {\r\n    fn f(&self) -> *const A {\r\n        assert_eq!(self as *const A as usize % 256, 0, \"optimized out\");\r\n        self\r\n    }\r\n}\r\n\r\nfn f2(v: u8) -> Box<dyn FnOnce() -> *const A> {\r\n    let a = A { v };\r\n    Box::new(move || {\r\n        a.f()\r\n    })\r\n}\r\n\r\n#[test]\r\nfn test() {\r\n    let addr = f2(0)();\r\n    assert_eq!(addr as usize % 256, 0, \"addr: {:?}\", addr);\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=bd447ff2503b311c957b469eb26ed8e6))", "labels": ["A-dst", "C-bug", "F-unsized_locals", "I-nominated", "I-unsound \ud83d\udca5", "P-high", "T-compiler"], "number_of_comments": 15, "created_at": "2020-01-17 05:10:35", "reactions": {"total_count": 1, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551117187": {"author_username": "matthiaskrgr", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68296, "title": "ICE mutable allocation in constant   ui/associated-type-bounds/union-bounds.rs with  -Zmir-opt-level=2", "body": "` RUST_BACKTRACE=1 rustc ui/associated-type-bounds/union-bounds.rs  -Zmir-opt-level=2`\r\n\r\n````\r\nerror: internal compiler error: mutable allocation in constant\r\n\r\nthread 'rustc' panicked at 'no errors encountered even though `delay_span_bug` issued', src/librustc_errors/lib.rs:346:17\r\nstack backtrace:\r\n   0: backtrace::backtrace::libunwind::trace\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88\r\n   1: backtrace::backtrace::trace_unsynchronized\r\n             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66\r\n   2: std::sys_common::backtrace::_print_fmt\r\n             at src/libstd/sys_common/backtrace.rs:77\r\n   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt\r\n             at src/libstd/sys_common/backtrace.rs:59\r\n   4: core::fmt::write\r\n             at src/libcore/fmt/mod.rs:1057\r\n   5: std::io::Write::write_fmt\r\n             at src/libstd/io/mod.rs:1426\r\n   6: std::sys_common::backtrace::_print\r\n             at src/libstd/sys_common/backtrace.rs:62\r\n   7: std::sys_common::backtrace::print\r\n             at src/libstd/sys_common/backtrace.rs:49\r\n   8: std::panicking::default_hook::{{closure}}\r\n             at src/libstd/panicking.rs:204\r\n   9: std::panicking::default_hook\r\n             at src/libstd/panicking.rs:224\r\n  10: rustc_driver::report_ice\r\n  11: std::panicking::rust_panic_with_hook\r\n             at src/libstd/panicking.rs:476\r\n  12: std::panicking::begin_panic\r\n  13: <rustc_errors::HandlerInner as core::ops::drop::Drop>::drop\r\n  14: core::ptr::real_drop_in_place\r\n  15: core::ptr::real_drop_in_place\r\n  16: core::ptr::real_drop_in_place\r\n  17: rustc_interface::interface::run_compiler_in_existing_thread_pool\r\n  18: scoped_tls::ScopedKey<T>::set\r\n  19: syntax::with_globals\r\nnote: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.\r\n\r\nerror: internal compiler error: unexpected panic\r\n\r\nnote: the compiler unexpectedly panicked. this is a bug.\r\n\r\nnote: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports\r\n\r\nnote: rustc 1.42.0-nightly (3291ae339 2020-01-15) running on x86_64-unknown-linux-gnu\r\n\r\nnote: compiler flags: -Z mir-opt-level=2\r\n\r\nquery stack during panic:\r\nend of query stack\r\n````\r\n\r\n\r\nsomewhat reduced:\r\n````rust\r\n#![feature(associated_type_bounds)]\r\n#![feature(untagged_unions)]\r\n\r\n#![allow(unused_assignments)]\r\n\r\ntrait Tr1: Copy { type As1: Copy; }\r\ntrait Tr4<'a>: Copy { type As4: Copy; }\r\nimpl Tr1 for &str { type As1 = bool; }\r\nimpl Tr1 for () { type As1 = (usize,); }\r\nimpl<'a> Tr4<'a> for (usize,) { type As4 = u8; }\r\n\r\nunion Un4<'x1, T: Tr1<As1: for<'l> Tr4<'l>>> {\r\n    f1: &'x1 <T::As1 as Tr4<'x1>>::As4,\r\n}\r\n\r\nfn main() {\r\n    let f1 = (1,);\r\n    let _ = Un4::<()> { f1: &f1.0 };\r\n}\r\n````\r\n\r\nrustc @ 9fe05e9456b84996637c2f29b35c37960e537540", "labels": ["A-mir", "C-bug", "I-ICE", "T-compiler", "glacier", "requires-nightly"], "number_of_comments": 2, "created_at": "2020-01-16 23:38:36", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551111704": {"author_username": "aweinstock314", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68295, "title": "ICE in librustc::traits::select::confirm_param_candidate", "body": "Error message: ```error: internal compiler error: src/librustc/traits/select.rs:2922: Where clause `Binder(<base::default_allocator::DefaultAllocator as base::allocator::Allocator<N, R, C>>)` was applicable to `Obligation(predicate=Binder(TraitPredicate(<base::default_allocator::DefaultAllocator as base::allocator::Allocator<_, _, _>>)), depth=1)` but now is not```\r\n\r\nCommit that reproduces the issue: https://github.com/aweinstock314/nalgebra/commit/5106e2dd9e805424132d3c79d21b75a3ad338122\r\n\r\nI get the same error (except for the exact line number) on 1.38, 1.40, beta, and a couple of nightlies.\r\n\r\nThe other issues reachable via the query `is:issue is:open ICE \"but now is not\"` (#62742 and #55765) are both about the `\"was matchable against\"` `bug!` invocation at https://github.com/rust-lang/rust/blob/48840618382eccb8a799320c8e5d08e3b52f4c42/src/librustc/traits/select.rs#L3464, this `bug!` invocation is at https://github.com/rust-lang/rust/blob/48840618382eccb8a799320c8e5d08e3b52f4c42/src/librustc/traits/select.rs#L2781, so this is unlikely to be a duplicate.\r\n\r\nI haven't yet tried to minimize this: The commit beforehand (1 line difference) on the same nalgebra branch is a compile-fail due to a trait method not being found, and I'm still trying to figure out if that one's a bug in my code.", "labels": ["A-associated-items", "A-traits", "A-typesystem", "C-bug", "E-needs-mcve", "I-ICE", "P-high", "T-compiler"], "number_of_comments": 11, "created_at": "2020-01-16 23:21:05", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "551104806": {"author_username": "sunjay", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68293, "title": "Suggest examples of format specifiers in error messages", "body": "This is [real code](https://twitter.com/Sunjay03/status/1217930353874276352) that someone I am helping learn Rust wrote today. It's a problem you could easily stare at for hours and never figure it out. Especially if you're new to using format strings. The code actually looks **correct** (from a distance).\r\n\r\n```rust\r\nfn main() {\r\n    println!(\":#?\", vec![123]);\r\n}\r\n```\r\n\r\nHere's the error message we produce:\r\n\r\n```rust\r\nerror: argument never used\r\n --> src/main.rs:2:21\r\n  |\r\n2 |     println!(\":#?\", vec![123]);\r\n  |              -----  ^^^^^^^^^ argument never used\r\n  |              |\r\n  |              formatting specifier missing\r\n```\r\n\r\nThe person I was helping assumed that some formatting trait hadn't been implemented. It didn't occur to them that the format specifier was incorrect even though it said \"formatting specifier missing\".\r\n\r\nI think we could help them by adding a hint or something that shows an example of a specifier whenever we say \"formatting specifier missing\".\r\n\r\nSomething like:\r\n\r\n```\r\nhint: format specifiers usually look like `{}` or `{:?}`\r\n```\r\n\r\nThis would then help them compare against what they have and find the problem sooner.\r\n\r\nFrom @estebank: ([source](https://twitter.com/ekuber/status/1217936806269710336))\r\n\r\n> We already handle C-style formatting strings and provide an appropriate suggestion, so I think this would also be reasonable to handle this.\r\n> ```rust\r\n> fn main() {\r\n>     println!(\"%d\", 42);\r\n> }\r\n> ```\r\n>\r\n> Adding logic to [here](https://github.com/rust-lang/rust/blob/48840618382eccb8a799320c8e5d08e3b52f4c42/src/librustc_builtin_macros/format_foreign.rs) should be relatively straightforward.\r\n>\r\n> Also, this case should also be slightly tweaked to point at the formatting\r\n> specifiers that *were* found:\r\n>\r\n> ```rust\r\n> fn main() {\r\n>     println!(\"{} :#?\", 1, 42);\r\n> }\r\n> ```", "labels": ["A-diagnostics", "A-suggestion-diagnostics", "C-enhancement", "T-compiler"], "number_of_comments": 2, "created_at": "2020-01-16 23:01:17", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "550601606": {"author_username": "0e4ef622", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68273, "title": "Unexpected 'static lifetime requirement", "body": "Attempting to compile\r\n\r\n```rust\r\ntrait Trait<T> { }\r\nimpl<A: Trait<T> + ?Sized, T> Trait<T> for Box<A> { }\r\n\r\nfn foo<T>(s: &Box<dyn Trait<T>>) {\r\n    let _: &(dyn Trait<T> + 'static) = s;\r\n}\r\n```\r\n\r\nyields the following error.\r\n\r\n```\r\nerror[E0310]: the parameter type `T` may not live long enough\r\n --> src/lib.rs:5:40\r\n  |\r\n4 | fn foo<T>(s: &Box<dyn Trait<T>>) {\r\n  |        - help: consider adding an explicit lifetime bound `T: 'static`...\r\n5 |     let _: &(dyn Trait<T> + 'static) = s;\r\n  |                                        ^\r\n  |\r\nnote: ...so that the type `std::boxed::Box<(dyn Trait<T> + 'static)>` will meet its required lifetime bounds\r\n --> src/lib.rs:5:40\r\n  |\r\n5 |     let _: &(dyn Trait<T> + 'static) = s;\r\n  |                                        ^\r\n```\r\n\r\nHowever, changing the line mentioned in the error to `let _: &(dyn Trait<T> + 'static) = &**s;` allows the code to compile.\r\n\r\nThe former attempts to coerce the `Box` itself to a trait object, while the latter simply takes a reference to the trait object within the `Box`, although I fail to understand why the former shouldn't work when the latter does. My guess is that the lifetime of the `Box` is bounded to the lifetime of `T` unnecessarily.", "labels": [], "number_of_comments": 0, "created_at": "2020-01-16 06:28:17", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "550471066": {"author_username": "tmandry", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68262, "title": "Support whole program devirtualization", "body": "When doing LTO, LLVM supports a devirtualization pass that converts some indirect calls to static, inlineable calls. This can unlock a lot of optimizations when dynamic dispatch is used frequently in a program.\r\n\r\nI don't know how hard this would be to support in Rust. Clang has a flag `-fwhole-program-vtables` which we would need to emulate. From there it seems like it might \"just work\". I'm opening this issue to start collecting more information.\r\n\r\nI also found #11915 which mentions this, but not sure if any of the information there is still accurate.", "labels": ["A-LLVM", "A-traits", "C-enhancement", "T-compiler"], "number_of_comments": 1, "created_at": "2020-01-15 22:43:41", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "550410338": {"author_username": "matthewjasper", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68261, "title": "Don't infer regions in type checking", "body": "This is a tracking issue for avoiding region inference in item body type checking. The goal would be to use `ReErased` where we currently use `ReVar` as much as possible.\r\n\r\nThe motivations for this are:\r\n\r\n* It would avoid doing region inference twice (once in typeck, once in borrowck).\r\n* It might improve caching since there are fewer distinct types.\r\n* It ensures that region inference cannot affect later passes.\r\n\r\ncc @nikomatsakis ", "labels": ["A-NLL", "A-inference", "A-lifetimes", "C-enhancement", "T-compiler"], "number_of_comments": 1, "created_at": "2020-01-15 20:24:08", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "550406908": {"author_username": "joshtriplett", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68260, "title": "lint on dbg! of non-reference with return value not used", "body": "The `dbg!` macro takes its argument by value, so that it can return that same value. See https://github.com/rust-lang/rust/issues/59943 for some background.\r\n\r\nWe should lint on code that calls `dbg!` on a non-reference value (thus consuming that value) and doesn't do anything with the return value. The lint could suggest taking a reference.", "labels": ["A-lint", "C-feature-request", "T-lang"], "number_of_comments": 2, "created_at": "2020-01-15 20:16:43", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "550406000": {"author_username": "christianpoveda", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68259, "title": "Miri environ shim", "body": "r? @RalfJung ", "labels": ["S-waiting-on-author"], "number_of_comments": 2, "created_at": "2020-01-15 20:14:50", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "550342055": {"author_username": "DrGabble", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68257, "title": "Cannot use generic const argument without `{}`, despite no conflict", "body": "I would expect this code to compile, but it does not:\r\n\r\n```rust\r\n#![feature(const_generics)]\r\n\r\nstruct Foo<const A: usize, const B: usize> {\r\n    a: [usize; A],\r\n    b: [usize; B],\r\n}\r\n\r\nimpl<const A: usize> Foo<A, 1> {\r\n    fn get_b(&self) -> usize {\r\n        self.b[0]\r\n    }\r\n}\r\n\r\nimpl<const B: usize> Foo<1, B> {\r\n    fn get_a(&self) -> usize {\r\n        self.a[0]\r\n    }\r\n}\r\n\r\n\r\nfn main() {\r\n    let foo = Foo { a: [0, 3], b: [0] };\r\n    dbg!(foo.get_b());\r\n}\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=00aba90934a80e43114bae17991b8caf))\r\n\r\nErrors:\r\n\r\n```\r\n   Compiling playground v0.0.1 (/playground)\r\nerror: type arguments must be declared prior to const arguments\r\n  --> src/main.rs:14:29\r\n   |\r\n14 | impl<const B: usize> Foo<1, B> {\r\n   |                             ^\r\n\r\nerror: aborting due to previous error\r\n\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n\r\n```", "labels": ["A-const-generics", "C-bug", "F-const_generics", "T-compiler", "requires-nightly"], "number_of_comments": 7, "created_at": "2020-01-15 17:59:29", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "550139919": {"author_username": "crlf0710", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68245, "title": "Expand `unreachable_code` lint to support detecting unreachable code after panicking.", "body": "This seems a useful lint, but I'm not sure whether this is implementable in `clippy`.", "labels": ["A-lint", "C-feature-request", "T-compiler", "T-lang"], "number_of_comments": 6, "created_at": "2020-01-15 11:51:29", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "550040715": {"author_username": "olegnn", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68243, "title": "Invalid help message for borrowed function argument", "body": "For this code\r\n```rust\r\nfn main() {\r\n    let _: Vec<_> = vec![Ok::<_, ()>(vec![0]); 5]\r\n        .into_iter()\r\n        .filter(|&vec| vec.unwrap().len() > 5)\r\n        .collect();\r\n}\r\n\r\n```\r\n\r\n([Playground](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=0226b59f901fd6c90a0179b3b5485f69))\r\n\r\nCompiler produces following output (it's basically the same on all channels)\r\n```\r\nerror[E0507]: cannot move out of a shared reference\r\n --> src/main.rs:4:18\r\n  |\r\n4 |         .filter(|&vec| vec.unwrap().len() > 5)\r\n  |                  ^---\r\n  |                   |\r\n  |                   data moved here\r\n  |                   move occurs because `vec` has type `std::result::Result<std::vec::Vec<i32>, ()>`, which does not implement the `Copy` trait\r\n  |\r\nhelp: consider borrowing the `Result`'s content\r\n  |\r\n4 |         .filter(|&vec.as_ref()| vec.unwrap().len() > 5)\r\n  |                  ^^^^^^^^^^^^^\r\nhelp: consider removing the `&`\r\n  |\r\n4 |         .filter(|vec| vec.unwrap().len() > 5)\r\n  |                  ^^^\r\n\r\nerror: aborting due to previous error\r\n\r\nFor more information about this error, try `rustc --explain E0507`.\r\nerror: could not compile `playground`.\r\n\r\nTo learn more, run the command again with --verbose.\r\n```\r\nWith invalid help message\r\n```\r\nhelp: consider borrowing the `Result`'s content\r\n  |\r\n4 |         .filter(|&vec.as_ref()| vec.unwrap().len() > 5)\r\n```\r\n- It's syntactically invalid. \r\n- It doesn't remove `&` which means it attempts to borrow borrowed value.\r\n\r\nOnly second help message may help. It works with options the same way.", "labels": ["A-diagnostics", "A-suggestion-diagnostics", "C-bug", "D-invalid-suggestion", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-15 08:38:07", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "549897247": {"author_username": "xobs", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68238, "title": "cargo test gives bad advice when given invalid target", "body": "<!-- Thanks for filing a \ud83d\udc1b bug report \ud83d\ude04! -->\r\n\r\n**Problem**\r\n<!-- A clear and concise description of what the bug is. -->\r\n<!-- including what currently happens and what you expected to happen. -->\r\nIt is possible to run tests for various targets using `cargo test --target [triple]`.  When given an invalid triple, cargo indicates the user should run `--print target-list` for help.  However, this is not valid advice.\r\n\r\n**Steps**\r\n<!-- The steps to reproduce the bug. -->\r\n1. Run `cargo test --target invalid-target`\r\n2. Run the suggested `cargo test --print target-list`\r\n\r\n**Possible Solution(s)**\r\n<!-- Not obligatory, but suggest a fix/reason for the bug, -->\r\n<!-- or ideas how to implement the addition or change -->\r\ncargo should implement `--print target-list`, or the advice should be removed.\r\n\r\n**Notes**\r\n\r\nOutput of `cargo version`: cargo 1.40.0 (bc8e4c8be 2019-11-22)\r\n\r\n<!-- Also, any additional context or information you feel may be relevant to the issue. -->\r\n<!-- (e.g rust version, OS platform/distribution/version, target toolchain(s), release channel.. -->\r\n```\r\n$ cargo test --target invalid-target\r\nerror: failed to run `rustc` to learn about target-specific information\r\n\r\nCaused by:\r\n  process didn't exit successfully: `rustc - --crate-name ___ --print=file-names --target invalid-target --crate-type bin --crate-type rlib --crate-type dylib --crate-type cdylib --crate-type staticlib --crate-type proc-macro --print=sysroot --print=cfg` (exit code: 1)\r\n--- stderr\r\nerror: Error loading target specification: Could not find specification for target \"invalid-target\"\r\n  |\r\n  = help: Use `--print target-list` for a list of built-in targets\r\n\r\n\r\n$ cargo test --print target-list\r\nerror: Found argument '--print' which wasn't expected, or isn't valid in this context\r\n\r\nUSAGE:\r\n    cargo.exe test [OPTIONS] [TESTNAME] [-- <args>...]\r\n\r\nFor more information try --help\r\n$\r\n...", "labels": ["A-diagnostics", "C-enhancement", "D-confusing", "T-compiler"], "number_of_comments": 2, "created_at": "2020-01-14 21:13:47", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "549857758": {"author_username": "Mark-Simulacrum", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68235, "title": "Sealed traits for rustdoc", "body": "In #67562, it was proposed to make `trait Any` an unsafe trait. This was ultimately rejected, as we do not currently want downstream users to see that it is unsafe. However, we wanted a way to have both. The suggestion is that rustdoc could have an (unstable, for now) attribute that indicates that a trait is \"sealed,\" in the sense that no upstream impls are permitted.\r\n\r\nrustdoc would then show this trait as unimplementable. It would not show any unsafety on the trait (as it is then irrelevant to readers of the documentation).\r\n\r\nSee https://github.com/rust-lang/rust/pull/67562#issuecomment-572102876, https://github.com/rust-lang/rust/pull/67562#issuecomment-572909100.", "labels": ["T-rustdoc"], "number_of_comments": 0, "created_at": "2020-01-14 22:34:10", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "549813906": {"author_username": "carllerche", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68228, "title": "declarative macro results in `rustc` entering infinite loop", "body": "Rustc: `rustc 1.40.0 (73528e339 2019-12-16)`\r\n\r\n`uname -a`: Darwin Carls-MacBook-Pro-2.local 18.7.0 Darwin Kernel Version 18.7.0: Sun Dec  1 18:59:03 PST 2019; root:xnu-4903.278.19~1/RELEASE_X86_64 x86_64\r\n\r\nI have crafted a declarative macro that results in `rustc` entering an infinite loop and never completing.\r\n\r\nRepro:\r\n\r\n```rust\r\n#[macro_export]\r\nmacro_rules! lock {\r\n    // Done normalizing\r\n    (@ { $($t:tt)* }) => {\r\n    };\r\n    (@ { $($t:tt)* } $a:pat, $b:expr, $c:block $($r:tt)* ) => {\r\n        $crate:lock!(@{ $($t)* $a,$b, $c, } $($r)*)\r\n\r\n    };\r\n    ( $($t:tt)* ) => {\r\n        $crate::lock!(@{} $($t:tt)*)\r\n    }\r\n}\r\n\r\nfn main() {\r\n    lock! {\r\n        foo, bar(), {\r\n            println!(\"WAT!\");\r\n        }\r\n    }\r\n}\r\n```", "labels": ["I-hang"], "number_of_comments": 1, "created_at": "2020-01-14 20:56:39", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "549708343": {"author_username": "vallentin", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68220, "title": "Diagnostics show different expected and found types", "body": "Found a case where the diagnostics show an incorrect type (missing `&`), when calling slice methods taking `&T`, if the slice is e.g. `[&T]`, `[&&T]`, etc.\r\n\r\nThus the diagnostics are incorrect for e.g. `[&str]`, `[&i32]`, `[&&bool]`, but are correct for e.g. `[i32]`.\r\n\r\n---\r\n\r\n### Unexpected - Example 1\r\n\r\nCalling `contains` on `[&str]` incorrectly with a `&str` (instead of `&&str`). Then the highlighted line says `expected &str` (wrong) and the note after says `expected type &&str` (correct).\r\n\r\n```rust\r\nlet arr = [\"A\", \"B\", \"C\"];\r\narr.contains(\"B\");\r\n```\r\n\r\n#### Diagnostics\r\n\r\n```\r\nerror[E0308]: mismatched types                                             \r\n  --> src\\main.rs:24:18\r\n   |\r\n24 |     arr.contains(\"B\");\r\n   |                  ^^^ expected &str, found str\r\n   |\r\n   = note: expected type `&&str`\r\n              found type `&'static str`\r\n```\r\n\r\n---\r\n\r\n### Unexpected - Example 2\r\n\r\nSecond example using a `const` `[&i32]` and calling `binary_search` incorrectly.\r\n\r\n```rust\r\nconst ARR: [&i32; 3] = [&1, &2, &3];\r\nARR.binary_search(&2);\r\n```\r\n\r\n#### Diagnostics\r\n\r\n```\r\nerror[E0308]: mismatched types                                            \r\n  --> src\\main.rs:22:23\r\n   |\r\n22 |     ARR.binary_search(&2);\r\n   |                       ^^ expected &i32, found integer\r\n   |\r\n   = note: expected type `&&i32`\r\n              found type `&{integer}\r\n```\r\n\r\n---\r\n\r\n### Unexpected - Example 3\r\n\r\n```rust\r\nconst ARR: [&&bool; 3] = [&&true, &&true, &&true];\r\nARR.contains(&&true);\r\n```\r\n\r\n#### Diagnostics\r\n\r\n```\r\nerror[E0308]: mismatched types\r\n  --> src\\main.rs:11:18\r\n   |\r\n11 |     ARR.contains(&&true);\r\n   |                  ^^^^^^ expected &bool, found bool\r\n   |\r\n   = note: expected type `&&&bool`\r\n              found type `&&bool`\r\n```\r\n\r\n---\r\n\r\n### Expected - Example 1\r\n\r\nJust to reiterate, using `[i32]` instead of `[&i32]` results in the expected error.\r\n\r\n```rust\r\nlet arr = [1, 2, 3];\r\narr.contains(2);\r\n```\r\n\r\n#### Diagnostics\r\n\r\n```rust\r\nerror[E0308]: mismatched types                                            \r\n  --> src\\main.rs:32:18\r\n   |\r\n32 |     arr.contains(2);\r\n   |                  ^\r\n   |                  |\r\n   |                  expected &{integer}, found integer\r\n   |                  help: consider borrowing here: `&2`\r\n   |\r\n   = note: expected type `&{integer}`\r\n              found type `{integer}`\r\n```\r\n\r\n---\r\n\r\n```\r\n$ rustc --version --verbose\r\nrustc 1.40.0 (73528e339 2019-12-16)\r\nbinary: rustc\r\ncommit-hash: 73528e339aae0f17a15ffa49a8ac608f50c6cf14\r\ncommit-date: 2019-12-16\r\nhost: x86_64-pc-windows-msvc\r\nrelease: 1.40.0\r\nLLVM version: 9.0\r\n```", "labels": ["A-diagnostics", "C-enhancement", "D-incorrect", "T-compiler"], "number_of_comments": 0, "created_at": "2020-01-14 17:19:33", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "549646500": {"author_username": "Zoxc", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68218, "title": "[WIP] More parallel tweaks", "body": "Based on https://github.com/rust-lang/rust/pull/67870, https://github.com/rust-lang/rust/pull/68171 and https://github.com/rust-lang/rust/pull/67888.\r\n\r\nr? @michaelwoerister ", "labels": ["S-waiting-on-author"], "number_of_comments": 7, "created_at": "2020-01-14 15:35:31", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}, "549589543": {"author_username": "GuillaumeGomez", "repository_url": "https://api.github.com/repos/rust-lang/rust", "issue_number": 68217, "title": "Don't render text from implementors file", "body": "Currently, we generate some HTML directly into the implementors file which is then used to add the missing implementors on some traits. This shouldn't be done this way, instead we should just provide the needed information and then generate the tag on the front-end to prevent some malicious insertions.", "labels": ["T-rustdoc"], "number_of_comments": 0, "created_at": "2020-01-14 14:04:53", "reactions": {"total_count": 0, "+1": 0, "-1": 0, "laugh": 0, "heart": 0, "hooray": 0}}}